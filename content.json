{"meta":{"title":"王天阳的个人博客","subtitle":"","description":"学习｜记录｜心情","author":"王天阳","url":"https://wangtianyang.com","root":"/"},"pages":[{"title":"","date":"2023-01-05T08:03:47.035Z","updated":"2023-01-05T08:03:47.035Z","comments":true,"path":"baidu_verify_code-duQSFyAuCD.html","permalink":"https://wangtianyang.com/baidu_verify_code-duQSFyAuCD.html","excerpt":"","text":"d2df00e100c8b43af695545aa68290bd layout: false"},{"title":"about","date":"2023-01-05T09:35:51.000Z","updated":"2023-01-05T09:35:51.208Z","comments":true,"path":"about/index-1.html","permalink":"https://wangtianyang.com/about/index-1.html","excerpt":"","text":""},{"title":"about","date":"2023-01-05T09:36:52.000Z","updated":"2023-01-05T09:36:52.684Z","comments":true,"path":"about/index-2.html","permalink":"https://wangtianyang.com/about/index-2.html","excerpt":"","text":""},{"title":"关于我","date":"2022-01-13T05:40:34.000Z","updated":"2023-01-05T08:03:47.034Z","comments":true,"path":"about/index.html","permalink":"https://wangtianyang.com/about/index.html","excerpt":"","text":"97年生人，籍贯上海，本科毕业于北京邮电大学，现于北京邮电大学就读研究生，专业所属信息与通信工程学院。研究方向：平均场 有效容量 流体天线专业技能：熟练运用C++、Java、Python，了解JavaScript"},{"title":"archives","date":"2022-01-12T09:44:28.000Z","updated":"2023-01-05T08:03:47.035Z","comments":true,"path":"archives/index.html","permalink":"https://wangtianyang.com/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-01-12T09:44:19.000Z","updated":"2023-01-05T08:03:47.035Z","comments":true,"path":"categories/index.html","permalink":"https://wangtianyang.com/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"2023-01-06T05:23:59.418Z","updated":"2023-01-06T05:23:59.410Z","comments":true,"path":"links/index.html","permalink":"https://wangtianyang.com/links/index.html","excerpt":"","text":"留言添加友链 友链格式网站名称：王天阳的个人博客网站地址：http://wangtianyang.com/网站描述：学习｜记录｜心情网站Logo/头像：http://wangtianyang.com/images/avatar.jpeg"},{"title":"","date":"2023-01-06T03:22:23.761Z","updated":"2023-01-06T03:22:23.748Z","comments":true,"path":"links/linklist.json","permalink":"https://wangtianyang.com/links/linklist.json","excerpt":"","text":"[{\"nickname\":\"三水非冰博客\",\"avatar\":\"https://www.sanshuifeibing.com/usr/images/avatar2.jpg\",\"site\":\"https://www.sanshuifeibing.com\"},{\"nickname\":\"北宸\",\"avatar\":\"https://leafjame.github.io/images/beichen.png\",\"site\":\"https://leafjame.github.io\"},{\"nickname\":\"千灵夙赋\",\"avatar\":\"https://qianling.pw/images/avatar.png\",\"site\":\"https://qianling.pw/\"}]"},{"title":"一些诗句摘抄","date":"2022-01-13T11:35:09.000Z","updated":"2023-01-05T08:03:47.083Z","comments":true,"path":"poems/index.html","permalink":"https://wangtianyang.com/poems/index.html","excerpt":"","text":"诗在生活里，就像火在木头里"},{"title":"tags","date":"2023-01-05T09:35:59.000Z","updated":"2023-01-05T09:35:59.663Z","comments":true,"path":"tags/index-1.html","permalink":"https://wangtianyang.com/tags/index-1.html","excerpt":"","text":""},{"title":"tags","date":"2023-01-05T09:36:38.000Z","updated":"2023-01-05T09:36:38.656Z","comments":true,"path":"tags/index-2.html","permalink":"https://wangtianyang.com/tags/index-2.html","excerpt":"","text":""},{"title":"标签","date":"2022-01-12T09:43:20.000Z","updated":"2023-01-05T09:38:17.599Z","comments":false,"path":"tags/index.html","permalink":"https://wangtianyang.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2023-01-07T03:48:37.338Z","updated":"2023-01-07T03:48:37.338Z","comments":true,"path":"love/css/default.css","permalink":"https://wangtianyang.com/love/css/default.css","excerpt":"","text":"body{ margin:0; padding:0; background:#ffe; font-size:12px; overflow:auto } #mainDiv{ width:100%; height:100% } #loveHeart{ float:left; width:670px; height:625px } #garden{ width:100%; height:100% } #elapseClock{ text-align:right; font-size:18px; margin-top:10px; margin-bottom:10px } #words{ font-family:\"sans-serif\"; width:500px; font-size:24px; color:#666 } #messages{ display:none } #elapseClock .digit{ font-family:\"digit\"; font-size:36px } #loveu{ padding:5px; font-size:22px; margin-top:80px; margin-right:120px; text-align:right; display:none } #loveu .signature{ margin-top:10px; font-size:20px; font-style:italic } #clickSound{ display:none } #code{ float:left; width:440px; height:400px; color:#333; font-family:\"Consolas\",\"Monaco\",\"Bitstream Vera Sans Mono\",\"Courier New\",\"sans-serif\"; font-size:12px } #code .string{ color:#2a36ff } #code .keyword{ color:#7f0055; font-weight:bold } #code .placeholder{ margin-left:15px } #code .space{ margin-left:7px } #code .comments{ color:#3f7f5f } #copyright{ margin-top:10px; text-align:center; width:100%; color:#666 } #errorMsg{ width:100%; text-align:center; font-size:24px; position:absolute; top:100px; left:0 } #copyright a{ color:#666 }"},{"title":"","date":"2023-01-07T03:35:45.334Z","updated":"2023-01-06T14:39:02.688Z","comments":true,"path":"love/js/functions.js","permalink":"https://wangtianyang.com/love/js/functions.js","excerpt":"","text":"var $window=$(window),gardenCtx,gardenCanvas,$garden,garden;var clientWidth=$(window).width();var clientHeight=$(window).height();$(function(){$loveHeart=$(\"#loveHeart\");var a=$loveHeart.width()/2;var b=$loveHeart.height()/2-55;$garden=$(\"#garden\");gardenCanvas=$garden[0];gardenCanvas.width=$(\"#loveHeart\").width();gardenCanvas.height=$(\"#loveHeart\").height();gardenCtx=gardenCanvas.getContext(\"2d\");gardenCtx.globalCompositeOperation=\"lighter\";garden=new Garden(gardenCtx,gardenCanvas);$(\"#content\").css(\"width\",$loveHeart.width()+$(\"#code\").width());$(\"#content\").css(\"height\",Math.max($loveHeart.height(),$(\"#code\").height()));$(\"#content\").css(\"margin-top\",Math.max(($window.height()-$(\"#content\").height())/2,10));$(\"#content\").css(\"margin-left\",Math.max(($window.width()-$(\"#content\").width())/2,10));setInterval(function(){garden.render()},Garden.options.growSpeed)});$(window).resize(function(){var b=$(window).width();var a=$(window).height();if(b!=clientWidth&&a!=clientHeight){location.replace(location)}});function getHeartPoint(c){var b=c/Math.PI;var a=19.5*(16*Math.pow(Math.sin(b),3));var d=-20*(13*Math.cos(b)-5*Math.cos(2*b)-2*Math.cos(3*b)-Math.cos(4*b));return new Array(offsetX+a,offsetY+d)}function startHeartAnimation(){var c=50;var d=10;var b=new Array();var a=setInterval(function(){var h=getHeartPoint(d);var e=true;for(var f=0;f=c.length){clearInterval(e)}},75)});return this}})(jQuery);function timeElapse(c){var e=Date();var f=(Date.parse(e)-Date.parse(c))/1000;var g=Math.floor(f/(3600*24));f=f%(3600*24);var b=Math.floor(f/3600);if(b"},{"title":"","date":"2023-01-07T03:35:45.335Z","updated":"2023-01-06T14:39:02.688Z","comments":true,"path":"love/js/garden.js","permalink":"https://wangtianyang.com/love/js/garden.js","excerpt":"","text":"function Vector(a,b){this.x=a;this.y=b}Vector.prototype={rotate:function(b){var a=this.x;var c=this.y;this.x=Math.cos(b)*a-Math.sin(b)*c;this.y=Math.sin(b)*a+Math.cos(b)*c;return this},mult:function(a){this.x*=a;this.y*=a;return this},clone:function(){return new Vector(this.x,this.y)},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y)},subtract:function(a){this.x-=a.x;this.y-=a.y;return this},set:function(a,b){this.x=a;this.y=b;return this}};function Petal(a,f,b,e,c,d){this.stretchA=a;this.stretchB=f;this.startAngle=b;this.angle=e;this.bloom=d;this.growFactor=c;this.r=1;this.isfinished=false}Petal.prototype={draw:function(){var a=this.bloom.garden.ctx;var e,d,c,b;e=new Vector(0,this.r).rotate(Garden.degrad(this.startAngle));d=e.clone().rotate(Garden.degrad(this.angle));c=e.clone().mult(this.stretchA);b=d.clone().mult(this.stretchB);a.strokeStyle=this.bloom.c;a.beginPath();a.moveTo(e.x,e.y);a.bezierCurveTo(c.x,c.y,b.x,b.y,d.x,d.y);a.stroke()},render:function(){if(this.r"},{"title":"","date":"2023-01-07T03:35:45.339Z","updated":"2023-01-06T14:39:02.689Z","comments":true,"path":"love/js/jquery.js","permalink":"https://wangtianyang.com/love/js/jquery.js","excerpt":"","text":"/*! * jQuery JavaScript Library v1.4.2 * http://jquery.com/ * * Copyright 2010, John Resig * Dual licensed under the MIT or GPL Version 2 licenses. * http://jquery.org/license * * Includes Sizzle.js * http://sizzlejs.com/ * Copyright 2010, The Dojo Foundation * Released under the MIT, BSD, and GPL Licenses. * * Date: Sat Feb 13 22:33:48 2010 -0500 */ (function(A,w){function ma(){if(!c.isReady){try{s.documentElement.doScroll(\"left\")}catch(a){setTimeout(ma,1);return}c.ready()}}function Qa(a,b){b.src?c.ajax({url:b.src,async:false,dataType:\"script\"}):c.globalEval(b.text||b.textContent||b.innerHTML||\"\");b.parentNode&&b.parentNode.removeChild(b)}function X(a,b,d,f,e,j){var i=a.length;if(typeof b===\"object\"){for(var o in b)X(a,o,b[o],f,e,d);return a}if(d!==w){f=!j&&f&&c.isFunction(d);for(o=0;o"}],"posts":[{"title":"Hexo-NeXT 自定义静态页面部署问题","slug":"Hexo-NeXT-css-js文件部署问题","date":"2023-01-07T04:39:39.000Z","updated":"2023-01-07T16:06:47.036Z","comments":true,"path":"2023/01/07/Hexo-NeXT-css-js文件部署问题/","link":"","permalink":"https://wangtianyang.com/2023/01/07/Hexo-NeXT-css-js%E6%96%87%E4%BB%B6%E9%83%A8%E7%BD%B2%E9%97%AE%E9%A2%98/","excerpt":"问题定位NexT 主题下部署自定义静态页面时（比如本站 love page），写好的 html 达不到想要的效果。 预期效果： 经过排查可以分为下面两个子问题： 自定义 html 不能作为一个独立的静态页面展示，而是作为NexT框架下的一个组件，如普通博文一般； CSS 和 JS 文件的渲染没有起效。","text":"问题定位NexT 主题下部署自定义静态页面时（比如本站 love page），写好的 html 达不到想要的效果。 预期效果： 经过排查可以分为下面两个子问题： 自定义 html 不能作为一个独立的静态页面展示，而是作为NexT框架下的一个组件，如普通博文一般； CSS 和 JS 文件的渲染没有起效。 原因分析 执行 hexo generate 时，NexT 会渲染 source 文件夹下的所有 html 文件，所以会将我们写好的静态页面也一同渲染到框架中。 执行 hexo generate 时，NexT 会在 CSS 和 JS 文件开头加一行1&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt; 正是这行代码导致了 CSS 和 JS 文件不可用。 解决方案 在站点配置文件（即根目录下的 _config.yml）中，skip_render 字段后面添加不需要渲染的文件名，比如：1skip_render: love/* # 不渲染 blog/source/love 路径下所有文件 或者在不需要渲染的文件开头添加12layout: false--- 将 CSS 和 JS 文件放在主题的 source 目录下（blog/themes/next/source），而非直接网站的 source 目录下（blog/source），并将 html 中的相关路径改为 ../","categories":[{"name":"Issues","slug":"Issues","permalink":"https://wangtianyang.com/categories/Issues/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://wangtianyang.com/tags/Hexo/"}]},{"title":"【读书笔记】《Java核心技术 卷I》","slug":"【读书笔记】《JAVA核心技术卷I》","date":"2022-12-22T01:57:27.000Z","updated":"2023-01-12T06:50:08.912Z","comments":true,"path":"2022/12/22/【读书笔记】《JAVA核心技术卷I》/","link":"","permalink":"https://wangtianyang.com/2022/12/22/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8AJAVA%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7I%E3%80%8B/","excerpt":"Java 在线 API 文档 Java的基本程序设计结构数据类型char 类型 p32 char 类型原本用于表示单个字符，不过现在不一样了。如今，有些 Unicode 字符可以用一个 char 值描述，而另外一些 Unicode 字符则需要两个 char 值。","text":"Java 在线 API 文档 Java的基本程序设计结构数据类型char 类型 p32 char 类型原本用于表示单个字符，不过现在不一样了。如今，有些 Unicode 字符可以用一个 char 值描述，而另外一些 Unicode 字符则需要两个 char 值。 变量与常量枚举类型 p37 12enum Size &#123;SMALL, MEDIUM, LARGE, EXTRA_LARGE&#125;;Size sz = Size.MEDIUM; 运算符位运算符 p43 位运算符包括： 1234567&amp; // 与| // 或^ // 异或~ // 非&gt;&gt; // 左移并用符号位填充高位&gt;&gt;&gt; // 左移并用 0 填充高位&lt;&lt; // 右移， 并不存在 &lt;&lt;&lt; 运算符 例： 1234int fourthBitFromRight = (n &amp; 0b1000) / 0b1000; // 当二进制表示的 n 从右往左数第 4 位为 1 时，fourthBitFromRight 为 1，否则为 0。// 上句代码等同于：int fourthBitFromRight = (n &amp; (1 &lt;&lt; 3)) &gt;&gt; 3; 注：应用在 bool 值上时，&amp; 和 | 运算符也会得到一个 bool 值。这些运算符与 &amp;&amp; 和 || 运算符很类似，不过 &amp; 和 | 运算符不采用“短路”的方式来求值，也就是说，得到计算结果之前两个操作数都需要计算。 括号与运算符优先级 p44 因为 += 是右结合运算符（详细运算符优先级见本书 p44），所以表达式 1a += b += c 等价于 1a += (b += c) 也就是将 b += c 的结果（加上 c 之后的 b）加到 a 上。 字符串 p44 Java 没有内置的字符串类型，而是在标准 Java 类库中提供了一个预定类 String。String 类的常用方法见 p49～p51。 子串 p45 12String a = &quot;Hello&quot;;String b = a.substring(0, 3); // b is &quot;Hel&quot; 拼接 p45 Java 允许 + 号拼接两个字符串。此外，在 Java 11 中，还提供了一个 repeat 方法： 1String repeated = &quot;Java&quot;.repeat(3); // repeated is &quot;JavaJavaJava&quot; 不可变字符串 p46 Java 中的 String 类对象是不可变的，也就是说，不能修改字符串中的单个字符。不过可以修改字符串变量，让它指向另外一个字符串。 从中可以看出，与 C++ 不同的是，Java 中的字符串并不是字符数组 char[]，而是 char* 指针。 检测字符串是否相等 p47 一定不要使用 == 运算符来检测两个字符串是否相等！== 运算符比较的只是两个字符串的地址。 C++ NOTE：C++ 中重载了 string 类的 == 运算符，而 Java 没有。事实上，Java设计者只重载了字符串的 + 运算符，但没有重载其他任何运算符，且不允许 Java 程序员自己重载运算符。 检测两个字符串是否相等可以用 equals 方法： 1s.equals(t) 其中 s 和 t 可以是字符串变量，也可以是字符串字面量。如果要比较两个字符串而不区分大小写，可以用 equalsIgnoreCase 方法： 1s.equalsIgnoreCase(t) 空串与 Null 串 p48 空串与 Null 串并不相同： 空串是指长度为 0 的字符串，仍是一个 Java 对象； Null 串表示目前没有任何对象与该变量关联。 码点与代码单元 p48 从 上一小章节 char 类型 可以看到，char 数据类型是一个采用 UTF-16 编码表示 Unicode 码点的代码单元。最常用的 Unicode 字符使用一个代码单元就可以表示，而辅助字符则需要一对代码单元来表示。 str.length() 方法只会返回字符串 str 的代码单元数量，而想要获取字符串的实际长度，即码点的数量，需要使用 str.codePointCount(0, str.length())。 同样的，str.charAt(i) 只会返回位置 i 处的代码单元，而想要得到第 i 个码点，应该使用 str.codePointAt(i)。 构建字符串 p54 StringBuilder 类可以避免拼接字符串时的时间与空间浪费： 123456789String ch = &quot;abc&quot;;String str = &quot;def&quot;;StringBuilder builder = new StringBuilder();builder.append(ch);builder.append(str);// 构建完成后调用 toString 方法，将可以得到一个 String 对象String completedString = builder.toString(); 其他 StringBuilder 的常用方法见 p54。 输入与输出读取输入 p55 输出： 1System.out.println() 输入： 12345Scanner in = new Scanner(System.in)lString name = in.nexLline(); // 读取一行，以换行作分隔符String firstName = in.next(); // 读取一个单词，以空白符作分隔符int age = in.nextInt(); // 读取一个整数double height = in.nextDouble(); // 读取一个浮点数 如果想要不可见的输入，比如密码，可以使用 Console 类： 123Console cons = System.console();String username = cons.readLine(&quot;User name: &quot;);char[] passwd = cons.readPassword(&quot;Password: &quot;); // 为了安全起见，返回的密码应该被存放在一个字符数组中，而不是字符串中，这样在处理完密码以后马上用一个填充值来覆盖数组元素 Console 类没有读取单个单词或者数值的方法。 其他输入输出方法见 p56-p57。 格式化输出 p57 12345double x = 10000.0 / 3.0;System.out.print(x); // 3333.3333333333335System.out.printf(&quot;%8.2f&quot;, x); // 输出8 个字符，精度为小数点后两位：3333.33（多余的字符位用前导空格填充）System.out.printf(&quot;%,.2f&quot;, x); // 增加分组分隔符，精度为小数点后两位：3,333.33 printf 可以使用多个标志，可用于 printf 的标志符有： 标志 目的 示例 + 打印符号位 +3333.33 空格 在整数之前添加空格 \\ 3333.33\\ 0 数字前面补0 003333.33 - 左对齐 \\ 3333.33 \\ ( 将负数括在括号内 (3333.33) , 添加分组分隔符 3,333.33 #（对于 f 格式） 包含小数点 3,333. #（对于 x 或 o 格式） 添加前缀 0x 或 0 0xcafe $ 指定要格式化的参数索引 - &lt; 格式化前面说明的数值 - printf 可以接收多个参数： 1System.out.prinf(&quot;Hello, %s. Next year, you&#x27;ll be %d.&quot;, name, age); 每一个以 % 字符开始的格式说明符都用相应的参数替换，可用于 printf 的转换符如下表： 转换符 类型 示例 d 十进制整数 159 x 十六进制整数 9f o 八进制整数 237 f 定点浮点数 15.9 e 指数浮点数 1.59e+01 g 通用浮点数（e 和 f 中较短的一个） - a 十六进制浮点数 0x1.fccdp3 s 字符串 Hello c 字符 H b 布尔 true h 散列码 42628b2 % 百分号 % n 与平台有关的行分隔符 - 可以使用静态的 String.format 方法创建一个格式化的字符串，而不打印输出： 1String str = String.format(&quot;Hello, %s. Next year, you&#x27;ll be %d.&quot;, name, age); 日期与时间的格式化选项见 p59。 文件输入与输出 p61 读取文件：1Scaner in = new Scanner(Path.of(&quot;myfiled.txt&quot;), StandardCharsets.UTF_8); NOTE：如果文件名中包含反斜杠符号，就要在每一个反斜杠之前再加一个反斜杠转义：“c:\\\\mydirectory\\\\myfile.txt” 写入文件： 1PrintWriter out = new PrintWriter(&quot;myfile.txt&quot;, StandardCharsets.UTF_8); 如果文件不存在，创建该文件。可以像输出到 System.out 一样使用 print、println 以及 printf。 控制流程块作用域 p63 块（block）是指由若干条 Java 语句组成的语句，并用一对大括号括起来（也就是说，大括号可以单独成对使用，不必搭配语句）。块确定了变量的作用域。一个块可以嵌套在另一个块中，但不能在嵌套的两个块中声明同名的变量。 多重选择：switch 语句 p72 12345678910111213switch (choice)&#123; case 1: . . . break; case 2: . . . break; . . . default: . . . break;&#125; case 标签可以是： 类型为 char、byte、short 或 int 的常量表达式； 枚举常量； 从 Java 7 开始，case 标签还可以是字符串字面量。 在 switch 语句中使用枚举常量时，不必在每个标签中指明枚举名，可以由 switch 的表达式值推导出，例如： 123456789enum Size &#123;SMALL, MEDIUM, LARGE, EXTRA_LARGE&#125;;Size sz = Size.MEDIUM;switch (sz)&#123; case SMALL: // 不用写成 Size.SMALL . . . . . .&#125; 终端控制流程的语句 p74 Java 中没有 goto，但是新增了一种带标签的 break 语句来代替 goto，例： 12345678910read_data:while (. . .)&#123; for (. . .) &#123; . . . if (. . .) break read_data; &#125;&#125; NOTE：事实上，可以将标签应用到任何语句，甚至可以将其应用到 if 语句或者块语句上，但不建议这么使用。 大数 p76 java.math 包中有两个大数类可以处理包含任意长数字序列的数值： BigInteger 类实现任意精度的整数运算； BigDecimall 类实现任意精度的浮点数运算。 可以使用静态的 valueOf 方法将普通的数值转化为大数： 1BigInteger a = BigInteger.valueOf(100); 不能使用 + 或 * 等算术运算符来处理大数，而需要使用大数类中的 add 和 multipy 方法： 12BigInteger c = a.add(b); // c = a + bBigInteger d = c.multiply(b.add(BigInteger.valueOf(2))); // d = c * (b + 2) 更多大数类的方法见 p78。 数组声明数组 p79 声明数组： 1int[] a; 声明并初始化一个可以存储 100 个整数的数组： 1int[] a = new int[100]; 一旦创建了数组，就不能改变它的长度！ 声明并同时提供初始值： 1int[] a = &#123;2, 3, 5, 7, 11, 13&#125;; 最后一个值后面允许有逗号！这样方便随时添加。 声明匿名数组： 1new int[] &#123;17, 19, 21, 22, 30&#125; 可以用它来初始化一个数组。 for each 循环 p81 12for (int element : a) System.out.println(element); 数组拷贝 p82 浅拷贝（两个变量引用同一个数组）：1int[] b = a; 深拷贝： 1int[] b = Arrays.copyOf(a, n); 第二个参数是新数组的长度，如果 大于原数组长度，那么： 如果数组元素是数值型，用 0 填充； 如果数组元素是布尔型，用 false 填充； 小于原数组长度，只拷贝前 n 个值。 命令行参数 p83 如果在命令行中输入： 1java MyProgress -g cruel world 那么对于 String[] args: 123args[0]: &quot;-g&quot;args[1]: &quot;cruel&quot;args[2]: &quot;world&quot; 数组排序 p83 1Arrays.sort(a); 该方法使用的是快排。 多维数组 p86 1double[][] a; 对象与类用户自定义类 文件名必须与 public 类的名字相匹配，在一个文件中，只能有一个公共类。 构造器总是结合 new 运算符来调用。不能对一个已经存在的对象调用构造器来达到重新设置实例字段的目的。 用 var 声明局部变量 p109 从 Java 10 开始，可以用 var 关键字来声明局部变量，而无须指定类型。var 关键字只能用于方法中的局部变量！ 使用 null 引用 p109 如果对 null 值应用一个方法，会产生一个 NullPointerException 异常。为了防止这个错误，我们应该避免对象中的字段为 null。对此有两种解决方法： “宽容型”方法是把 null 参数转化为一个适当的非 null 值，比如12345public Employee(String n, double s, int year, int month, int day)&#123; if (n == null) name = &quot;unknown&quot;; else name = n; . . .&#125; 或者用 java 9 中提供的新方法：12345public Employee(String n, double s, int year, int month, int day)&#123; name = Objects.requireNonNullElse(n, &quot;unknown&quot;); . . .&#125; “严格型”方法则是干脆拒绝 null 参数：123456public Employee(String n, double s, int year, int month, int day)&#123; Objects.requireNonNull(n, &quot;The name cannot be null!&quot;); name = n; . . .&#125; 隐式参数与显式参数 p110 每个方法都有两个参数： 第一个参数是隐式（implict）参数，是出现在方法前该类型的对象，也即调用该方法的对象。我们可以用关键字 this 指示隐式参数：12345public void raiseSalary(double byPercent)&#123; double raise = this.salary * byPercent / 100; this.salary += raise;&#125; 第二个参数是显式（explicit）参数，位于方法名后面括号中。 基于类的访问权限 p113 一个方法可以访问所属累的所有对象的私有数据。比如 Employee 类的方法可以访问任何 Employee 类型对象的私有字段。 final 实例字段 p114 可以将实例字段定义为 final，这样的字段必须在构造对象时初始化。 静态字段与静态方法静态字段 p115 如果将一个字段定义为 static，那么每个类只有一个该字段，也即所有该类的对象共享同一个静态字段，而对于非静态的实例字段，每个对象都有自己的一个副本。例： 12345678910111213141516171819202122232425public class EmployeeTest &#123; public static void main(String[] args) &#123; Employee employee1 = new Employee(); Employee employee2 = new Employee(); employee1.getId(); // 1 employee2.getId(); // 2 &#125;&#125;public class Employee &#123; private int id; private static int nextId = 1; public Employee() &#123; this.id = nextId; ++nextId; &#125; public void getId() &#123; System.out.println(this.id); &#125;&#125; 静态字段 nextId 属于类，而不属于任何单独的对象。 静态常量 p116 由于每个类对象都可以修改公共字段，所以最好不要有公共字段，但是公共常量就不会有问题： 1public static final . . . 静态方法 p116 静态方法是不在对象上执行的方法。比如：Math.pow(x, a)，它并不使用任何 Math 对象。换句话说，静态方法没有隐式参数。 静态方法不能访问非静态字段，因为它不能在对象上执行，但是可以访问静态字段。 方法参数 p121 按值调用（call by value）表示方法接收的是调用者提供的值； 按引用调用（call by reference）表示方法接收的是调用者提供的变量地址。 Java 中只有按值调用！！！也就是说，方法得到的是所有参数值的一个副本，它不能修改传递给它的任何参数变量的内容。比如以下方法是不起作用的： 1234public static void tripleValue(double x)&#123; x = 3 * x;&#125; 但是！！！Java 有两种类型的方法参数： 基本数据类型 对象引用 如果将对象作为参数，那么就可以修改它的字段值！因为它是引用，指向同一个对象。比如： 1234pubilc static void tripleSalary(Employee x)&#123; x.raiseSalary(200);&#125; 比较搞的是，对象引用仍然是按值传递的，比如： 12345678910pubilc static void swap(Employee x, Employee y)&#123; Employee tmp = x; x = y; y = tmp;&#125;var a = new Employee(. . .);var b = new Employee(. . .);swap(a, b)l 如果是按引用调用，那么上述方法应该是能交换 a 和 b 的，可是事实上，它只交换了 a 和 b 的副本 x 和 y，而 a 和 b 仍是原本的对象。 对象构造无参数的构造器 p127 仅当类没有任何其他构造器的时候，编译器才会提供一个默认的无参数构造器。 参数名 p129 对于构造器参数，有两种命名风格： 有些程序员喜欢在每个参数前面加上一个前缀“a”12345public Employee(String aName, double aSalary)&#123; name = aName; salary = aSalary;&#125; 利用 Java 的特点——参数变量会遮蔽同名的实例字段，所以我们也可以这么写：12345public Employee(String name, double salary)&#123; this.name = name; this.salary = salary;&#125; C++ NOTE：在 C++ 中，经常用下划线或某个固定的字母（一般选用 m 或 x）作为实例字段的前缀，Java程序员一般不这么做。 调用另一个构造器 p129 关键词 this 除了指示一个方法的隐式参数以外，还有另一个作用：如果构造器的第一个语句形如 this(. . .)，那么这个构造器将调用同一个类的另一个构造器。例： 12345public Employee(double s)&#123; this(&quot;Employee #&quot; + nextId, s); // 调用 Employee(String, double) nextId++;&#125; 初始化块 p130 Java 除了能在构造器中设置值和在声明中赋值以外，还有第三种初始化数据字段的方法，称为初始化块（initialization block）。例： 1234567891011class Employee&#123; private static int nextId; private int id; &#123; id = nextId; nextId++; &#125;&#125; 初始化块的执行在构造器主体之前。可以用关键字 static 来修饰一个静态的初始化块： 12345static&#123; var generator = new Random(); nextId = generator.nextInt(10000);&#125; 静态字段只会在类第一次加载的时候初始化一次。 对象析构与 finalize 方法 p134 由于 Java 有自动的垃圾回收机制，不需要人工回收内存，所以 Java 不支持析构器，也不要使用 finalize 方法来完成清理！ 包包名 p134 使用包的主要原因是确保类名的唯一性。 为了确保包名的绝对唯一性，要用一个因特网域名以逆序的形式作为包名，然后对于不同的工程使用不同的子包。 从编译器的角度来看，嵌套的包之间没有任何关系，例如 java.util 和 java.util.jar 包毫无关系，每一个包都是独立的类集合。 类的导入 p135 一个类可以使用所属包中的所有类，以及其他包中的公共类（public class）。我们可以采用两种方式访问另一个包中的公共类： 使用完全限定名（fully qualified name），即包名后面跟着类名。例如：1java.time.LocalDate today = java.time.LocalDate.now(); 使用 import：123import java.time.*;LocalDate today = LocalDate.now(); 还可以导入一个包中的特定类：1import java.time.LocalDate; NOTE：只能使用星号 * 导入一个包，而不能使用 import java.* 或 import java.*.* 导入以 java 为前缀的所有包。 静态导入 p136 在 import 后添加 static 关键字可以导入静态方法和静态字段，这样在使用静态方法和静态字段时不必加类名前缀。例： 12345678910import static java.lang.System.*;public class HelloWorld&#123; public static void main(String args[]) &#123; out.println(&quot;test&quot;); // i.e., System.out exit(0); // i.e., System.exit &#125;&#125; 在包中增加类 p137 要想将类放入包中，就必须将包的名字放在源文件的开头，即放在定义这个包中各个类的代码之前。例： 123456package com.horstmann.corejava;public class Employee&#123; . . .&#125; 如果没有在源文件中放置 package 语句，那么这个源文件中的类就属于无名包（unnamed package）。 将源文件放到与完整包名匹配的子目录。例如，com.horstmann.corejava 包中的所有源文件应该放置在子目录 com/horstmann/corejava中。 编译： 1javac com/horstmann/corejava/Employee.java 运行： 1java com.horstmann.corejava.Employee 包访问 p139 public 访问修饰符：可以由任意类使用； private 访问修饰符：只能由定义它们的类使用； 不指定访问修饰符（默认）：可以被同一个包中的所有方法使用。 文档注释类注释 p149 类注释必须放在 import 语句之后，类定义之前。例： 123456789/** * Here is * some * comments. */public class Card&#123; . . .&#125; 方法注释 p149 每一个方法注释必须放在所描述的方法之前，并可以使用下面的标记： @param variable description 这个标记将给当前方法的参数部分添加一个条目，这个描述可以占据多行，并且可以使用 HTML 标记。一个方法的所有 @param 标记必须放在一起。 @return description 这个标记将给当前方法添加返回部分。这个描述可以跨多行，并且可以使用 HTML 标记。 @throws class description 这个标记将添加一个注释，表示这个方法有可能抛出异常。 例： 1234567891011/** * Raises the salary of an employee. * @param byPercent the percentage by which to raise the salary (e.g., 10 means 10%) * @return the amount of the raise */public double raiseSalary(double byPercent)&#123; double raise = salary * byPercent / 100; salary += raise; return raise;&#125; 字段注释 p150 只需要对公共字段（通常指静态常量）建立文档。例如： 1234/** * The &quot;Hearts&quot; card suit */public static final int HEARTS = 1; 通用注释 p150 @author name @version text 类设计技巧 p152 一定保证数据私有。 一定要对数据进行初始化。 不要在类中使用过多的基本类型，可以用一个新类来替换。 不是所有的字段都需要单独的字段访问器和字段更改器。 分解有过多职责的类。 类名和方法名要能够体现它们的职责。 优先使用不可变的类。 继承类、超类和子类EmployeeTest.java 1234567891011121314151617public class EmployeeTest &#123; public static void main(String[] args) &#123; Manager boss = new Manager(&quot;Carl Cracker&quot;, 80000, 1987, 12, 15); boss.setBonus(5000); Employee[] staff = new Employee[3]; staff[0] = boss; staff[1] = new Employee(&quot;Harry Hacker&quot;, 50000, 1989, 10, 1); staff[2] = new Employee(&quot;Tommy Tester&quot;, 40000, 1990, 3, 15); for (Employee e : staff) &#123; System.out.println(&quot;name=&quot; + e.getName() + &quot;,salary=&quot; + e.getSalary()); &#125; &#125;&#125; Employee.java 1234567891011121314151617181920212223242526272829303132333435import java.time.*;public class Employee &#123; private String name; private double salary; private LocalDate hireDay; public Employee(String name, double salary, int year, int month, int day) &#123; this.name = name; this.salary = salary; this.hireDay = LocalDate.of(year, month, day); &#125; public String getName() &#123; return name; &#125; public double getSalary() &#123; return salary; &#125; public LocalDate getHireDay() &#123; return hireDay; &#125; public void raiseSalary(double byPercent) &#123; double raise = salary * byPercent / 100; salary += raise; &#125;&#125; Manager.java 123456789101112131415161718192021public class Manager extends Employee&#123; private double bonus; public Manager(String name, double salary, int year, int month, int day) &#123; super(name, salary, year, month, day); bonus = 0; &#125; @Override public double getSalary() &#123; return bonus + super.getSalary(); &#125; public void setBonus(double bonus) &#123; this.bonus = bonus; &#125;&#125; 定义子类 p156 1234public class Manager extends Employee&#123; added methods and fields&#125; C++ NOTE：在 Java 中，所有的继承都是公共继承，而没有 C++ 中的私有继承和保护继承。 将 Employee 类称为超类（superclass）、基类（baseclass）或父类（parent class）；Manager 类称为子类（subclass）、派生类（derived class）或孩子类（child class）。 覆盖方法 p157 子类不能直接访问超类中的私有字段！因此需要使用超类中提供的公共方法来访问字段，用关键字 super 来达成此目的。例：super.getSalary()，可以在子类中调用父类的 getSalary() 方法。 子类构造器 p158 12345public Manager(String name, double salary, int year, int month, int day)&#123; super(name, salary, year, month, day); bonus = 0;&#125; 如果子类的构造器没有显式地调用超类的构造器，那么将自动调用超类的无参数构造器。如果超类没有无参数构造器，并且在子类的构造器中又没有显式地调用超类的其他构造器，Java 编译器就会报告一个错误。 一个对象变量可以指示多种实际类型的现象称为多态（polymorphism）。在运行时能自动选择适当的方法，称为动态绑定（dynamic binding）。 C++ NOTE：在 C++ 中，如果希望实现动态绑定，需要将成员函数声明为 virtual。在 Java 中，动态绑定是默认的行为，如果不希望让一个方法是虚拟的，可以将它标记为 final。 继承层次 p162 Java 不支持多重继承，但是有接口。 多态 p162 有一个简单规则可以用来判断是否应该将数据设计为继承关系，那就是“is-a”规则，即子类的每个对象都是超类的对象，比如每个经理都是员工。“is-a”规则的另一种表述是替换原则（substitution principle），意思是程序中任何出现超类对象的地方都可以使用子类对象替换！ 1234boss.setBonus(5000); // OK!staff[0].setBonus(5000); // ERROR!Manager m = staff[0]; // ERROR! 编译器只将 staff[0] 看成是一个 Employee 对象！ 阻止继承：final 类和方法 p165 1234public final class Executive extends Manager&#123; . . .&#125; final 类中的所有方法自动地成为 final 方法，但是也可以手动声明正常类中的某个特定方法为 final，这样可以阻止子类覆盖。 123456789public class Employee&#123; . . . public final String getName() &#123; return name; &#125; . . .&#125; 如果将一个类声明为 final，只有其中的房啊自动成为 final，而不包括字段。 强制类型转换 p166 1234double x = 3.405;int nx = (int) x; // x is 3Manager boss = (Manager) staff[0]; 如果试图在继承链上进行向下的强制类型转换，并且“谎报”对象包含的内容，就会产生 ClassCastException 异常，比如： 1Manager boss = (Manager) staff[1]; // ERROR! 当然如果两个类型本身就风马牛不相及，类型转换也不会成功： 1String c = (String) staff[1]; // ERROR! 因此，在进行强制转换之前，应该先使用 instanceof 操作符查看能否转换成功。例： 12345if (staff[1] instanceof Manager)&#123; boss = (Manager) staff[1]; . . .&#125; 抽象类 p169 可以使用 abstract 关键词将方法声明为抽象方法，抽象方法不用提供具体实现。包含一个或多个抽象方法的类本身必须被声明为抽象类。例： 12345public abstract class Person&#123; . . . public abstract String getDescription();&#125; 即使不含抽象方法，也可以讲类声明为抽象类。抽象类不能实例化！ 受保护访问 p173 private：仅对本类可见 public：对外部完全可见 protected： 对本包和所有子类可见 若子类与基类不在同一包中，那么在子类中，子类实例可以访问其从基类继承而来的protected方法，而不能访问基类实例的protected方法 默认/不使用修饰符：对本包可见 Object：所有类的超类Object 类型的变量 p174 在 Java 中，只有基本类型（primitive type）不是对象，即，数值、字符和布尔类型的值不是对象。其他所有都是对象，都扩展自 Object 类。 所有的数组类型，不管是对象数组还是基本类型的数字都扩展了 Object 类。 123456Object obj;Employee[] staff = new Employee[10]&#x27;obj = staff; // OK!obj = new int[10]; // OK! C++ NOTE：在 C++ 中没有所有类的根类，不过，每个指针都可以转换为 void* 指针。 equals 方法 p175 Obejct 类中的 equals 方法用于检测一个对象是否等于另外一个对象。Object 类中实现的 equals 方法将确定两个对象引用是否相等：如果两个对象引用相等，这两个对象肯定就相等。不过也可以重写，比如： 123456789101112131415161718192021public class Employee&#123; . . . public boolen equals(Object otherObject) &#123; // 检查是不是一个 Object if (this == otherObject) return true; // 如果显参为空，返回 false if (otherObject == null) return false; // 如果类型不匹配，返回 flase if (getClass() != otherObject.getClass()) return false; Employee other = (Employee) otherObject; return name.equals(other.name) &amp;&amp; salary == other.salary &amp;&amp; hireDay.equals(other.hireDay); &#125;&#125; 为了防备 name 或 hireDay可能为 null 的情况，需要使用 Objects.equals 方法。如果两个参数都为 null，Objects.equals(a, b) 将返回 true；如果其中一个参数为 null，则返回 false；如果两个参数都不为 null，则调用 a.equals(b)。因此 Employee.equals 方法的最后一句语句要改写为： 123return Objects.equals(name, other.name) &amp;&amp; salary == other.salary &amp;&amp; Objects.equals(hireDay, other.hireDay); 在子类中定义 equals 方法时，首先调用超类的 equals。如果检测失败，对象就不可能相等；否则比较子类中的实例字段。 12345678910public class Manager extends Employee&#123; . . . public boolen equals(Object otherObject) &#123; if (!super.equals(otherObject)) return false; Manager other = (Manager) otherObject; return bonus == other.bonus; &#125;&#125; 相等测试与继承 p176 Java 语言规范要求 equals 方法具有以下特性： 自反性：对于任何非空引用 x，x.equals(x) 应该返回 true； 对称性：对于任何引用 x 和 y，当且仅当 x.equals(y) 返回 true 时，y.equals(x) 也返回 true； 传递性：对于任何引用 x、y 和 z，如果 x.equals(y) 返回 true 且 y.equals(z) 也返回 true时，x.equals(z) 应该返回 true； 一致性：如果 x 和 y 引用的对象没有发生变化，反复调用 x.equals(y) 应该返回同样的结果； 对于任意非空引用 x，x.equals(null) 应该返回 false。 但是当隐式参数和显式参数是超类与子类的关系时，equals 方法应该如何处理呢？许多程序员选择 instanceof 进行检测： 1if (!(otherObject instanceof Employee)) return false; 但是这显然违反了对称性规则。但是如果用 getClass 检测，又违反了替换原则。本书中给出了一个完美编写 equals 方法的建议： 显式参数命名为 otherObject，稍后需要将它强制转换为另一个名为 other 的变量。 检测 this 和 otherObject 是否相等：1if (this == otherObject) return true; 这条语句只是一个优化，因为检查身份要比逐个比较字段开销小。 检测 otherObject 是否为 null，如果为 null，返回 false：1if (otherObject == null) return false; 比较 this 和 otherObject 的类。如果 equals 的语义可以在子类中改变，就使用 getClass 检测：1if (getClass() != otherObject.getClass()) return false; 如果所有子类都有相同的相等性语义，就使用 instanceof 检测：1if (!(otherObject instanceof ClassName)) return false; 将 otherObject 强制转换为相应类类型的变量：1ClassName other = (ClassName) otherObject; 现在根据相等性概念的要求来比较字段，使用 == 比较基本类型字段，使用 Objects.equals 比较对象字段。如果所有字段都匹配，就返回 true；否则返回 false。123return field1 == other.field1 &amp;&amp; Objects.equals(field2, other.field2) &amp;&amp; . . .; 如果在子类中重新定义 equals，就要在其中包含一个 super.equals(other) 调用。 hashCode 方法 p179 散列码（hash code）是由对象导出的一个整型值，hashCode 方法应该返回一个整数（可以为负）。 如果两个对象相同，那他们的散列码也应该相同。因此，如果重写了 equals 方法，那么也应该重写 hashCode 方法。例如，下面是 Employee 类的 hashCode 方法： 12345678910public class Employee&#123; public int hashCode() &#123; return 7 * name.hashCode() + 11 * new Double(salary).hashCode() + 13 * hireDay.hashCode(); &#125; . . .&#125; 以上代码可以分两步优化： 使用 null 安全的方法 Objects.hashCode。如果其参数为 null，这个方法会返回 0，否则返回对参数调用 hashCode 的结果； 使用静态方法 Double.hashCode 来避免创建 Double 对象。 如下： 123456public int hashCode()&#123; return 7 * Objects.hashCode(name) + 11 * Double.hashCode(salary) + 13 * Objects.hashCode(hireDay);&#125; 上面的代码可以进一步优化：调用 Objects.hash 并提供所有这些参数，该方法会对各个参数调用 Objects.hashCode，并组合这些散列值。如下： 1234public int hashCode()&#123; return Objects.hash(name, salary, hireDay);&#125; equals 与 hashCode 的定义必须相容：如果 x.equals(y) 返回 true，那么 x.hashCode() 和 y.hashCode() 就必须返回相同的值。例如，如果定义 Employee.equals 比较的是员工的 ID，那么 hashCode 方法就需要散列 ID，而不是员工的姓名或存储地址。 toString 方法 p181 绝大多数（不是全部）的 toString 方法都遵循这样的格式：类的名字，随后是一对方括号括起来的字段值。比如，Employee 类中的 toString 方法的实现为： 1234567public String toString()&#123; return getClass.getName() + &quot;,salary=&quot; + salary + &quot;,hireDay=&quot; + hireDay + &quot;]&quot;;&#125; 子类应该调用 super.toString()，例如： 12345678910public class Manager extends Employee&#123; . . . public String toString() &#123; return super.toString() + &quot;[bonus=&quot; + bonus + &quot;]&quot;; &#125;&#125; toString 完备的理由： 只要对象与一个字符串通过操作符 + 链接，Java 编译器就会自动调用 toString 方法来获得这个对象的字符串描述； 如果 x 是一个任意对象，并调用 System.out.println(x);，println 方法会自动调用 x.toString()； toString 方法是一种非常有用的调试工具，可以搭配 Logger.global.info 方法来输入日志。 泛型数组列表 p186 在 C/C++ 中，必须在编译时就确定整个数组的大小，而 Java 允许运行时确定数组的大小： 12int n = . . .;var staff = new Employee[n]; 但这并没有完全解决运行时动态改变数组大小的问题，解决该问题的正确方式是使用 ArrayList 类。ArrayList 类类似于数组，但在添加或删除元素时，它能够自动调整数组容量，而不需要为此编写任何代码。 ArrayList 是一个有类型参数（type parameter）的泛型类（generic class）。为了指定列表保存的元素对象的类型，需要用一对见括号将类名括起来追加到 ArrayList 后面，例如，ArrayList&lt;Employee&gt;。 声明数组列表 p187 声明并构造数组列表： 12345// 三种方式ArrayList&lt;Employee&gt; staff = new ArrayList&lt;Employee&gt;(); // original formvar staff = new ArrayList&lt;Employee&gt;(); // in Java 10ArrayList&lt;Employee&gt; staff = new ArrayList&lt;&gt;(); // OK! 添加元素到数组列表： 1staff.add(new Employee(&quot;Harry Hacker&quot;, . . .)); 数组列表内部管理着一个对象引用数组，当这个内部的对象引用数组满了，数组列表就会自动创建一个更大的数组，并将所有的对象从较小的数组中拷贝到更大的数组中去。我们也可以为数组列表预先分配好可能的容量，这样就可以减少开销很大的重新分配空间。例： 123// 两种方式staff.ensureCapacity(100);ArrayList&lt;Employee&gt; staff = new ArrayList&lt;100&gt;; size 方法可以返回数组列表中包含的实际的元素个数。例： 1staff.size(); 一旦确定不会再新增元素，我们可以用 trimToSize 方法来回收数组列表中多余的未使用的空间。 访问数组列表元素 p189 访问元素1staff.get(i); \\\\ i 是索引 替换已经存在的元素1staff.set(i, harry); 注意！i 必须小于数组列表的实际元素个数，否则应该用 add。 插入元素1staff.add(i, vincent); 位置 i 及之后的所有元素都要向后移动一个位置。 删除元素1Employee e = staff.remove(i); 位置 i 之后的所有元素都要向前移动一个位置。 类型化与原始数组列表的兼容性 p191 假设有一个没有使用类型参数的遗留代码，如下所示： 12345public class EmployeeDB&#123; public void update(ArrayList list) &#123; . . . &#125; public ArrayList find(String query) &#123; . . . &#125;&#125; 可以将一个类型化的数组列表传递给 update 方法，而不需要进行任何强制类型转换，如下所示： 12ArrayList&lt;Employee&gt; staff = . . .;employeeDB.update(staff); 相反，将一个原始未类型化的 ArrayList 赋给一个类型化 ArrayList 会得到一个警告（不是报错！），如下所示： 1ArrayList&lt;Employee&gt; result = employeeDB.find(query); // yields warning 使用强制类型转换并不能避免出现警告，如下所示： 12ArrayList&lt;Employee&gt; result = (ArrayList&lt;Employee&gt;) employeeDB.find(query); // yields another warning 对于这个问题，我们做不了什么，只能在确保警告不太严重的情况下忽略它。可以用 @SuppressWarnings(&quot;unchecked&quot;) 注解来标记接受强制类型转换的变量，如下所示： 1@SuppressWarnings(&quot;unchecked&quot;) ArrayList&lt;Employee&gt; result = (ArrayList&lt;Employee&gt;) employeeDB.find(query); 对象包装器与自动装箱 p192 所有的基本类型都有一个与之对应的类，这些类称为包装器（wrapper）： Integer Long Float Double Short Byte Character Boolean 前 6 个类派生于公共的超类 Number。 包装器类是不可变的，即一旦构造了包装器，就不允许更改包装在其中的值。同时，包装器类还是 final 的，因此不能派生它们的子类。 数组列表尖括号中的类型参数不允许事基本类型，也就是说必须写成包装器类，例如： 12var list = new ArrayList&lt;int&gt;(); // ERROR!!!var list = new ArrayList&lt;Integer&gt;(); // OK! NOTE：由于每个值分别包装在对象中，所以 ArrayList&lt;Integer&gt; 的效率远远低于 int[] 数组。因此，只有当程序员操作的方便性比执行效率更重要的时候，才会考虑对较小的集合使用这种结构。 list.add(3); 会自动转换成 list.add(Integer.valueOf(3));，这种特性叫作自动装箱（auto-boxing）；相反地，int n = list.get(i); 也会自动转换为 int n = list.get(i).intValue();，这种特性叫作自动拆箱（auto-unboxing）。自动装箱和自动拆箱也适用于算术表达式。 == 运算符应用于包装器对象时，检测的是对象的内存位置，而非值！！！ 自动装箱补充说明： 由于包装器类引用可以为 null，所以自动装箱有可能会抛出一个 NullPointerException 异常，例如：12Integer n = null;System.out.println(2 * n); // throws NullPointerException 如果在一个算术表达式或条件表达式中混合使用 Integer 和 Double 类型，Integer 值就会拆箱，提升为 Double，再装箱为 Double，例如：1234Integer a = 1;Double b = 100.0;System.out.println(a+b); // 101.0System.out.println(true ? a : b); // 1.0 装箱和拆箱是编译器要做的工作，而不是虚拟机。 要想将字符串转换为整型，可以使用如下语句： 1int x = Integer.parseInt(s); // 静态方法，与 Integer 对象无关 参数数量可变的方法 p195 在显参中使用 ... 可以使方法接受任意数量的对象。例如： 123456789/** *计算若干个数值中的最大值（数值个数可变） */public static double max(double... values)&#123; double largest = Double.NEGATIVE_INFINITY; for (double v : values) largest = v &gt; largest ? v : largest; return largest;&#125; 枚举类 p196 1public enum SIze&#123;SMALL, MEDIUM, LARGE, EXTRA_LARGE&#125;; 上面是一个常见的声明并定义枚举的例子，实际上这个声明定义的类型是一个类，它刚好有 4 个实例，不可能构造新的对象，因此可以直接用 == 来比较两个枚举类型的值。 可以为枚举类增加构造器、方法和字段。枚举类的构造器总是且默认是私有的，因此可以省略 private 修饰符，但不能声明为 public 或 protected，会出现语法错误。 所有枚举类都是 Enum 类的子类，因此也继承了这个类的许多方法，比如： toString 方法。例如 Size.SMALL.toString() 将返回字符串 “SMALL”。 toString 的逆方法 valueOf，valueOf 方法是静态方法。例如 Size s = Enum.valueOf(Size.class, &quot;SMALL&quot;); 将 s 设置成 Size.SMALL。 每个枚举类型都有一个静态的 values 方法，它将返回一个包含全部枚举值的数组。例如 Size[] values = Size.values(); 返回包含元素 Size.SMALL、Size.MEDIUM、Size.LARGE 和 Size.EXTRA_LARGE 的数组。 ordinal 方法返回 enum 声明中枚举常量的位置，从 0 开始计数。例如 Size.MEDIUM.ordinal() 将返回 1。 反射 p198 能够分析类能力的程序称为反射（reflective），反射机制可以用来： 在运行时分析类的能力。 在运行时检查对象。 实现泛型数组操作代码。 利用 Method 对象。 Class 类 p199 在程序运行期间，Java 运行时系统始终为所有对象维护一个运行时类型标识，这个信息会跟踪每个对象所属的类。可以使用一个 Class 类来访问这些信息，Object 类中的 getClass() 方法将会返回一个 Class 类型的实例。例如： 123Employee e;. . .Class cl = e.getClass(); 就像 Employee 对象描述一个特定员工的属性一样，Class 对象会描述一个特定类的属性。例如，getName 方法会返回类的名字，如果类在一个包里，包的名字也作为类名的一部分。例如： 123var generate = new Random();Class cl = generate.getClass();String name = cl.getName(); // name is &quot;java.util.Random&quot; getName 的你方法是 forName，它是静态方法，并且返回类名对应的 Class 对象。例如： 12String name = &quot;java.util.Random&quot;;Class cl = Class.forName(name); 如果输入的不是类名或接口名，那么 forName 方法将抛出一个检查型异常（checked exception），因此使用这个方法时应该提供一个异常处理器（exception handler）。 也可以直接用 T.class 来获得 Class 类对象，例如： 123Class cl1 = Random.class; // if import java.util.*;Class cl2 = int.class;Class cl3 = Double[].class; 虚拟机为每个类型管理一个唯一的 Class 对象，因此可以利用 == 运算符实现两个类对象的比较。 声明异常入门 p201 如果一个方法包含一条可能抛出检查型异常的语句，则在方法名上增加一个 throws 子句。例如： 123456public static void doSomethingWithClass(String name) throws ReflectiveOperationException&#123; Class cl = Class.forName(name); // might throw exception . . .&#125; 资源 p202 类通常有一些关联的数据文件，例如： 图像和声音文件； 包含消息字符串和按钮标签的文本文件。 在 Java 中，这些关联的文件被称为资源（resource）。Class 类提供了查找资源文件的方法，步骤如下： 获得拥有资源的类的 Class 对象；1Class cl = ResourceTest.class; 使用 getResource 方法获得描述资源文件的 URL，例如：12URL url = cl.getResource(&quot;about.gif&quot;);var icon = new ImageIcon(url); 使用 getResourceAsStream 方法得到一个输入流来读取文件中的数据，例如：12InputStream stream = cl.getResourceAsStream(&quot;data/about.txt&quot;);var about = new String(stream.readAllBytes(), &quot;UTF-8&quot;); 利用反射分析类的能力 p203 在 java.lang.reflect 包中有三个类 Field、Method 和 Constructor 分别用于描述类的字段、方法和构造器。 这三个类都有一个 getName 方法，返回字段、方法和构造器的名称。 Field 类有一个 getType 方法，返回一个描述字段类型的 Class 对象。 Method 和 Constructor 类有报告参数类型的方法，Method 类还有一个报告返回类型的方法。 这三个类都有一个 getModifiers 方法，返回一个整数，用不同的 0/1 位描述所使用的修饰符，如 public 和 static。可以使用 java.lang.reflect 类中的 isPublic、isPrivate 或 isFinal 等静态方法判断方法或构造器 是 public、private 还是 final。另外还可以利用 Modifier.toString 方法将修饰符打印出来。 Class 类中的 getFields、getMethods 和 getConstructors 方法将分别返回这个类支持的公共字段、方法和构造器的数组，其中包括超类的公共成员。 Class 类中的 getDeclareFields、getDeclareMethods 和 getDeclareConstructors 方法将分别返回类中声明的全部字段、方法和构造器的数组，其中包括私有成员、包成员和受保护成员，但不包括超类的成员。 继承的设计技巧 p219 将公共操作和字段放在超类中。 不要使用受保护的字段。 除非两个类是“is-a”关系，否则不要使用继承。 除非所有继承的方法都有意义，否则不要使用继承。 在覆盖方法时，不要改变预期的行为。 使用多态，而不要使用类型信息。 不要滥用反射。 接口、lambda 表达式与内部类接口接口的概念 p222 接口（interface）用来描述类应该做什么，而不指定它们具体应该如何做。一个类可以实现（implement）一个或多个接口。例如： 1234public interface Comparable&#123; int compareTo(Object other);&#125; 这说明，任何实现 Comparable 接口的类都需要包含 compareTo 方法，这个方法有一个 Object 参数，并且返回一个整数。可以进一步将 Comparable 提升为泛型接口： 1234public interface Comparable&lt;T&gt;&#123; int compareTo(T other);&#125; 为了让类实现一个接口，通常需要完成两个步骤： 使用关键字 implements 将类声明为实现给定的接口。 对接口中的所有方法提供定义。 例如： 1234567class Employee implements Comparable&lt;Employee&gt;&#123; public int compareTo(Employee other) &#123; return Double.compare(salary, other.salary); &#125;&#125; 接口中的所有方法自动是 public，因此无需提供关键字。但是在实现接口时，必须把方法声明为 public。 接口的属性 p228 不能用 new 运算符实例化一个接口，但是可以声明接口的变量，接口变量必须引用实现了这个借口的类的对象。例如： 123x = new Comparable(. . .); // ERROR!Comparable x; // OKx = new Employee(. . .); // OK provided Employee implements Comparable 接口可以通过 extends 字段进行扩展，与类的继承一样。例如： 1public interface Powered extends Moveable &#123; . . . &#125; 接口中不能包含实例字段，但是可以包含常量。而且与接口中方法都自动被设置为 public 一样，接口中的字段也自动被设置为 public static final。例如： 1234public interface Powered extends Moveable &#123; double SPEED_LIMIT = 95; // a public static final constant&#125; 可以用 instanceof 检查一个对象是否实现了某个特定的接口。例如： 1if (anObject instanceof Comparable) &#123; . . . &#125; 可以实现多个接口，用逗号分开，例如： 1class Employee implements Cloneable, Comparable &#123; . . . &#125; 接口与抽象类 p229 为什么要用接口代替抽象类？ 因为 Java 不支持多重继承（multiple inheritance），多重继承会让语言变得非常复杂（如果 C++），或者效率会降低（如同 Eiffel）。而接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性。 C++ NOTE：C++ 具有多重继承特性，随之带来了一些复杂的特性，如虚基类、控制规则和横向指针类型转换，等等。 静态和私有方法 p230 从 Java 8 开始，允许在接口中增加静态方法，虽然这有违接口作为抽象规范的初衷。 默认方法 p230 可以用 default 修饰符来为接口方法提供一个默认实现，接口的具体实现不用实现默认方法。默认方法也可以调用其他方法，例如： 12345public interface Collection&#123; int size(); // an abstract method default boolean isEmpty() &#123; return size() == 0; &#125;&#125; 这样实现 Collection 的程序员就不用再操心实现 isEmpty 方法了。 默认方法的一个重要用法是接口演化（interface evolution），比如要为一个接口添加新方法的同时不影响到它的具体实现类，那么就可以用到默认方法。 解决默认方法冲突 p231 默认方法的两种冲突情形： 一个类同时继承了一个超类并实现了一个接口，其中超类提供了一个具体方法，且接口提供了一个同名同参数类型的默认方法。例如：1234567891011121314151617interface Person&#123; default String getName() &#123; return &quot;wty&quot;; &#125;;&#125;public class Named &#123; public String getName() &#123; return &quot;vincent&quot;; &#125;&#125;class Student extends Named implements Person &#123; . . . &#125; 遵从超类优先：如果超类提供了一个具体方法，同名且有相同参数类型的默认方法会被忽略。 一个类实现了两个接口，两个接口都提供了一个同名同参数类型的方法，且至少有一个是默认方法。例如：1234567891011121314 interface Person&#123; default String getName() &#123; return &quot;wty&quot;; &#125;;&#125; interface Named&#123; String getName();&#125;class Student implements Person, Named &#123; . . . &#125; Java 编译器并不会从中选择一个，而是报告一个错误并交给程序员来解决这个二义性问题。我们只需要在 Student 类中提供一个 getName 方法即可，类中的方法会同时覆盖两个接口中的方法，例如：1234567class Student implements Person, Named&#123; public String getName() &#123; return Person.super.getName(); &#125;&#125; 接口与回调 p233 定时器： 123var listener = new TimePrinter();Timer t = new TImer(1000, listener);t.start(); Timer 构造器的第一个参数是一个时间间隔（单位是毫秒），即经过多长时间通知一次；第二个参数是监听器对象。 对象克隆 236 在对象内重写 clone 方法，该方法用于深拷贝。例： 123456789101112131415161718192021public Employee implements Cloneable&#123; private String name; private double salary; private Date hireDay; . . . public Employee clone() throws CloneNotSupportedException &#123; // call Object.clone() Employee cloned = (Employee) super.clone(); // clone mutable fields cloned.hireDay = (Day) hireDay.clone(); return cloned; &#125; . . .&#125; 如果在一个对象上调用 clone，但这个对象的类并没有实现 Cloneable 接口，Object 类的 clone 方法就会抛出一个 CloneNotSupportException。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://wangtianyang.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://wangtianyang.com/tags/Java/"}]},{"title":"【读书笔记】《数据库系统概念》","slug":"【读书笔记】数据库系统概念","date":"2022-09-08T13:53:38.000Z","updated":"2023-01-06T13:31:46.089Z","comments":true,"path":"2022/09/08/【读书笔记】数据库系统概念/","link":"","permalink":"https://wangtianyang.com/2022/09/08/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/","excerpt":"引言数据库系统应用数据库有两种用途： 联机事务处理，即大量用户使用数据库，每个用户检索相对少量的数据，进行小的更新 数据分析，即审阅数据，给出结论 数据库系统的目标文件处理系统（file-processing system）有如下弊端： 数据冗余和不一致性 数据访问困难 数据孤立 完整性问题 原子性问题 并发访问异常 安全性问题 数据视图数据模型数据库结构的基础是数据模型（data model）：一个描述数据、数据联系、数据语义以及一致性约束的概念工具的集合。 数据模型可以被分为四类： 关系模型（relational model）：关系模型用表的集合来表示数据和数据间的联系，表也称为关系。 实体-联系模型（entity-relational model）：E-R模型使用称为实体的基本对象的集合，以及这些对象之间的联系。 半结构化数据模型（semi-structured data model）：半结构化数据模型允许在其数据定义中某些相同类型的数据项含有不同的属性集。比如JSON和可扩展标记语言（eXtensible Markuo Language, XML）。 基于对象的数据模型（object-based data model）：可以看成对关系模型进行扩展，增加了封装、方法和对象标识。","text":"引言数据库系统应用数据库有两种用途： 联机事务处理，即大量用户使用数据库，每个用户检索相对少量的数据，进行小的更新 数据分析，即审阅数据，给出结论 数据库系统的目标文件处理系统（file-processing system）有如下弊端： 数据冗余和不一致性 数据访问困难 数据孤立 完整性问题 原子性问题 并发访问异常 安全性问题 数据视图数据模型数据库结构的基础是数据模型（data model）：一个描述数据、数据联系、数据语义以及一致性约束的概念工具的集合。 数据模型可以被分为四类： 关系模型（relational model）：关系模型用表的集合来表示数据和数据间的联系，表也称为关系。 实体-联系模型（entity-relational model）：E-R模型使用称为实体的基本对象的集合，以及这些对象之间的联系。 半结构化数据模型（semi-structured data model）：半结构化数据模型允许在其数据定义中某些相同类型的数据项含有不同的属性集。比如JSON和可扩展标记语言（eXtensible Markuo Language, XML）。 基于对象的数据模型（object-based data model）：可以看成对关系模型进行扩展，增加了封装、方法和对象标识。 数据抽象通过数据抽象来对用户屏蔽复杂性，以简化用户与系统之间的交互，数据抽象的层次从低到高为： 物理层（physical level） 描述数据实际上是怎么存储的。 逻辑层（logical level） 描述数据库中存储什么数据以及数据间存在什么联系。 视图层（view level） 描述整个数据库的某个部分。 实例和模式特定时刻存储在数据库中的信息的集合称为数据库的一个实例，而数据库的总体设计乘坐数据库模式。 数据库语言数据库系统提供数据定义语言（Data-Definition Language, DDL）来定义数据库模式，并提供数据操纵语言（Data-Manipulation Language, DML）来表达数据库的查询和更新。他们是单一数据库语言（比如SQL）的不同部分。 数据库定义语言可以通过一系列被称作数据存储和定义的DDL语言来说明数据库系统所采用的存储结构和访问方式， 数据库系统仅实现可以以最小代价测试的完整性约束： 域约束（domain constraint）：每个属性都必须对应于一个域，比如整数型、字符型、日期/时间型。域约束是完整性约束的最基本形式。 引用完整性（referential integrity）。 授权（autorization）： 读权限 插入权限 更新权限 删除权限 SQL数据定义语言1234create table department(dept_name char(20),building char(15),budget numeric(12,2)); 数据操纵语言作用：对数据库增、删、改、查。 有两种类型的DML： 过程化的DML（procedural DML）：要求用户指定需要什么数据以及如何获得这些数据。 声明式的DML（declarative DML）：只要求用户指定需要什么数据，而不必指明如何获得这些数据。 SQL数据操纵语言查询一个表的例子： 123select instrector.namefrom instructorwhere instructor.dept_name = &#x27;History&#x27;; 查询多个表的例子： 1234select instrector.name, department.dept_namefrom instructor, departmentwhere instructor.dept_name = department.dept_name and department.budget &gt; 95000; 数据库引擎数据库系统的功能部件可分为存储管理器、查询处理器和事务管理部件。 存储管理器存储管理器（storage manager）是数据库系统中负责在数据库中存储的低层数据与应用程序以及向系统提交的查询之间提供接口的部件。存储管理器部件包括： 权限及完整性管理器 事务管理器 文件管理器 缓冲区管理器 存储管理器实现了以下几种数据结构： 数据文件 数据字典 索引 查询处理器 DDL解释器 DDL编译器 查询执行引擎 事务管理 原子性 一致性 持久性 事务管理器包括并发控制管理器和恢复管理器。 原子性和持久性的保证是恢复管理器的指责； 一致性是并发控制管理器的指责。 数据库和应用体系结构早期的数据库采用两层体系结构：客户机 -&gt; 数据库；现如今的数据库采用三层体系结构：客户机 -&gt; 应用服务器 -&gt; 数据库系统。三层结构比两层结构更安全、性能更好。 关系模型介绍关系数据库的结构在关系模型中，术语 关系（relation）被用来指代 表，而术语 元组（tuple）被用来指代 行，术语 属性（attribute）指代的是表中的 列。 关系是元组的 集合（set），所以元组在关系中出现的顺序是无关紧要的。 对于关系的每个属性都存在一个允许取值的集合，称为该属性的 域（domain）。我们要求一个关系的所有属性的域都是原子的。如果一个属性存的是一组集合，那么他就不是原子的。 关系型数据库适合存定义明确而且相对静态的应用，但不是用于存取那些数据本身以及数据类型结构经常变化的应用。 数据库模式 数据库模式：数据库的逻辑设计 数据库实例：数据库中数据的一个快照 码一个关系中不可以有两个元组在所有属性上取值完全相同。 超码（superkey）是一个或多个属性的集合，超码可以让我们在一个关系中唯一地表示出来一个元组。 如果 K 是一个超码，那么 K 的任意超集也都是超码，因此超码中可能包含无关紧要的属性。如果一个超码的任意真子集都不是超码，那么我们将这样的最小超码称为 候选码（candidate key）。 一个关系中可能存在两个或以上的候选码，因此我们用 主码（primary key）来表示被选中的候选码。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://wangtianyang.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://wangtianyang.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"后台开发面试知识点自查","slug":"后台开发面试知识点自查","date":"2022-09-02T12:20:51.000Z","updated":"2023-01-06T13:38:45.386Z","comments":true,"path":"2022/09/02/后台开发面试知识点自查/","link":"","permalink":"https://wangtianyang.com/2022/09/02/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E8%87%AA%E6%9F%A5/","excerpt":"C++C和C++的区别是什么？Answer网上最常用的两种说法是：C++是C的超集，或者说C是C++的子集、C++面向对象而C面向过程，但我认为这种抽象的说法并不对，C和C++的区别只能从更具体的方向阐述。C++提供了更强大的标准库STL，还有许多纷繁复杂的特性，比如模板、引用、智能指针、auto变量等。 误区一：C是C++的子集 网上这么说是因为C能实现的C++都能实现，而C++支持的C却未必能支持。但其实C++里面很多东西都可以在C里面用稍微别扭一些的方式实现，基本上只有两件事做不到，或者做起来尤其困难： 自动的对象作用域以及基于它的生命周期管理 模板 而且在一些细节却重要的地方，二者差别很大，比如 C 语言的函数指针： 1int (*pfunc)();","text":"C++C和C++的区别是什么？Answer网上最常用的两种说法是：C++是C的超集，或者说C是C++的子集、C++面向对象而C面向过程，但我认为这种抽象的说法并不对，C和C++的区别只能从更具体的方向阐述。C++提供了更强大的标准库STL，还有许多纷繁复杂的特性，比如模板、引用、智能指针、auto变量等。 误区一：C是C++的子集 网上这么说是因为C能实现的C++都能实现，而C++支持的C却未必能支持。但其实C++里面很多东西都可以在C里面用稍微别扭一些的方式实现，基本上只有两件事做不到，或者做起来尤其困难： 自动的对象作用域以及基于它的生命周期管理 模板 而且在一些细节却重要的地方，二者差别很大，比如 C 语言的函数指针： 1int (*pfunc)(); 看上去pfunc可以指向返回值为int，无参数的函数，但实际上pfunc可以指向任意返回值为int的函数，无论参数是什么。而无参的情况必须写明参数为void： 1int (*pfunc)(void); C语言不必指定参数类型也可以引用函数，这一点让C语言具有很强的动态特性。而C++去除了这种设计，因为破坏了类型安全。 同理，C语言常用的(void)转换在C++中也在很大程度上摒弃了，理由也是类型不安全。比如`intp = (void*)0;` 误区二：C++是面向对象的语言，C是面向过程的语言 现代C++是至少四种编程范式的集合体——面向过程，面向对象，泛型编程和元编程，函数式编程等，实际可能不止4种。说C++是面向对象语言，是一种很瞧不起C++的说法，因为面向对象仅仅是C++的多种范式之一。 在面向对象方面，C语言提供的语法支持比较薄弱，但这不表示C是面向过程的语言，用C语言也可以写面向对象的程序，例如Linux的图形界面GNOME就是用纯C写的。 C与C++ struct的区别？Answer C C++ 成员函数 不可以 可以 静态成员 不可以 可以 访问控制 默认public，不能修改 public/private/protected 继承关系 不可以 可以从类或其他结构体继承 初始化 不可以 可以 使用时，C需要加上struct关键字，或者用typedef取别名，而C++可以省略struct关键字直接使用，比如： 123456789struct Student &#123; int age; string name;&#125;typedef struct Student Student2; // C中取别名struct Student stu1; // C中正常使用Student2 stu2; // C中通过取别名使用Student stu3; // C++中使用 强类型、弱类型、静态类型、动态类型的区别是什么？Answer先上图 编译时就知道变量类型的是静态类型；运行时才知道一个变量类型的叫做动态类型。 不允许隐式转换的是强类型，允许隐式转换的是弱类型。 C++ 里常见的 auto ite = vec.iterator(); 这种也属于静态类型，这种叫做类型推导，通过已知的类型在编译时期推导出不知道的变量的类型。 弱类型： 12&gt; &quot;1&quot;+2&#x27;12&#x27; 强类型： 1234&gt;&gt;&gt; &quot;1&quot;+2Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: cannot concatenate &#x27;str&#x27; and &#x27;int&#x27; objects 动态类型： 123456&gt;&gt;&gt; a = 1&gt;&gt;&gt; type(a)&lt;type &#x27;int&#x27;&gt;&gt;&gt;&gt; a = &quot;s&quot;&gt;&gt;&gt; type(a)&lt;type &#x27;str&#x27;&gt; 静态类型： 123456Prelude&gt; let a = &quot;123&quot; :: Int&lt;interactive&gt;:2:9: Couldn&#x27;t match expected type `Int&#x27; with actual type `[Char]&#x27; In the expression: &quot;123&quot; :: Int In an equation for `a&#x27;: a = &quot;123&quot; :: Int include头文件双引号””和尖括号&lt;&gt;的区别？Answer 尖括号&lt;&gt;的头文件是系统文件，双引号””的头文件是自定义文件。 编译器预处理阶段查找头文件的路径不一样： 使用尖括号&lt;&gt;的头文件的查找路径:编译器设置的头文件路径—&gt;系统变量。 使用双引号””的头文件的查找路径:当前头文件目录—&gt;编译器设置的头文件路径—&gt;系统变 量。 C++程序编译过程？Answer编译过程分为四个过程：编译（编译预处理、编译、优化），汇编，链接。 编译预处理：处理以 # 开头的指令； 将所有的#define删除，并且展开所有的宏定义 处理所有的条件预编译指令，如#if、#ifdef 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置 过滤所有的注释 添加行号和文件名标识。 编译：将源码 .cpp 文件翻译成 .s 汇编代码； 词法分析:将源代码的字符序列分割成一系列的记号。 语法分析:对记号进行语法分析，产生语法树。 语义分析:判断表达式是否有意义。 代码优化 目标代码生成:生成汇编代码。 目标代码优化 汇编：将汇编代码 .s 翻译成机器指令 .o 文件； 链接：汇编程序生成的目标文件，即 .o 文件，并不会立即执行，因为可能会出现：.cpp 文件中的函数引用了另一个 .cpp 文件中定义的符号或者调用了某个库文件中的函数。那链接的目的就是将这些文件对应的目标文件连接成一个整体，从而生成可执行的程序 .exe 文件。 静态链接和动态链接的区别？Answer 静态链接：代码从其所在的静态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中。 动态链接：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间。 二者的优缺点： 静态链接：浪费空间，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（更新困难）；优点就是执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容。属于空间换时间。 动态链接：节省内存、更新方便，但是动态链接是在程序运行时，每次执行都需要链接，相比静态链接会有一定的性能损失。属于时间换空间。 静态库和动态库怎么创建？Answer以MacOS为例：假设我们有一个util.cpp文件和main.cpp文件，在main文件中调用util.cpp文件中定义的函数。我们把util.cpp文件制作成静态库和动态库。 生成目标文件 1g++ -c util.cpp -o util.o 打包静态库 1ar crv libutil.a util.o 生成动态库 1g++ -shared -fPIC -o libutil.so util.o 使用静态库 1g++ -g main.cpp libutil.a -o a.out 使用动态库 1g++ -g -std=c++11 main.cpp -L. -l util -o a.out -L. 意思是在当前目录下(./)寻找库 也可以写到一个makefile文件一键执行 1234567891011target: mkdir -p output g++ -c util.cpp -o ./output/util.o -std=c++11 ar crv ./output/libutil.a ./output/util.o g++ -shared -fPIC -o ./output/libutil.so ./output/util.o rm ./output/util.o g++ -g main.cpp ./output/libutil.a -o a.out -std=c++11 #g++ -g -std=c++11 main.cpp -L./output -l util -o a.out rm -rf *.dSYMclean: rm -rf ./output *.out *.dSYM C++内存布局？Answer Code Segment（代码区） 也称Text Segment，存放可执行程序的机器码。 Data Segment (数据区） 存放已初始化的全局和静态变量，常量数据（如字符串常量）。 BSS（Block started by symbol) 存放未初始化的全局和静态变量。（默认设为0） Heap（堆） 从低地址向高地址增长。容量大于栈，程序中动态分配的内存在此区域。 Stack（栈） 从高地址向低地址增长。由编译器自动管理分配。程序中的局部变量、函数参数值、返回变量等存在此区域。 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;/*说明：C++ 中不再区分初始化和未初始化的全局变量、静态变量的存储区，如果非要区分下述程序标注在了括号中*/int g_var = 0; // g_var 在数据区char *gp_var; // gp_var 在BSSint main()&#123; int var; // var 在栈区 char *p_var; // p_var 在栈区 char arr[] = &quot;abc&quot;; // arr 为数组变量，存储在栈区；&quot;abc&quot;为字符串常量，存储在数据区 char *p_var1 = &quot;123456&quot;; // p_var1 在栈区；&quot;123456&quot;为字符串常量，存储在数据区 static int s_var = 0; // s_var 为静态变量，存在数据区 p_var = (char *)malloc(10); // 分配得来的 10 个字节的区域在堆区 free(p_var); return 0;&#125; 栈和堆的区别？Answer 申请方式：栈是系统自动分配，堆是程序员主动申请。 申请后系统响应：分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；申请堆空间，堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上。 空间分配：栈在内存中是连续的一块空间（向低地址扩展）最大容量是系统预定好的，堆在内存中的空间（向高地址扩展）是不连续的。 申请效率：栈是由系统自动分配，申请效率高，但程序员无法控制；堆是由程序员主动申请，效率低，使用起来方便但是容易产生碎片。 存放的内容：栈中存放的是局部变量，函数的参数；堆中存放的内容由程序员控制。 自由存储区是否等价于堆？Answer堆是操作系统维护的一块内存，而自由存储是C++中通过new与delete动态分配和释放对象的抽象概念。在概念上两者并不等价，但是从技术上来说，两者是否等价要取决于operate new如何实现，C++编译器默认使用堆来实现自由存储，因为new和delete默认会由mollac和free来实现，但是也可以通过重载操作符来改用其他内存实现自由存储。 全局变量、局部变量、静态全局变量、静态局部变量的区别？AnswerC++ 变量根据定义的位置的不同的生命周期，具有不同的作用域，作用域可分为 6 种：全局作用域，局部作用域，语句作用域，类作用域，命名空间作用域和文件作用域。 从作用域看： 全局变量：在所有函数外部声明的变量，称为全局变量。具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他源文件需要用 extern 关键字再次声明这个全局变量。 静态全局变量：具有文件作用域。它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被 static 关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。 局部变量：具有局部作用域。它是自动对象（auto），在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。 静态局部变量：具有局部作用域。它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。 从分配内存空间看： 数据区：全局变量，静态局部变量，静态全局变量。 栈：局部变量。 全局变量定义在头文件中有什么问题？Answer如果在头文件中定义全局变量，当该头文件被多个文件include时，该头文件中的全局变量就会被定义多次，导致重复定义，因此不能再头文件中定义全局变量。 如何限制类的对象只能在堆上创建？如何限制对象只能在栈上创建？AnswerC++ 中的类的对象的建立分为两种：静态建立、动态建立。 静态建立：由编译器为对象在栈空间上分配内存，直接调用类的构造函数创建对象。例如：A a; 动态建立：使用 new 关键字在堆空间上创建对象，底层首先调用 operator new() 函数，在堆空间上寻找合适的内存并分配；然后，调用类的构造函数创建对象。例如：A *p = new A(); 限制对象只能建立在堆上： 最直观的思想：避免直接调用类的构造函数，因为对象静态建立时，会调用类的构造函数创建对象。但是直接将类的构造函数设为私有并不可行，因为当构造函数设置为私有后，不能在类的外部调用构造函数来构造对象，只能用 new 来建立对象。但是由于 new 创建对象时，底层也会调用类的构造函数，将构造函数设置为私有后，那就无法在类的外部使用 new 创建对象了。因此，这种方法不可行。 解决方法 1： 将析构函数设置为私有。原因：静态对象建立在栈上，是由编译器分配和释放内存空间，编译器为对象分配内存空间时，会对类的非静态函数进行检查，即编译器会检查析构函数的访问性。当析构函数设为私有时，编译器创建的对象就无法通过访问析构函数来释放对象的内存空间，因此，编译器不会在栈上为对象分配内存。 12345678910class A&#123;public: A() &#123;&#125; void destory() &#123; delete this; &#125;private: ~A() &#123;&#125;&#125;; 该方法存在的问题： 用 new 创建的对象，通常会使用 delete 释放该对象的内存空间，但此时类的外部无法调用析构函数，因此类内必须定义一个 destory() 函数，用来释放 new 创建的对象。 无法解决继承问题，因为如果这个类作为基类，析构函数要设置成 virtual，然后在派生类中重写该函数，来实现多态。但此时，析构函数是私有的，派生类中无法访问。 解决方法 2： 构造函数设置为 protected，并提供一个 public 的静态函数来完成构造，而不是在类的外部使用 new 构造；将析构函数设置为 protected。原因：类似于单例模式，也保证了在派生类中能够访问析构函数。通过调用 create() 函数在堆上创建对象。 123456789101112131415class A&#123;protected: A() &#123;&#125; ~A() &#123;&#125;public: static A *create() &#123; return new A(); &#125; void destory() &#123; delete this; &#125;&#125;; 限制对象只能建立在栈上： 解决方法：将 operator new() 设置为私有。原因：当对象建立在堆上时，是采用 new 的方式进行建立，其底层会调用 operator new() 函数，因此只要对该函数加以限制，就能够防止对象建立在堆上。 123456789class A&#123;private: void *operator new(size_t t) &#123;&#125; // 注意函数的第一个参数和返回值都是固定的 void operator delete(void *ptr) &#123;&#125; // 重载了 new 就需要重载 deletepublic: A() &#123;&#125; ~A() &#123;&#125;&#125;; 什么是内存对齐？内存对齐的原则？为什么要进行内存对齐，有什么优点？Answer内存对齐：编译器将程序中的每个“数据单元”安排在字的整数倍的地址指向的内存之中 内存对齐的原则： 结构体变量的首地址能够被其最宽基本类型成员大小与对齐基数中的较小者所整除； 关于对齐基数，gcc中默认#pragma pack(4)，可以通过预编译命令#pragma pack(n)，n = 1,2,4,8,16来改变这一系数。 结构体每个成员相对于结构体首地址的偏移量 （offset） 都是该成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在成员之间加上填充字节 （internal padding）； 结构体的总大小为结构体最宽基本类型成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在最末一个成员之后加上填充字节 （trailing padding）。 1234567891011121314151617181920212223242526272829303132/*说明：程序是在 64 位编译器下测试的*/#include &lt;iostream&gt;using namespace std;struct A&#123; short var; // 2 字节 int var1; // 8 字节 （内存对齐原则：填充 2 个字节） 2 (short) + 2 (填充) + 4 (int)= 8 long var2; // 12 字节 8 + 4 (long) = 12 char var3; // 16 字节 （内存对齐原则：填充 3 个字节）12 + 1 (char) + 3 (填充) = 16 string s; // 48 字节 16 + 32 (string) = 48&#125;;int main()&#123; short var; int var1; long var2; char var3; string s; A ex1; cout &lt;&lt; sizeof(var) &lt;&lt; endl; // 2 short cout &lt;&lt; sizeof(var1) &lt;&lt; endl; // 4 int cout &lt;&lt; sizeof(var2) &lt;&lt; endl; // 4 long cout &lt;&lt; sizeof(var3) &lt;&lt; endl; // 1 char cout &lt;&lt; sizeof(s) &lt;&lt; endl; // 32 string cout &lt;&lt; sizeof(ex1) &lt;&lt; endl; // 48 struct return 0;&#125; 进行内存对齐的原因：（主要是硬件设备方面的问题） 某些硬件设备只能存取对齐数据，存取非对齐的数据可能会引发异常； 某些硬件设备不能保证在存取非对齐数据的时候的操作是原子操作； 相比于存取对齐的数据，存取非对齐的数据需要花费更多的时间； 某些处理器虽然支持非对齐数据的访问，但会引发对齐陷阱（alignment trap）； 某些硬件设备只支持简单数据指令非对齐存取，不支持复杂数据指令的非对齐存取。 内存对齐的优点： 便于在不同的平台之间进行移植，因为有些硬件平台不能够支持任意地址的数据访问，只能在某些地址处取某些特定的数据，否则会抛出异常； 提高内存的访问效率，因为 CPU 在读取内存时，是一块一块的读取。 怎么计算类的大小？Answer类的大小是指类的实例化对象的大小，用 sizeof 对类型名操作时，结果是该类型的对象的大小。 计算原则： 遵循结构体的对齐原则。 与普通成员变量有关，与成员函数和静态成员无关。即普通成员函数，静态成员函数，静态数据成员，静态常量数据成员均对类的大小无影响。因为静态数据成员被类的对象共享，并不属于哪个具体的对象。 虚函数对类的大小有影响，是因为虚函数表指针的影响。 虚继承对类的大小有影响，是因为虚基表指针带来的影响。 空类的大小是一个特殊情况，空类的大小为 1，当用 new 来创建一个空类的对象时，为了保证不同对象的地址不同，空类也占用存储空间。 123456789101112131415161718192021222324252627282930/*说明：程序是在 64 位编译器下测试的*/#include &lt;iostream&gt;using namespace std;class A&#123;private: static int s_var; // 不影响类的大小 const int c_var; // 4 字节 int var; // 8 字节 4 + 4 (int) = 8 char var1; // 12 字节 8 + 1 (char) + 3 (填充) = 12public: A(int temp) : c_var(temp) &#123;&#125; // 不影响类的大小 ~A() &#123;&#125; // 不影响类的大小&#125;;class B&#123;&#125;;int main()&#123; A ex1(4); B ex2; cout &lt;&lt; sizeof(ex1) &lt;&lt; endl; // 12 字节 cout &lt;&lt; sizeof(ex2) &lt;&lt; endl; // 1 字节 return 0;&#125; 带有虚函数的情况：（注意：虚函数的个数并不影响所占内存的大小，因为类对象的内存中只保存了指向虚函数表的指针。） 1234567891011121314151617181920212223242526272829303132/*说明：程序是在 64 位编译器下测试的*/#include &lt;iostream&gt;using namespace std;class A&#123;private: static int s_var; // 不影响类的大小 const int c_var; // 4 字节 int var; // 8 字节 4 + 4 (int) = 8 char var1; // 12 字节 8 + 1 (char) + 3 (填充) = 12public: A(int temp) : c_var(temp) &#123;&#125; // 不影响类的大小 ~A() &#123;&#125; // 不影响类的大小 virtual void f() &#123; cout &lt;&lt; &quot;A::f&quot; &lt;&lt; endl; &#125; virtual void g() &#123; cout &lt;&lt; &quot;A::g&quot; &lt;&lt; endl; &#125; virtual void h() &#123; cout &lt;&lt; &quot;A::h&quot; &lt;&lt; endl; &#125; // 24 字节 12 + 4 (填充) + 8 (指向虚函数的指针) = 24&#125;;int main()&#123; A ex1(4); A *p; cout &lt;&lt; sizeof(p) &lt;&lt; endl; // 8 字节 注意：指针所占的空间和指针指向的数据类型无关 cout &lt;&lt; sizeof(ex1) &lt;&lt; endl; // 24 字节 return 0;&#125; 什么是内存泄露？Answer内存泄漏：由于疏忽或错误导致的程序未能释放已经不再使用的内存。 进一步解释： 并非指内存从物理上消失，而是指程序在运行过程中，由于疏忽或错误而失去了对该内存的控制，从而造成了内存的浪费。 常指堆内存泄漏，因为堆是动态分配的，而且是用户来控制的，如果使用不当，会产生内存泄漏。 使用 malloc、calloc、realloc、new 等分配内存时，使用完后要调用相应的 free 或 delete 释放内存，否则这块内存就会造成内存泄漏。 指针重新赋值 123char *p = (char *)malloc(10);char *p1 = (char *)malloc(10);p = p1; 开始时，指针 p 和 p1 分别指向一块内存空间，但指针 p 被重新赋值，导致 p 初始时指向的那块内存空间无法找到，从而发生了内存泄漏。 怎么防止内存泄漏？内存泄漏检测工具的原理？Answer智能指针 智能指针是 C++ 中已经对内存泄漏封装好了一个工具，可以直接拿来使用 智能指针是为了解决动态内存分配时带来的内存泄漏以及多次释放同一块内存空间而提出的。C++11 中封装在了头文件&lt;memory&gt;中。 智能指针有哪几种？AnswerC++ 标准模板库 STL（Standard Template Library） 一共给我们提供了四种智能指针：auto_ptr、unique_ptr、shared_ptr 和 weak_ptr，其中 auto_ptr 是 C++98 提出的，C++11 已将其摒弃，并提出了 unique_ptr 替代 auto_ptr。 共享指针（shared_ptr）：《Effective C++》称之为“引用计数型智能指针”，资源可以被多个指针共享，使用计数机制表明资源被几个指针共享。通过 use_count() 查看资源的所有者的个数，可以通过 weak_ptr 来构造，调用 release() 释放资源的所有权，计数减一，当计数减为 0 时，会自动释放内存空间，从而避免了内存泄漏。 独占指针（unique_ptr）：独享所有权的智能指针，资源只能被一个指针占有，该指针不能拷贝构造和赋值。但可以进行移动构造和移动赋值构造（调用 move() 函数），即一个 unique_ptr 对象赋值给另一个 unique_ptr 对象，可以通过该方法进行赋值。 弱指针（weak_ptr）：指向 share_ptr 指向的对象，能够解决由shared_ptr带来的循环引用问题。使用 weak_ptr 的成员函数 use_count() 可以观测资源的引用计数，另一个成员函数 expired() 的功能等价于 use_count()==0，但更快，表示被观测的资源（也就是 shared_ptr 管理的资源）已经不复存在。weak_ptr 可以使用一个非常重要的成员函数lock()从被观测的 shared_ptr 获得一个可用的 shared_ptr 管理的对象， 从而操作资源。但当 expired()==true 的时候，lock()函数将返回一个存储空指针的 shared_ptr。 shared_ptr和unique_ptr的区别？Answershared_ptr允许多个指针指向同一个对象，而unique_ptr 独占所指向的对象。与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr被销毁时，它所指向的对象也被销毁。 shared_ptr类12shared_ptr&lt;string&gt; p1; //可以指向stringshared_ptr&lt;list&lt;int&gt;&gt; p2; //可以指向int的list make_shared函数最安全的分配和使用动态内存的方法是调用一个名为make_shared的标准库函数。此函数在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr。 当要用make_shared时，必须指定想要创建的对象的类型，如下： 123456//指向一个值为42的int的shared_ptrshared_ptr&lt;int&gt; p3 = make_shared&lt;int&gt;(42);//p4指向一个值为&quot;9999999999&quot;的stringshared_ptr&lt;string&gt; p4 = make_shared&lt;string&gt;(10,&#x27;9&#x27;);//p5指向一个值初始化的int,值为0shared_ptr&lt;int&gt; p5 = make_shared&lt;int&gt;(); 也可以使用auto定义一个对象来保存make_shared的结果，更为简单： 12//p6指向一个动态分配的空vector&lt;string&gt;auto p6 = make_shared&lt;vector&lt;string&gt;&gt;(); 当进行拷贝或赋值操作时，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象： 12auto p = make_shared&lt;int&gt;(42); //p指向的对象只有p一个引用者auto q(p); //p和q指向相同对象，此对象有两个引用者 我们可以认为每个shared_ptr都有一个关联的计数器，通常称其为引用计数。无论何时我们拷贝一个shared_ptr，计数器都会递增。 unique_ptr类与shared_ptr不同，没有类似make_shared的标准库函数返回一个unique_ptr。所以初始化unique_ptr必须采用直接初始化形式，如下： 12unique_ptr&lt;double&gt; p1; //可以指向一个double的unique_ptrunique_ptr&lt;int&gt; p2(new int(42)); //p2指向一个值为42的int 实现一个shared_ptr。Answer计数原理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;memory&gt;template &lt;typename T&gt;class SmartPtr &#123;private : T *_ptr; size_t *_count;public: SmartPtr(T *ptr = nullptr) : _ptr(ptr) &#123; if (_ptr) &#123; _count = new size_t(1); &#125; else &#123; _count = new size_t(0); &#125; &#125; ~SmartPtr() &#123; (*this-&gt;_count)--; if (*this-&gt;_count == 0) &#123; delete this-&gt;_ptr; delete this-&gt;_count; &#125; &#125; SmartPtr(const SmartPtr &amp;ptr) &#123; // 拷贝构造：计数 +1 if (this != &amp;ptr) &#123; this-&gt;_ptr = ptr._ptr; this-&gt;_count = ptr._count; (*this-&gt;_count)++; &#125; &#125; SmartPtr &amp;operator=(const SmartPtr &amp;ptr) &#123; // 赋值运算符重载 if (this-&gt;_ptr == ptr._ptr) &#123; return *this; &#125; if (this-&gt;_ptr) &#123; // 将当前的 ptr 指向的原来的空间的计数 -1 (*this-&gt;_count)--; if (this-&gt;_count == 0) &#123; delete this-&gt;_ptr; delete this-&gt;_count; &#125; &#125; this-&gt;_ptr = ptr._ptr; this-&gt;_count = ptr._count; (*this-&gt;_count)++; // 此时 ptr 指向了新赋值的空间，该空间的计数 +1 return *this; &#125; T &amp;operator*() &#123; assert(this-&gt;_ptr == nullptr); return *(this-&gt;_ptr); &#125; T *operator-&gt;() &#123; assert(this-&gt;_ptr == nullptr); return this-&gt;_ptr; &#125; size_t use_count() &#123; return *this-&gt;count; &#125;&#125;; 一个独占指针（unique_ptr）怎么赋值给另一个独占指针（unique_ptr）对象？Answer借助 std::move() 可以实现将一个 unique_ptr 对象赋值给另一个 unique_ptr 对象，其目的是实现所有权的转移。 123// A 作为一个类 std::unique_ptr&lt;A&gt; ptr1(new A());std::unique_ptr&lt;A&gt; ptr2 = std::move(ptr1); 使用智能指针会出现什么问题？怎么解决？Answer智能指针可能出现的问题：循环引用。在如下例子中定义了两个类 Parent、Child，在两个类中分别定义另一个类的对象的共享指针，由于在程序结束后，两个指针相互指向对方的内存空间，导致内存无法释放。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;class Child;class Parent;class Parent &#123;private: shared_ptr&lt;Child&gt; ChildPtr;public: void setChild(shared_ptr&lt;Child&gt; child) &#123; this-&gt;ChildPtr = child; &#125; void doSomething() &#123; if (this-&gt;ChildPtr.use_count()) &#123; &#125; &#125; ~Parent() &#123; &#125;&#125;;class Child &#123;private: shared_ptr&lt;Parent&gt; ParentPtr;public: void setPartent(shared_ptr&lt;Parent&gt; parent) &#123; this-&gt;ParentPtr = parent; &#125; void doSomething() &#123; if (this-&gt;ParentPtr.use_count()) &#123; &#125; &#125; ~Child() &#123; &#125;&#125;;int main() &#123; weak_ptr&lt;Parent&gt; wpp; weak_ptr&lt;Child&gt; wpc; &#123; shared_ptr&lt;Parent&gt; p(new Parent); shared_ptr&lt;Child&gt; c(new Child); p-&gt;setChild(c); c-&gt;setPartent(p); wpp = p; wpc = c; cout &lt;&lt; p.use_count() &lt;&lt; endl; // 2 cout &lt;&lt; c.use_count() &lt;&lt; endl; // 2 &#125; cout &lt;&lt; wpp.use_count() &lt;&lt; endl; // 1 cout &lt;&lt; wpc.use_count() &lt;&lt; endl; // 1 return 0;&#125; 循环引用的解决方法：weak_ptr 循环引用：该被调用的析构函数没有被调用，从而出现了内存泄漏。 weak_ptr 对被 shared_ptr 管理的对象存在 非拥有性（弱）引用，在访问所引用的对象前必须先转化为 shared_ptr； weak_ptr 用来打断 shared_ptr 所管理对象的循环引用问题，若这种环被孤立（没有指向环中的外部共享指针），shared_ptr 引用计数无法抵达 0，内存被泄露；令环中的指针之一为弱指针可以避免该情况； weak_ptr 用来表达临时所有权的概念，当某个对象只有存在时才需要被访问，而且随时可能被他人删除，可以用 weak_ptr 跟踪该对象；需要获得所有权时将其转化为 shared_ptr，此时如果原来的 shared_ptr 被销毁，则该对象的生命期被延长至这个临时的 shared_ptr 同样被销毁。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;class Child;class Parent;class Parent &#123;private: //shared_ptr&lt;Child&gt; ChildPtr; weak_ptr&lt;Child&gt; ChildPtr;public: void setChild(shared_ptr&lt;Child&gt; child) &#123; this-&gt;ChildPtr = child; &#125; void doSomething() &#123; //new shared_ptr if (this-&gt;ChildPtr.lock()) &#123; &#125; &#125; ~Parent() &#123; &#125;&#125;;class Child &#123;private: shared_ptr&lt;Parent&gt; ParentPtr;public: void setPartent(shared_ptr&lt;Parent&gt; parent) &#123; this-&gt;ParentPtr = parent; &#125; void doSomething() &#123; if (this-&gt;ParentPtr.use_count()) &#123; &#125; &#125; ~Child() &#123; &#125;&#125;;int main() &#123; weak_ptr&lt;Parent&gt; wpp; weak_ptr&lt;Child&gt; wpc; &#123; shared_ptr&lt;Parent&gt; p(new Parent); shared_ptr&lt;Child&gt; c(new Child); p-&gt;setChild(c); c-&gt;setPartent(p); wpp = p; wpc = c; cout &lt;&lt; p.use_count() &lt;&lt; endl; // 2 cout &lt;&lt; c.use_count() &lt;&lt; endl; // 1 &#125; cout &lt;&lt; wpp.use_count() &lt;&lt; endl; // 0 cout &lt;&lt; wpc.use_count() &lt;&lt; endl; // 0 return 0;&#125; C++11 有哪些新特性？Answer auto 类型推导关键字：自动类型推导，编译器会在 编译期间 通过初始值推导出变量的类型，通过 auto 定义的变量必须有初始值。 decltype 类型推导关键字：decltype 是“declare type”的缩写，译为“声明类型”。和 auto 的功能一样，都用来在编译期间进行自动类型推导。如果希望从表达式中推断出要定义的变量的类型，但是不想用该表达式的值初始化变量，这时就不能再用 auto。和auto的区别如下： 12auto var = val1 + val2; decltype(val1 + val2) var1 = 0; lambda 表达式（匿名函数） 1234 [capture list] (parameter list) -&gt; return type&#123; function body;&#125;; 范围for语句 123 for (declaration : expression)&#123; statement&#125; 右值引用、移动语义、完美转发 看我另一篇博文——C++右值引用 智能指针 delete 函数和 default 函数 delete 函数：= delete 表示该函数不能被调用。 default 函数：= default 表示编译器生成默认的函数，例如：生成默认的构造函数。 例子： 12345678910111213141516171819 #include &lt;iostream&gt;using namespace std;class A&#123;ßpublic: A() = default; // 表示使用默认的构造函数 ~A() = default; // 表示使用默认的析构函数 A(const A &amp;) = delete; // 表示类的对象禁止拷贝构造 A &amp;operator=(const A &amp;) = delete; // 表示类的对象禁止拷贝赋值&#125;;int main()&#123; A ex1; A ex2 = ex1; // error: use of deleted function &#x27;A::A(const A&amp;)&#x27; A ex3; ex3 = ex1; // error: use of deleted function &#x27;A&amp; A::operator=(const A&amp;)&#x27; return 0;&#125; 什么是面向对象？面向对象的三大特性？Answer面向对象：对象是指具体的某一个事物，这些事物的抽象就是类，类中包含数据（成员变量）和动作（成员方法）。 面向对象的三大特性： 封装：将具体的实现过程和数据封装成一个函数，只能通过接口进行访问，降低耦合性。 继承：子类继承父类的特征和行为，子类有父类的非 private 方法或成员变量，子类可以对父类的方法进行重写，增强了类之间的耦合性，但是当父类中的成员变量、成员函数或者类本身被 final 关键字修饰时，修饰的类不能继承，修饰的成员不能重写或修改。 多态：多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。 重载、重写/覆盖、重定义/隐藏的区别？Answer 重载：函数名相同，函数的参数个数、参数类型或参数顺序三者中必须至少有一种不同。函数返回值的类型可以相同，也可以不相同。发生在一个类内部，不能跨作用域。 重定义：也叫做隐藏，子类重新定义父类中有相同名称的非虚函数 ( 参数列表可以不同 ) ，指派生类的函数屏蔽了与其同名的基类函数。可以理解成发生在继承中的重载。 重写：也叫做覆盖（override），一般发生在子类和父类继承关系之间。子类重新定义父类中有相同名称和参数的虚函数。(访问修饰符可以不同) 什么是多态？多态如何实现？Answer多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。在基类的函数前加上 virtual 关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。 实现方法：多态是通过虚函数实现的，虚函数的地址保存在虚函数表中，虚函数表的地址保存在含有虚函数的类的实例对象的内存空间中。 实现过程： 在类中用 virtual 关键字声明的函数叫做虚函数； 存在虚函数的类都有一个虚函数表，当创建一个该类的对象时，该对象有一个指向虚函数表的虚表指针（虚函数表和类对应的，虚表指针是和对象对应）； 当基类指针指向派生类对象，基类指针调用虚函数时，基类指针指向派生类的虚表指针，由于该虚表指针指向派生类虚函数表，通过遍历虚表，寻找相应的虚函数。 举例： 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;class Base&#123;public: virtual void fun() &#123; cout &lt;&lt; &quot;Base::fun()&quot; &lt;&lt; endl; &#125; virtual void fun1() &#123; cout &lt;&lt; &quot;Base::fun1()&quot; &lt;&lt; endl; &#125; virtual void fun2() &#123; cout &lt;&lt; &quot;Base::fun2()&quot; &lt;&lt; endl; &#125;&#125;;class Derive : public Base&#123;public: void fun() &#123; cout &lt;&lt; &quot;Derive::fun()&quot; &lt;&lt; endl; &#125; virtual void D_fun1() &#123; cout &lt;&lt; &quot;Derive::D_fun1()&quot; &lt;&lt; endl; &#125; virtual void D_fun2() &#123; cout &lt;&lt; &quot;Derive::D_fun2()&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; Base *p = new Derive(); p-&gt;fun(); // Derive::fun() 调用派生类中的虚函数 return 0;&#125; 基类的虚函数表如下： 派生类的对象虚函数表如下： 简单解释：当基类的指针指向派生类的对象时，通过派生类的对象的虚表指针找到虚函数表（派生类的对象虚函数表），进而找到相应的虚函数Derive::f()进行调用。 strlen和sizeof的区别？Answer strlen测量的是字符串的实际长度（其源代码如下），以\\0结束。而sizeof测量的是字符数组的分配大小。 123456789101112#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main()&#123; char arr[10] = &quot;hello&quot;; cout &lt;&lt; strlen(arr) &lt;&lt; endl; // 5 cout &lt;&lt; sizeof(arr) &lt;&lt; endl; // 10 return 0;&#125; 若字符数组 arr 作为函数的形参，sizeof(arr) 中 arr 被当作字符指针来处理，strlen(arr) 中 arr 依然是字符数组，从下述程序的运行结果中就可以看出。 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;void size_of(char arr[])&#123; cout &lt;&lt; sizeof(arr) &lt;&lt; endl; // warning: &#x27;sizeof&#x27; on array function parameter &#x27;arr&#x27; will return size of &#x27;char*&#x27; . cout &lt;&lt; strlen(arr) &lt;&lt; endl; &#125;int main()&#123; char arr[20] = &quot;hello&quot;; size_of(arr); return 0;&#125;/*输出结果：85*/ strlen本身是库函数，因此在程序运行过程中，计算长度；而sizeof在编译时，计算长度； sizeof的参数可以是类型，也可以是变量；strlen的参数必须是char*类型的变量。 lambda 表达式（匿名函数）的具体应用和使用场景Answerlambda 表达式的定义形式如下： 1234[capture list] (parameter list) -&gt; reurn type&#123; function body&#125; 其中： capture list：捕获列表，指 lambda 表达式所在函数中定义的局部变量的列表，通常为空，但如果函数体中用到了 lambda 表达式所在函数的局部变量，必须捕获该变量，即将此变量写在捕获列表中。捕获方式分为：引用捕获方式 [&amp;]、值捕获方式 [=]。 return type、parameter list、function body：分别表示返回值类型、参数列表、函数体，和普通函数一样。 举例：lambda表达式常搭配排序算法使用。 12345678910111213141516#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; vector&lt;int&gt; arr = &#123;3, 4, 76, 12, 54, 90, 34&#125;; sort(arr.begin(), arr.end(), [](int a, int b) &#123; return a &gt; b; &#125;); // 降序排序 for (auto a : arr) &#123; cout &lt;&lt; a &lt;&lt; &quot; &quot;; &#125; return 0;&#125;/*运行结果：90 76 54 34 12 4 3*/ explicit 的作用（如何避免编译器进行隐式类型转换）Answer作用：用来声明类构造函数是显式调用[1]的，而非隐式调用，可以阻止调用构造函数时进行隐式转换。只可用于修饰单参构造函数，因为无参构造函数和多参构造函数本身就是显示调用的，再加上explicit关键字也没有什么意义。 123456789101112131415#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;class A &#123;public: int var; A(int tmp) &#123; var = tmp; &#125;&#125;;int main() &#123; A ex = 10; // 发生了隐式转换 return 0;&#125; 上述代码中，A ex = 10;在编译时，进行了隐式转换，将 10 转换成 A 类型的对象，然后将该对象赋值给 ex，等同于如下操作：为了避免隐式转换，可用 explicit 关键字进行声明： 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;class A&#123;public: int var; explicit A(int tmp) &#123; var = tmp; cout &lt;&lt; var &lt;&lt; endl; &#125;&#125;;int main()&#123; A ex(100); A ex1 = 10; // error: conversion from &#x27;int&#x27; to non-scalar type &#x27;A&#x27; requested return 0;&#125; static 的作用Answer作用：static 定义静态变量，静态函数。 保持变量内容持久：static 作用于局部变量，改变了局部变量的生存周期，使得该变量存在于定义后直到程序运行结束的这段时间。 123456789101112131415#include &lt;iostream&gt;using namespace std;int fun()&#123; static int var = 1; // var 只在第一次进入这个函数的时初始化 var += 1; return var;&#125; int main()&#123; for(int i = 0; i &lt; 10; ++i) cout &lt;&lt; fun() &lt;&lt; &quot; &quot;; // 2 3 4 5 6 7 8 9 10 11 return 0;&#125; 隐藏：static 作用于全局变量和函数，改变了全局变量和函数的作用域，使得全局变量和函数只能在定义它的文件中使用，在源文件中不具有全局可见性。（注：普通全局变量和函数具有全局可见性，即其他的源文件也可以使用。） static 作用于类的成员变量和类的成员函数，使得类变量或者类成员函数和类有关，也就是说可以不定义类的对象就可以通过类访问这些静态成员。注意：类的静态成员函数中只能访问静态成员变量或者静态成员函数，不能将静态成员函数定义成虚函数。 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;using namespace std;class A&#123;private: int var; static int s_var; // 静态成员变量public: void show() &#123; cout &lt;&lt; s_var++ &lt;&lt; endl; &#125; static void s_show() &#123; cout &lt;&lt; s_var &lt;&lt; endl; // cout &lt;&lt; var &lt;&lt; endl; // error: invalid use of member &#x27;A::a&#x27; in static member function. 静态成员函数不能调用非静态成员变量。无法使用 this.var // show(); // error: cannot call member function &#x27;void A::show()&#x27; without object. 静态成员函数不能调用非静态成员函数。无法使用 this.show() &#125;&#125;;int A::s_var = 1; // 静态成员变量在类外进行初始化赋值，默认初始化为 0int main()&#123; // cout &lt;&lt; A::s_var &lt;&lt; endl; // error: &#x27;int A::sa&#x27; is private within this context A ex; ex.show(); A::s_show();&#125; static 在类中使用的注意事项（定义、初始化和使用）Answer static 静态成员变量： 静态成员变量是在类内进行声明，在类外进行定义和初始化，在类外进行定义和初始化的时候不要出现 static 关键字和private、public、protected 访问规则。 静态成员变量相当于类域中的全局变量，被类的所有对象所共享，包括派生类的对象。 静态成员变量可以作为成员函数的参数，而普通成员变量不可以。 123456789101112131415#include &lt;iostream&gt;using namespace std;class A&#123;public: static int s_var; int var; void fun1(int i = s_var); // 正确，静态成员变量可以作为成员函数的参数 void fun2(int i = var); // error: invalid use of non-static data member &#x27;A::var&#x27;&#125;;int main()&#123; return 0;&#125; 静态数据成员的类型可以是所属类的类型，而普通数据成员的类型只能是该类类型的指针或引用。 12345678910111213141516#include &lt;iostream&gt;using namespace std;class A&#123;public: static A s_var; // 正确，静态数据成员 A var; // error: field &#x27;var&#x27; has incomplete type &#x27;A&#x27; A *p; // 正确，指针 A &amp;var1; // 正确，引用&#125;;int main()&#123; return 0;&#125; static 静态成员函数： 静态成员函数不能调用非静态成员变量或者非静态成员函数，因为静态成员函数没有 this 指针。静态成员函数做为类作用域的全局函数。 静态成员函数不能声明成虚函数（virtual）、const 函数和 volatile 函数。 static 全局变量和普通全局变量的异同？Answer相同点： 存储方式：普通全局变量和 static 全局变量都是静态存储方式。 不同点： 作用域：普通全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，普通全局变量在各个源文件中都是有效的；静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。 初始化：静态全局变量只初始化一次，防止在其他文件中使用。 const 作用及用法Answer作用： const 修饰成员变量，定义成 const 常量，相较于宏常量，可进行类型检查，节省内存空间，提高了效率。 const 修饰函数参数，使得传递过来的函数参数的值不能改变。 const 修饰成员函数，使得成员函数不能修改任何类型的成员变量（mutable 修饰的变量除外），也不能调用非 const 成员函数，因为非 const 成员函数可能会修改成员变量 在类中的用法： const 成员变量： const 成员变量只能在类内声明、定义，在构造函数初始化列表中初始化。 const 成员变量只在某个对象的生存周期内是常量，对于整个类而言却是可变的，因为类可以创建多个对象，不同类的 const 成员变量的值是不同的。因此不能在类的声明中初始化 const 成员变量，类的对象还没有创建，编译器不知道他的值。 const 成员函数： 不能修改成员变量的值，除非有 mutable 修饰；只能访问成员变量。 不能调用非常量成员函数，以防修改成员变量的值。 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;class A&#123;public: int var; A(int tmp) : var(tmp) &#123;&#125; void c_fun(int tmp) const // const 成员函数 &#123; var = tmp; // error: assignment of member &#x27;A::var&#x27; in read-only object. 在 const 成员函数中，不能修改任何类成员变量。 fun(tmp); // error: passing &#x27;const A&#x27; as &#x27;this&#x27; argument discards qualifiers. const 成员函数不能调用非 const 成员函数，因为非 const 成员函数可能会修改成员变量。 &#125; void fun(int tmp) &#123; var = tmp; &#125;&#125;;int main()&#123; return 0;&#125; define 和 const 的区别？Answer区别： 编译阶段：define 是在预编译阶段进行替换，const 是在编译阶段确定其值。 安全性：define 定义的宏常量没有数据类型，只是进行简单的替换，不会进行类型安全的检查；const 定义的常量是有类型的，是要进行判断的，可以避免一些低级的错误。 内存占用：define 定义的宏常量，在程序中使用多少次就会进行多少次替换，内存中有多个备份，占用的是代码段的空间；const 定义的常量占用静态存储区的空间，程序运行过程中只有一份。 调试：define 定义的宏常量不能调试，因为在预编译阶段就已经进行替换了；const 定义的常量可以进行调试。 const 的优点： 有数据类型，在定义式可进行安全性检查。 可调试。 占用较少的空间。 define 和 typedef 的区别？Answer 原理：#define作为预处理指令，在编译预处理时进行替换操作，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。typedef是关键字，在编译时处理，有类型检查功能，用来给一个已经存在的类型一个别名，但不能在一个函数定义里面使用typedef。 功能：typedef用来定义类型的别名，方便使用。#define不仅可以为类型取别名，还可以定义常量、变量、编译开关等。 作用域：#define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而typedef有自己的作用域。 指针的操作：typedef和#define在处理指针时不完全一样。1234567891011121314151617#include &lt;iostream&gt;#define INTPTR1 int *typedef int * INTPTR2;using namespace std;int main()&#123; INTPTR1 p1, p2; // p1: int *; p2: int INTPTR2 p3, p4; // p3: int *; p4: int * int var = 1; const INTPTR1 p5 = &amp;var; // 相当于 const int * p5; 常量指针，即不可以通过 p5 去修改 p5 指向的内容，但是 p5 可以指向其他内容。 const INTPTR2 p6 = &amp;var; // 相当于 int * const p6; 指针常量，不可使 p6 再指向其他内容。 return 0;&#125; inline 作用及使用方法Answer作用： inline 是一个关键字，可以用于定义内联函数。内联函数，像普通函数一样被调用，但是在调用时并不通过函数调用的机制而是直接在调用点处展开，这样可以大大减少由函数调用带来的开销，从而提高程序的运行效率。 使用方法： 类内定义成员函数默认是内联函数：在类内定义成员函数，可以不用在函数头部加 inline 关键字，因为编译器会自动将类内定义的函数（构造函数、析构函数、普通成员函数等）声明为内联函数，代码如下：123456789101112131415161718#include &lt;iostream&gt;using namespace std;class A&#123;public: int var; A(int tmp)&#123; var = tmp; &#125; void fun()&#123; cout &lt;&lt; var &lt;&lt; endl; &#125;&#125;;int main()&#123; return 0;&#125; 类外定义成员函数，若想定义为内联函数，需用关键字声明：当在类内声明函数，在类外定义函数时，如果想将该函数定义为内联函数，则可以在类内声明时不加 inline 关键字，而在类外定义函数时加上 inline 关键字。1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;class A&#123;public: int var; A(int tmp)&#123; var = tmp; &#125; void fun();&#125;;inline void A::fun()&#123; cout &lt;&lt; var &lt;&lt; endl;&#125;int main()&#123; return 0;&#125; 另外，可以在声明函数和定义函数的同时加上 inline；也可以只在函数声明时加 inline，而定义函数时不加 inline。只要确保在调用该函数之前把 inline 的信息告知编译器即可。 工作原理： 内联函数不是在调用时发生控制转移关系，而是在编译阶段将函数体嵌入到每一个调用该函数的语句块中，编译器会将程序中出现内联函数的调用表达式用内联函数的函数体来替换。 普通函数是将程序执行转移到被调用函数所存放的内存地址，当函数执行完后，返回到执行此函数前的地方。转移操作需要保护现场，被调函数执行完后，再恢复现场，该过程需要较大的资源开销。 宏定义（define）和内联函数（inline）的区别Answer 内联函数是在编译时展开，而宏在编译预处理时展开；在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。 内联函数是真正的函数，和普通函数调用的方法一样，在调用点处直接展开，避免了函数的参数压栈操作，减少了调用的开销。而宏定义编写较为复杂，常需要增加一些括号来避免歧义。 宏定义只进行文本替换，不会对参数的类型、语句能否正常编译等进行检查。而内联函数是真正的函数，会对参数的类型、函数体内的语句编写是否正确等进行检查。 new 和 malloc 如何判断是否申请到内存？Answer malloc ：成功申请到内存，返回指向该内存的指针；分配失败，返回 NULL 指针。 new ：内存分配成功，返回该对象类型的指针；分配失败，抛出 bad_alloc 异常。 delete 实现原理？delete 和 delete[] 的区别？Answerdelete 的实现原理： 首先执行该对象所属类的析构函数； 进而通过调用 operator delete() 的标准库函数来释放所占的内存空间。 delete 和 delete [] 的区别： delete 用来释放单个对象所占的空间，只会调用一次析构函数； delete [] 用来释放数组空间，会对数组中的每个成员都调用一次析构函数。 new 和 malloc 的区别？delete 和 free 的区别？Answer在使用的时候new、delete搭配使用，malloc、free搭配使用。 malloc、free是库函数，而new、delete是关键字。new申请空间时，无需指定分配空间的大小，编译器会根据类型自行计算；malloc在申请空间时，需要确定所申请空间的大小。 new申请空间时，返回的类型是对象的指针类型，无需强制类型转换，是类型安全的操作符；malloc申请空间时，返回的是void*类型，需要进行强制类型的转换，转换为对象类型的指针。 new分配失败时，会抛出bad_alloc异常，malloc分配失败时返回空指针。 对于自定义的类型，new首先调用operator new()函数申请空间（底层通过malloc实现），然后调用构造函数进行初始化，最后返回自定义类型的指针；delete首先调用析构函数，然后调用operator delete()释放空间（底层通过free实现）。malloc、free无法进行自定义类型的对象的构造和析构。 new操作符从自由存储区上为对象动态分配内存，而malloc函数从堆上动态分配内存。（自由存储区不等于堆） malloc 的原理？malloc 的底层实现？Answermalloc的原理: 当开辟的空间小于 128K 时，调用brk()函数，通过移动_enddata来实现； 当开辟空间大于 128 K 时，调用mmap()函数，通过在虚拟地址空间中开辟一块内存空间来实现。 malloc的底层实现： brk()函数实现原理：向高地址的方向移动指向数据段的高地址的指针_enddata。 mmap内存映射原理： 进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域； 调用内核空间的系统调用函数mmap()，实现文件物理地址和进程虚拟地址的一一映射关系； 进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝。 struct 和 union 的区别？Answer说明：union 是联合体，struct 是结构体。区别： 联合体和结构体都是由若干个数据类型不同的数据成员组成。使用时，联合体只有一个有效的成员；而结构体所有的成员都有效。 对联合体的不同成员赋值，将会对覆盖其他成员的值，而对于结构体的对不同成员赋值时，相互不影响。 联合体的大小为其内部所有变量的最大值，按照最大类型的倍数进行分配大小；结构体分配内存的大小遵循内存对齐原则。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;using namespace std;typedef union&#123; char c[10]; char cc1; // char 1 字节，按该类型的倍数分配大小&#125; u11;typedef union&#123; char c[10]; int i; // int 4 字节，按该类型的倍数分配大小&#125; u22;typedef union&#123; char c[10]; double d; // double 8 字节，按该类型的倍数分配大小&#125; u33;typedef struct s1&#123; char c; // 1 字节 double d; // 1（char）+ 7（内存对齐）+ 8（double）= 16 字节&#125; s11;typedef struct s2&#123; char c; // 1 字节 char cc; // 1（char）+ 1（char）= 2 字节 double d; // 2 + 6（内存对齐）+ 8（double）= 16 字节&#125; s22;typedef struct s3&#123; char c; // 1 字节 double d; // 1（char）+ 7（内存对齐）+ 8（double）= 16 字节 char cc; // 16 + 1（char）+ 7（内存对齐）= 24 字节&#125; s33;int main()&#123; cout &lt;&lt; sizeof(u11) &lt;&lt; endl; // 10 cout &lt;&lt; sizeof(u22) &lt;&lt; endl; // 12 cout &lt;&lt; sizeof(u33) &lt;&lt; endl; // 16 cout &lt;&lt; sizeof(s11) &lt;&lt; endl; // 16 cout &lt;&lt; sizeof(s22) &lt;&lt; endl; // 16 cout &lt;&lt; sizeof(s33) &lt;&lt; endl; // 24 cout &lt;&lt; sizeof(int) &lt;&lt; endl; // 4 cout &lt;&lt; sizeof(double) &lt;&lt; endl; // 8 return 0;&#125; class 和 struct 的异同？Answer struct和class都可以自定义数据类型，也支持继承操作。 struct中默认的访问级别是public，默认的继承级别也是public；class中默认的访问级别是private，默认的继承级别也是private。 当class继承struct或者struct继承class时，默认的继承级别取决于class或struct本身，class（private 继承），struct（public 继承），即取决于派生类的默认继承级别。123struct A&#123;&#125;；class B : A&#123;&#125;; // private 继承 struct C : B&#123;&#125;； // public 继承 举例：12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;using namespace std;class A&#123;public: void funA()&#123; cout &lt;&lt; &quot;class A&quot; &lt;&lt; endl; &#125;&#125;;struct B: A&#123; // 由于 B 是 struct，A 的默认继承级别为 publicpublic: void funB()&#123; cout &lt;&lt; &quot;class B&quot; &lt;&lt; endl; &#125;&#125;;class C: B&#123; // 由于 C 是 class，B 的默认继承级别为 private，所以无法访问基类 B 中的 printB 函数&#125;;int main()&#123; A ex1; ex1.funA(); // class A B ex2; ex2.funA(); // class A ex2.funB(); // class B C ex3; ex3.funB(); // error: &#x27;B&#x27; is not an accessible base of &#x27;C&#x27;. return 0;&#125; volatile 的作用？是否具有原子性，对编译器有什么影响？Answervolatile的作用：当对象的值可能在程序的控制或检测之外被改变时，应该将该对象声明为 violatile，告知编译器不应对这样的对象进行优化。volatile不具有原子性。volatile对编译器的影响：使用该关键字后，编译器不会对相应的对象进行优化，即不会将变量从内存缓存到寄存器中，防止多个线程有可能使用内存中的变量，有可能使用寄存器中的变量，从而导致程序错误。 什么情况下一定要用 volatile， 能否和 const 一起使用？Answer使用volatile关键字的场景： 当多个线程都会用到某一变量，并且该变量的值有可能发生改变时，需要用volatile关键字对该变量进行修饰； 中断服务程序中访问的变量或并行设备的硬件寄存器的变量，最好用volatile关键字修饰。 volatile关键字和const关键字可以同时使用，某种类型可以既是volatile又是const，同时具有二者的属性。 返回函数中静态变量的地址会发生什么？Answer123456789101112131415161718#include &lt;iostream&gt;using namespace std;int * fun(int tmp)&#123; static int var = 10; var *= tmp; return &amp;var;&#125;int main() &#123; cout &lt;&lt; *fun(5) &lt;&lt; endl; return 0;&#125;/*运行结果：50*/ 说明：上述代码中在函数fun中定义了静态局部变量var，使得离开该函数的作用域后，该变量不会销毁，返回到主函数中，该变量依然存在，从而使程序得到正确的运行结果。但是，该静态局部变量直到程序运行结束后才销毁，浪费内存空间。 extern C 的作用？Answer当 C++ 程序 需要调用 C 语言编写的函数，C++ 使用链接指示，即extern &quot;C&quot;指出任意非 C++ 函数所用的语言。 举例：1234// 可能出现在 C++ 头文件&lt;cstring&gt;中的链接指示extern &quot;C&quot;&#123; int strcmp(const char*, const char*);&#125; sizeof(1==1) 在 C 和 C++ 中分别是什么结果？AnswerC 语言代码：12345678910#include&lt;stdio.h&gt;void main()&#123; printf(&quot;%d\\n&quot;, sizeof(1==1));&#125;/*运行结果：4*/C++ 代码：1234567891011#include &lt;iostream&gt;using namespace std;int main() &#123; cout &lt;&lt; sizeof(1==1) &lt;&lt; endl; return 0;&#125;/*1*/ memmove函数的底层原理？Answer12345678910111213141516171819202122232425262728293031void *memcpy(void *dst, const void *src, size_t size)&#123; char *psrc; char *pdst; if (NULL == dst || NULL == src) &#123; return NULL; &#125; if ((src &lt; dst) &amp;&amp; (char *)src + size &gt; (char *)dst) // 出现地址重叠的情况，自后向前拷贝 &#123; psrc = (char *)src + size - 1; pdst = (char *)dst + size - 1; while (size--) &#123; *pdst-- = *psrc--; &#125; &#125; else &#123; psrc = (char *)src; pdst = (char *)dst; while (size--) &#123; *pdst++ = *psrc++; &#125; &#125; return dst;&#125; strcpy 函数有什么缺陷？Answerstrcpy 函数的缺陷：strcpy 函数不检查目的缓冲区的大小边界，而是将源字符串逐一的全部赋值给目的字符串地址起始的一块连续的内存空间，同时加上字符串终止符，会导致其他变量被覆盖。12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main()&#123; int var = 0x11112222; char arr[10]; cout &lt;&lt; &quot;Address : var &quot; &lt;&lt; &amp;var &lt;&lt; endl; cout &lt;&lt; &quot;Address : arr &quot; &lt;&lt; &amp;arr &lt;&lt; endl; strcpy(arr, &quot;hello world!&quot;); cout &lt;&lt; &quot;var:&quot; &lt;&lt; hex &lt;&lt; var &lt;&lt; endl; // 将变量 var 以 16 进制输出 cout &lt;&lt; &quot;arr:&quot; &lt;&lt; arr &lt;&lt; endl; return 0;&#125;/*Address : var 0x23fe4cAddress : arr 0x23fe42var:11002164arr:hello world!*/说明：从上述代码中可以看出，变量var的后六位被字符串&quot;hello world!&quot;的&quot;d!\\0&quot;这三个字符改变，这三个字符对应的 ASCII 码的十六进制为：\\0(0x00)，!(0x21)，d(0x64)。 原因：变量arr只分配的 10 个内存空间，通过上述程序中的地址可以看出arr和var在内存中是连续存放的，但是在调用strcpy函数进行拷贝时，源字符串&quot;hello world!&quot;所占的内存空间为 13，因此在拷贝的过程中会占用var的内存空间，导致var的后六位被覆盖。 auto 类型推导的原理Answerauto类型推导的原理： 编译器根据初始值来推算变量的类型，要求用auto定义变量时必须有初始值。编译器推断出来的auto类型有时和初始值类型并不完全一样，编译器会适当改变结果类型使其更符合初始化规则。 什么是虚函数？什么是纯虚函数？Answer虚函数：被 virtual 关键字修饰的成员函数，就是虚函数。 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;class A&#123;public: virtual void v_fun() // 虚函数 &#123; cout &lt;&lt; &quot;A::v_fun()&quot; &lt;&lt; endl; &#125;&#125;;class B : public A&#123;public: void v_fun() &#123; cout &lt;&lt; &quot;B::v_fun()&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; A *p = new B(); p-&gt;v_fun(); // B::v_fun() return 0;&#125; 纯虚函数： 纯虚函数在类中声明时，加上=0； 含有纯虚函数的类称为抽象类（只要含有纯虚函数这个类就是抽象类），类中只有接口，没有具体的实现方法； 继承纯虚函数的派生类，如果没有完全实现基类纯虚函数，依然是抽象类，不能实例化对象。 说明： 抽象类对象不能作为函数的参数，不能创建对象，不能作为函数返回类型； 可以声明抽象类指针，可以声明抽象类的引用； 子类必须继承父类的纯虚函数，并全部实现后，才能创建子类的对象。 虚函数和纯虚函数的区别？Answer 虚函数和纯虚函数可以出现在同一个类中，该类称为抽象基类。（含有纯虚函数的类称为抽象基类） 使用方式不同：虚函数可以直接使用，纯虚函数必须在派生类中实现后才能使用； 定义形式不同：虚函数在定义时在普通函数的基础上加上 virtual 关键字，纯虚函数定义时除了加上virtual 关键字还需要加上=0; 纯虚函数必须实现，否则编译器会报错； 对于实现纯虚函数的派生类，该纯虚函数在派生类中被称为虚函数，虚函数和纯虚函数都可以在派生类中重写； 析构函数最好定义为虚函数，特别是对于含有继承关系的类；析构函数可以定义为纯虚函数，此时，其所在的类为抽象基类，不能创建实例化对象。 虚函数的实现机制Answer虚函数通过虚函数表来实现。虚函数的地址保存在虚函数表中，在类的对象所在的内存空间中，保存了指向虚函数表的指针（称为“虚表指针”），通过虚表指针可以找到类对应的虚函数表。虚函数表解决了基类和派生类的继承问题和类中成员函数的覆盖问题，当用基类的指针来操作一个派生类的时候，这张虚函数表就指明了实际应该调用的函数。 虚函数表相关知识点： 虚函数表存放的内容：类的虚函数的地址。 虚函数表建立的时间：编译阶段，即程序的编译过程中会将虚函数的地址放在虚函数表中。 虚函数表保存的位置：常量区。 虚表指针保存的位置：虚表指针存放在对象的内存空间中最前面的位置，这是为了保证正确取到虚函数的偏移量。 虚函数表和类绑定，虚表指针和对象绑定。即类的不同的对象的虚函数表是一样的，但是每个对象都有自己的虚表指针，来指向类的虚函数表。 实例 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;class Base&#123;public: virtual void B_fun1() &#123; cout &lt;&lt; &quot;Base::B_fun1()&quot; &lt;&lt; endl; &#125; virtual void B_fun2() &#123; cout &lt;&lt; &quot;Base::B_fun2()&quot; &lt;&lt; endl; &#125; virtual void B_fun3() &#123; cout &lt;&lt; &quot;Base::B_fun3()&quot; &lt;&lt; endl; &#125;&#125;;class Derive : public Base&#123;public: virtual void D_fun1() &#123; cout &lt;&lt; &quot;Derive::D_fun1()&quot; &lt;&lt; endl; &#125; virtual void D_fun2() &#123; cout &lt;&lt; &quot;Derive::D_fun2()&quot; &lt;&lt; endl; &#125; virtual void D_fun3() &#123; cout &lt;&lt; &quot;Derive::D_fun3()&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; Base *p = new Derive(); p-&gt;B_fun1(); // Base::B_fun1() return 0;&#125; 基类和派生类的继承关系：基类的虚函数表：派生类的虚函数表：主函数中基类的指针p指向了派生类的对象，当调用函数B_fun1()时，通过派生类的虚函数表找到该函数的地址，从而完成调用。 单继承和多继承的虚函数表结构Answer编译器处理虚函数表： 编译器将虚函数表的指针放在类的实例对象的内存空间中，该对象调用该类的虚函数时，通过指针找到虚函数表，根据虚函数表中存放的虚函数的地址找到对应的虚函数。 如果派生类没有重新定义基类的虚函数 A，则派生类的虚函数表中保存的是基类的虚函数 A 的地址，也就是说基类和派生类的虚函数 A 的地址是一样的。 如果派生类重写了基类的某个虚函数 B，则派生的虚函数表中保存的是重写后的虚函数 B 的地址，也就是说虚函数 B 有两个版本，分别存放在基类和派生类的虚函数表中。 如果派生类重新定义了新的虚函数 C，派生类的虚函数表保存新的虚函数 C 的地址。 单继承无虚函数覆盖的情况：123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;class Base&#123;public: virtual void B_fun1() &#123; cout &lt;&lt; &quot;Base::B_fun1()&quot; &lt;&lt; endl; &#125; virtual void B_fun2() &#123; cout &lt;&lt; &quot;Base::B_fun2()&quot; &lt;&lt; endl; &#125; virtual void B_fun3() &#123; cout &lt;&lt; &quot;Base::B_fun3()&quot; &lt;&lt; endl; &#125;&#125;;class Derive : public Base&#123;public: virtual void D_fun1() &#123; cout &lt;&lt; &quot;Derive::D_fun1()&quot; &lt;&lt; endl; &#125; virtual void D_fun2() &#123; cout &lt;&lt; &quot;Derive::D_fun2()&quot; &lt;&lt; endl; &#125; virtual void D_fun3() &#123; cout &lt;&lt; &quot;Derive::D_fun3()&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; Base *p = new Derive(); p-&gt;B_fun1(); // Base::B_fun1() return 0;&#125; 基类和派生类的继承关系：基类的虚函数表：派生类的虚函数表： 单继承有虚函数覆盖的情况：123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;class Base&#123;public: virtual void fun1() &#123; cout &lt;&lt; &quot;Base::fun1()&quot; &lt;&lt; endl; &#125; virtual void B_fun2() &#123; cout &lt;&lt; &quot;Base::B_fun2()&quot; &lt;&lt; endl; &#125; virtual void B_fun3() &#123; cout &lt;&lt; &quot;Base::B_fun3()&quot; &lt;&lt; endl; &#125;&#125;;class Derive : public Base&#123;public: virtual void fun1() &#123; cout &lt;&lt; &quot;Derive::fun1()&quot; &lt;&lt; endl; &#125; virtual void D_fun2() &#123; cout &lt;&lt; &quot;Derive::D_fun2()&quot; &lt;&lt; endl; &#125; virtual void D_fun3() &#123; cout &lt;&lt; &quot;Derive::D_fun3()&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; Base *p = new Derive(); p-&gt;fun1(); // Derive::fun1() return 0;&#125; 派生类的虚函数表： 多继承无虚函数覆盖的情况：1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;class Base1&#123;public: virtual void B1_fun1() &#123; cout &lt;&lt; &quot;Base1::B1_fun1()&quot; &lt;&lt; endl; &#125; virtual void B1_fun2() &#123; cout &lt;&lt; &quot;Base1::B1_fun2()&quot; &lt;&lt; endl; &#125; virtual void B1_fun3() &#123; cout &lt;&lt; &quot;Base1::B1_fun3()&quot; &lt;&lt; endl; &#125;&#125;;class Base2&#123;public: virtual void B2_fun1() &#123; cout &lt;&lt; &quot;Base2::B2_fun1()&quot; &lt;&lt; endl; &#125; virtual void B2_fun2() &#123; cout &lt;&lt; &quot;Base2::B2_fun2()&quot; &lt;&lt; endl; &#125; virtual void B2_fun3() &#123; cout &lt;&lt; &quot;Base2::B2_fun3()&quot; &lt;&lt; endl; &#125;&#125;;class Base3&#123;public: virtual void B3_fun1() &#123; cout &lt;&lt; &quot;Base3::B3_fun1()&quot; &lt;&lt; endl; &#125; virtual void B3_fun2() &#123; cout &lt;&lt; &quot;Base3::B3_fun2()&quot; &lt;&lt; endl; &#125; virtual void B3_fun3() &#123; cout &lt;&lt; &quot;Base3::B3_fun3()&quot; &lt;&lt; endl; &#125;&#125;;class Derive : public Base1, public Base2, public Base3&#123;public: virtual void D_fun1() &#123; cout &lt;&lt; &quot;Derive::D_fun1()&quot; &lt;&lt; endl; &#125; virtual void D_fun2() &#123; cout &lt;&lt; &quot;Derive::D_fun2()&quot; &lt;&lt; endl; &#125; virtual void D_fun3() &#123; cout &lt;&lt; &quot;Derive::D_fun3()&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; Base1 *p = new Derive(); p-&gt;B1_fun1(); // Base1::B1_fun1() return 0;&#125; 基类和派生类的关系：派生类的虚函数表：（基类的顺序和声明的顺序一致） 多继承有虚函数覆盖的情况：123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;class Base1&#123;public: virtual void fun1() &#123; cout &lt;&lt; &quot;Base1::fun1()&quot; &lt;&lt; endl; &#125; virtual void B1_fun2() &#123; cout &lt;&lt; &quot;Base1::B1_fun2()&quot; &lt;&lt; endl; &#125; virtual void B1_fun3() &#123; cout &lt;&lt; &quot;Base1::B1_fun3()&quot; &lt;&lt; endl; &#125;&#125;;class Base2&#123;public: virtual void fun1() &#123; cout &lt;&lt; &quot;Base2::fun1()&quot; &lt;&lt; endl; &#125; virtual void B2_fun2() &#123; cout &lt;&lt; &quot;Base2::B2_fun2()&quot; &lt;&lt; endl; &#125; virtual void B2_fun3() &#123; cout &lt;&lt; &quot;Base2::B2_fun3()&quot; &lt;&lt; endl; &#125;&#125;;class Base3&#123;public: virtual void fun1() &#123; cout &lt;&lt; &quot;Base3::fun1()&quot; &lt;&lt; endl; &#125; virtual void B3_fun2() &#123; cout &lt;&lt; &quot;Base3::B3_fun2()&quot; &lt;&lt; endl; &#125; virtual void B3_fun3() &#123; cout &lt;&lt; &quot;Base3::B3_fun3()&quot; &lt;&lt; endl; &#125;&#125;;class Derive : public Base1, public Base2, public Base3&#123;public: virtual void fun1() &#123; cout &lt;&lt; &quot;Derive::fun1()&quot; &lt;&lt; endl; &#125; virtual void D_fun2() &#123; cout &lt;&lt; &quot;Derive::D_fun2()&quot; &lt;&lt; endl; &#125; virtual void D_fun3() &#123; cout &lt;&lt; &quot;Derive::D_fun3()&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; Base1 *p1 = new Derive(); Base2 *p2 = new Derive(); Base3 *p3 = new Derive(); p1-&gt;fun1(); // Derive::fun1() p2-&gt;fun1(); // Derive::fun1() p3-&gt;fun1(); // Derive::fun1() return 0;&#125; 基类和派生类的关系：派生类的虚函数表： 如何禁止构造函数的使用？Answer为类的构造函数增加= delete修饰符，可以达到虽然声明了构造函数但禁止使用的目的。 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;class A &#123;public: int var1, var2; A()&#123; var1 = 10; var2 = 20; &#125; A(int tmp1, int tmp2) = delete;&#125;;int main()&#123; A ex1; A ex2(12,13); // error: use of deleted function &#x27;A::A(int, int)&#x27; return 0;&#125; 什么是类的默认构造函数？Answer默认构造函数：未提供任何实参，来控制默认初始化过程的构造函数称为默认构造函数。 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;class A&#123;public: A()&#123; // 类的默认构造函数 var = 10; c = &#x27;q&#x27;; &#125; int var; char c;&#125;;int main()&#123; A ex; cout &lt;&lt; ex.c &lt;&lt; endl &lt;&lt; ex.var &lt;&lt; endl; return 0;&#125;/*运行结果：q10*/ 构造函数、析构函数可不可以是虚函数？为什么？Answer构造函数一般不定义为虚函数，原因： 从存储空间的角度考虑：构造函数是在实例化对象的时候进行调用，如果此时将构造函数定义成虚函数，需要通过访问该对象所在的内存空间才能进行虚函数的调用（因为需要通过指向虚函数表的指针调用虚函数表，虽然虚函数表在编译时就有了，但是没有虚函数的指针，虚函数的指针只有在创建了对象才有），但是此时该对象还未创建，便无法进行虚函数的调用。所以构造函数不能定义成虚函数。 从使用的角度考虑：虚函数是基类的指针指向派生类的对象时，通过该指针实现对派生类的虚函数的调用，构造函数是在创建对象时自动调用的。 从实现上考虑：虚函数表是在创建对象之后才有的，因此不能定义成虚函数。 从类型上考虑：在创建对象时需要明确其类型 析构函数一般定义成虚函数，原因： 析构函数定义成虚函数是为了防止内存泄漏，因为当基类的指针或者引用指向或绑定到派生类的对象时，如果未将基类的析构函数定义成虚函数，会调用基类的析构函数，那么只能将基类的成员所占的空间释放掉，派生类中特有的就会无法释放内存空间导致内存泄漏。 如何避免拷贝？Answer方法一：用=delete 方法二：将类的拷贝构造函数和赋值构造函数声明为私有 private，但对于类的成员函数和友元函数依然可以调用，达不到完全禁止类的对象被拷贝的目的，而且程序会出现错误，因为未对函数进行定义。 解决方法：声明一个基类，具体做法如下。 定义一个基类，将其中的拷贝构造函数和赋值构造函数声明为私有 private 派生类以私有 private 的方式继承基类12345678910111213class Uncopyable&#123;public: Uncopyable() &#123;&#125; ~Uncopyable() &#123;&#125;private: Uncopyable(const Uncopyable &amp;); // 拷贝构造函数 Uncopyable &amp;operator=(const Uncopyable &amp;); // 赋值构造函数&#125;;class A : private Uncopyable // 注意继承方式&#123; &#125;; 简单解释： 能够保证，在派生类 A 的成员函数和友元函数中无法进行拷贝操作，因为无法调用基类 Uncopyable 的拷贝构造函数或赋值构造函数。同样，在类的外部也无法进行拷贝操作。 如何减少构造函数开销？Answer在构造函数中使用类初始化列表，会减少调用默认的构造函数产生的开销，具体原因可以参考本章“为什么用成员初始化列表会快些？”这个问题。 为什么用成员初始化列表会快一些？Answer说明：数据类型可分为内置类型和用户自定义类型（类类型），对于用户自定义类型，利用成员初始化列表效率高。 原因：用户自定义类型如果使用类初始化列表，直接调用该成员变量对应的构造函数即完成初始化；如果在构造函数中初始化，因为 C++ 规定，对象的成员变量的初始化动作发生在进入构造函数本体之前，那么在执行构造函数的函数体之前首先调用默认的构造函数为成员变量设初值，在进入函数体之后，调用该成员变量对应的构造函数。因此，使用列表初始化会减少调用默认的构造函数的过程，效率高。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;using namespace std;class A&#123;private: int val;public: A() &#123; cout &lt;&lt; &quot;A()&quot; &lt;&lt; endl; &#125; A(int tmp) &#123; val = tmp; cout &lt;&lt; &quot;A(int &quot; &lt;&lt; val &lt;&lt; &quot;)&quot; &lt;&lt; endl; &#125;&#125;;class Test1&#123;private: A ex;public: Test1() : ex(1) // 成员列表初始化方式 &#123; &#125;&#125;;class Test2&#123;private: A ex;public: Test2() // 函数体中赋值的方式 &#123; ex = A(2); &#125;&#125;;int main()&#123; Test1 ex1; cout &lt;&lt; endl; Test2 ex2; return 0;&#125;/*运行结果：A(int 1)A()A(int 2)*/ 说明： 从程序运行结果可以看出，使用成员列表初始化的方式会省去调用默认的构造函数的过程。 多重继承时会出现什么状况？如何解决？Answer多重继承（多继承）：是指从多个直接基类中产生派生类。多重继承容易出现的问题：命名冲突和数据冗余问题。 举例: 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;// 间接基类class Base1&#123;public: int var1;&#125;;// 直接基类class Base2 : public Base1&#123;public: int var2;&#125;;// 直接基类class Base3 : public Base1&#123;public: int var3;&#125;;// 派生类class Derive : public Base2, public Base3&#123;public: void set_var1(int tmp) &#123; var1 = tmp; &#125; // error: reference to &#x27;var1&#x27; is ambiguous. 命名冲突 void set_var2(int tmp) &#123; var2 = tmp; &#125; void set_var3(int tmp) &#123; var3 = tmp; &#125; void set_var4(int tmp) &#123; var4 = tmp; &#125;private: int var4;&#125;;int main()&#123; Derive d; return 0;&#125; 上述程序的继承关系如下：（菱形继承） 上述代码中存的问题： 对于派生类Derive上述代码中存在直接继承关系和间接继承关系。 直接继承：Base2 、Base3 间接继承：Base1 对于派生类中继承的的成员变量 var1 ，从继承关系来看，实际上保存了两份，一份是来自基类 Base2，一份来自基类 Base3。因此，出现了命名冲突。 解决方法 1： 声明出现冲突的成员变量来源于哪个类 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;// 间接基类class Base1&#123;public: int var1;&#125;;// 直接基类class Base2 : public Base1&#123;public: int var2;&#125;;// 直接基类class Base3 : public Base1&#123;public: int var3;&#125;;// 派生类 class Derive : public Base2, public Base3&#123;public: void set_var1(int tmp) &#123; Base2::var1 = tmp; &#125; // 这里声明成员变量来源于类 Base2，当然也可以声明来源于类 Base3 void set_var2(int tmp) &#123; var2 = tmp; &#125; void set_var3(int tmp) &#123; var3 = tmp; &#125; void set_var4(int tmp) &#123; var4 = tmp; &#125;private: int var4;&#125;;int main()&#123; Derive d; return 0;&#125; 解决方法 2：虚继承使用虚继承的目的：保证存在命名冲突的成员变量在派生类中只保留一份，即使间接基类中的成员在派生类中只保留一份。在菱形继承关系中，间接基类称为虚基类，直接基类和间接基类之间的继承关系称为虚继承。实现方式：在继承方式前面加上virtual关键字。123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;// 间接基类，即虚基类class Base1&#123;public: int var1;&#125;;// 直接基类 class Base2 : virtual public Base1 // 虚继承&#123;public: int var2;&#125;;// 直接基类 class Base3 : virtual public Base1 // 虚继承&#123;public: int var3;&#125;;// 派生类class Derive : public Base2, public Base3&#123;public: void set_var1(int tmp) &#123; var1 = tmp; &#125; void set_var2(int tmp) &#123; var2 = tmp; &#125; void set_var3(int tmp) &#123; var3 = tmp; &#125; void set_var4(int tmp) &#123; var4 = tmp; &#125;private: int var4;&#125;;int main()&#123; Derive d; return 0;&#125; 类之间的继承关系： 空类占多少字节？C++ 编译器会给一个空类自动生成哪些函数？Answer空类声明时编译器不会生成任何成员函数： 对于空类，声明编译器不会生成任何的成员函数，只会生成 1 个字节的占位符。 空类定义时编译器会生成 6 个成员函数： 当空类 A 定义对象时，sizeof(A)仍是为 1，但编译器会生成 6 个成员函数：缺省的构造函数、拷贝构造函数、析构函数、赋值运算符、两个取址运算符。 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;/*class A&#123;&#125;; 该空类的等价写法如下：*/class A&#123;public: A()&#123;&#125;; // 缺省构造函数 A(const A &amp;tmp)&#123;&#125;; // 拷贝构造函数 ~A()&#123;&#125;; // 析构函数 A &amp;operator=(const A &amp;tmp)&#123;&#125;; // 赋值运算符 A *operator&amp;() &#123; return this; &#125;; // 取址运算符 const A *operator&amp;() const &#123; return this; &#125;; // 取址运算符（const 版本）&#125;;int main()&#123; A *p = new A(); cout &lt;&lt; &quot;sizeof(A):&quot; &lt;&lt; sizeof(A) &lt;&lt; endl; // sizeof(A):1 delete p; return 0;&#125; 为什么拷贝构造函数必须为引用？Answer原因：避免拷贝构造函数无限制的递归，最终导致栈溢出。 C++ 类对象的初始化顺序Answer构造函数调用顺序： 按照派生类继承基类的顺序，即派生列表中声明的顺序，依次调用基类的构造函数； 按照派生类中成员变量的声明顺序，依次调用派生类中成员变量所属类的构造函数； 执行派生类自身的构造函数。 综上可以得出，类对象的初始化顺序：基类构造函数–&gt;派生类成员变量的构造函数–&gt;自身构造函数 注： 基类构造函数的调用顺序与派生类的派生列表中的顺序有关； 成员变量的初始化顺序与声明顺序有关； 析构顺序和构造顺序相反。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;using namespace std;class A&#123;public: A() &#123; cout &lt;&lt; &quot;A()&quot; &lt;&lt; endl; &#125; ~A() &#123; cout &lt;&lt; &quot;~A()&quot; &lt;&lt; endl; &#125;&#125;;class B&#123;public: B() &#123; cout &lt;&lt; &quot;B()&quot; &lt;&lt; endl; &#125; ~B() &#123; cout &lt;&lt; &quot;~B()&quot; &lt;&lt; endl; &#125;&#125;;class Test : public A, public B // 派生列表&#123;public: Test() &#123; cout &lt;&lt; &quot;Test()&quot; &lt;&lt; endl; &#125; ~Test() &#123; cout &lt;&lt; &quot;~Test()&quot; &lt;&lt; endl; &#125;private: B ex1; A ex2;&#125;;int main()&#123; Test ex; return 0;&#125;/*运行结果：A()B()B()A()Test()~Test()~A()~B()~B()~A()*/ 程序运行结果分析： 首先调用基类 A 和 B 的构造函数，按照派生列表 public A, public B 的顺序构造； 然后调用派生类 Test 的成员变量 ex1 和 ex2 的构造函数，按照派生类中成员变量声明的顺序构造； 最后调用派生类的构造函数； 接下来调用析构函数，和构造函数调用的顺序相反。 如何禁止一个类被实例化？Answer方法一： 在类中定义一个纯虚函数，使该类成为抽象基类，因为不能创建抽象基类的实例化对象； 方法二： 将类的构造函数声明为私有private 实例化一个对象需要哪几个阶段？Answer 分配空间 创建类对象首先要为该对象分配内存空间。不同的对象，为其分配空间的时机未必相同。全局对象、静态对象、分配在栈区域内的对象，在编译阶段进行内存分配；存储在堆空间的对象，是在运行阶段进行内存分配。 初始化 首先明确一点：初始化不同于赋值。初始化发生在赋值之前，初始化随对象的创建而进行，而赋值是在对象创建好后，为其赋上相应的值。这一点可以联想下上一个问题中提到：初始化列表先于构造函数体内的代码执行，初始化列表执行的是数据成员的初始化过程，这个可以从成员对象的构造函数被调用看的出来。 赋值 对象初始化完成后，可以对其进行赋值。对于一个类的对象，其成员变量的赋值过程发生在类的构造函数的函数体中。当执行完该函数体，也就意味着类对象的实例化过程完成了。（总结：构造函数实现了对象的初始化和赋值两个过程，对象的初始化是通过初始化列表来完成，而对象的赋值则才是通过构造函数的函数体来实现。） 注：对于拥有虚函数的类的对象，还需要给虚表指针赋值。 没有继承关系的类，分配完内存后，首先给虚表指针赋值，然后再列表初始化以及执行构造函数的函数体，即上述中的初始化和赋值操作。 有继承关系的类，分配内存之后，首先进行基类的构造过程，然后给该派生类的虚表指针赋值，最后再列表初始化以及执行构造函数的函数体，即上述中的初始化和赋值操作。 友元函数的作用及使用场景Answer作用：友元提供了不同类的成员函数之间、类的成员函数与一般函数之间进行数据共享的机制。通过友元，一个不同函数或另一个类中的成员函数可以访问类中的私有成员和保护成员。 使用场景： 普通函数定义为友元函数，使普通函数能够访问类的私有成员。 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;class A&#123; friend ostream &amp;operator&lt;&lt;(ostream &amp;_cout, const A &amp;tmp); // 声明为类的友元函数public: A(int tmp) : var(tmp) &#123; &#125;private: int var;&#125;;ostream &amp;operator&lt;&lt;(ostream &amp;_cout, const A &amp;tmp)&#123; _cout &lt;&lt; tmp.var; return _cout;&#125;int main()&#123; A ex(4); cout &lt;&lt; ex &lt;&lt; endl; // 4 return 0;&#125; 友元类：类之间共享数据。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;class A&#123; friend class B;public: A() : var(10)&#123;&#125; A(int tmp) : var(tmp) &#123;&#125; void fun() &#123; cout &lt;&lt; &quot;fun():&quot; &lt;&lt; var &lt;&lt; endl; &#125;private: int var;&#125;;class B&#123;public: B() &#123;&#125; void fun() &#123; cout &lt;&lt; &quot;fun():&quot; &lt;&lt; ex.var &lt;&lt; endl; // 访问类 A 中的私有成员 &#125;private: A ex;&#125;;int main()&#123; B ex; ex.fun(); // fun():10 return 0;&#125; 深拷贝和浅拷贝的区别Answer 深拷贝：该对象和原对象占用不同的内存空间，既拷贝存储在栈空间中的内容，又拷贝存储在堆空间中的内容。 浅拷贝：该对象和原对象占用同一块内存空间，仅拷贝类中位于栈空间中的内容 当类的成员变量中有指针变量时，最好使用深拷贝。因为当两个对象指向同一块内存空间，如果使用浅拷贝，当其中一个对象的删除后，该块内存空间就会被释放，另外一个对象指向的就是垃圾内存。 浅拷贝实例 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;class Test&#123;private: int *p;public: Test(int tmp) &#123; this-&gt;p = new int(tmp); cout &lt;&lt; &quot;Test(int tmp)&quot; &lt;&lt; endl; &#125; ~Test() &#123; if (p != NULL) &#123; delete p; &#125; cout &lt;&lt; &quot;~Test()&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; Test ex1(10); Test ex2 = ex1; return 0;&#125;/*运行结果：Test(int tmp)~Test()*/ 说明：上述代码中，类对象 ex1、ex2 实际上是指向同一块内存空间，对象析构时，ex2 先将内存释放了一次，之后 析构对象 ex1 时又将这块已经被释放过的内存再释放一次。对同一块内存空间释放了两次，会导致程序崩溃。 深拷贝实例： 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;class Test&#123;private: int *p;public: Test(int tmp) &#123; p = new int(tmp); cout &lt;&lt; &quot;Test(int tmp)&quot; &lt;&lt; endl; &#125; ~Test() &#123; if (p != NULL) &#123; delete p; &#125; cout &lt;&lt; &quot;~Test()&quot; &lt;&lt; endl; &#125; Test(const Test &amp;tmp) // 定义拷贝构造函数 &#123; p = new int(*tmp.p); cout &lt;&lt; &quot;Test(const Test &amp;tmp)&quot; &lt;&lt; endl; &#125;&#125;; 编译时多态和运行时多态的区别？Answer 编译时多态：在程序编译过程中出现，发生在模板和函数重载中（泛型编程）。 运行时多态：在程序运行过程中出现，发生在继承体系中，是指通过基类的指针或引用访问派生类中的虚函数。 编译时多态和运行时多态的区别： 时期不同：编译时多态发生在程序编译过程中，运行时多态发生在程序的运行过程中； 实现方式不同：编译时多态运用泛型编程来实现，运行时多态借助虚函数来实现。 实现一个类成员函数，要求不允许修改类的成员变量？Answer如果想达到一个类的成员函数不能修改类的成员变量，只需用 const 关键字来修饰该函数即可。 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;class A&#123;public: int var1, var2; A() &#123; var1 = 10; var2 = 20; &#125; void fun() const // 不能在 const 修饰的成员函数中修改成员变量的值，除非该成员变量用 mutable 修饰 &#123; var1 = 100; // error: assignment of member &#x27;A::var1&#x27; in read-only object &#125;&#125;;int main()&#123; A ex1; return 0;&#125; 如何让类不能被继承？Answer解决方法一：借助final关键字，用该关键字修饰的类不能被继承。 1234567891011121314151617#include &lt;iostream&gt;using namespace std;class Base final&#123;&#125;;class Derive: public Base&#123; // error: cannot derive from &#x27;final&#x27; base &#x27;Base&#x27; in derived type &#x27;Derive&#x27;&#125;;int main()&#123; Derive ex; return 0;&#125; 解决方法二：借助友元、虚继承和私有构造函数来实现123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;class Base&#123; friend T;private: Base()&#123; cout &lt;&lt; &quot;base&quot; &lt;&lt; endl; &#125; ~Base()&#123;&#125;&#125;;class B:virtual public Base&lt;B&gt;&#123; //一定注意 必须是虚继承public: B()&#123; cout &lt;&lt; &quot;B&quot; &lt;&lt; endl; &#125;&#125;;class C:public B&#123;public: C()&#123;&#125; // error: &#x27;Base&lt;T&gt;::Base() [with T = B]&#x27; is private within this context&#125;;int main()&#123; B b; return 0;&#125;;说明：在上述代码中 B 类是不能被继承的类。 具体原因： 虽然 Base 类构造函数和析构函数被声明为私有 private，在 B 类中，由于 B 是 Base 的友元，因此可以访问 Base 类构造函数，从而正常创建 B 类的对象； B 类继承 Base 类采用虚继承的方式，创建 C 类的对象时，C 类的构造函数要负责 Base 类的构造，但是 Base 类的构造函数私有化了，C 类没有权限访问。因此，无法创建 C 类的对象， B 类是不能被继承的类。 注意：在继承体系中，友元关系不能被继承，虽然 C 类继承了 B 类，B 类是 Base 类的友元，但是 C 类和 Base 类没有友元关系。 左值和右值的区别？左值引用和右值引用的区别，如何将左值转换成右值？Answer左值：可以取到地址、有名字的对象。 右值：表达式结束就不再存在的临时对象。 左值和右值的区别：左值持久，右值短暂 右值引用和左值引用的区别： 左值引用不能绑定到要转换的表达式、字面常量或返回右值的表达式。右值引用恰好相反，可以绑定到这类表达式，但不能绑定到一个左值上。 右值引用必须绑定到右值的引用，通过 &amp;&amp; 获得。右值引用只能绑定到一个将要销毁的对象上，因此可以自由地移动其资源。 std::move可以将一个左值强制转化为右值，继而可以通过右值引用使用该值，以用于移动语义。 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;void fun1(int&amp; tmp) &#123; cout &lt;&lt; &quot;fun1(int&amp; tmp):&quot; &lt;&lt; tmp &lt;&lt; endl; &#125; void fun2(int&amp;&amp; tmp) &#123; cout &lt;&lt; &quot;fun2(int&amp;&amp; tmp)&quot; &lt;&lt; tmp &lt;&lt; endl; &#125; int main() &#123; int var = 11; fun1(12); // error: cannot bind non-const lvalue reference of type &#x27;int&amp;&#x27; to an rvalue of type &#x27;int&#x27; fun1(var); fun2(1); &#125; std::move() 函数的实现原理Answerstd::move()函数原型： 12345template &lt;typename T&gt;typename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; t)&#123; return static_cast&lt;typename remove_reference&lt;T&gt;::type &amp;&amp;&gt;(t);&#125; 说明：引用折叠原理 右值传递给上述函数的形参 T&amp;&amp; 依然是右值，即 T&amp;&amp; &amp;&amp; 相当于 T&amp;&amp;。 左值传递给上述函数的形参 T&amp;&amp; 依然是左值，即 T&amp;&amp; &amp; 相当于 T&amp;。 小结：通过引用折叠原理可以知道，move()函数的形参既可以是左值也可以是右值。remove_reference具体实现：1234567891011121314151617//原始的，最通用的版本template &lt;typename T&gt; struct remove_reference&#123; typedef T type; //定义 T 的类型别名为 type&#125;; //部分版本特例化，将用于左值引用和右值引用template &lt;class T&gt; struct remove_reference&lt;T&amp;&gt; //左值引用&#123; typedef T type; &#125; template &lt;class T&gt; struct remove_reference&lt;T&amp;&amp;&gt; //右值引用&#123; typedef T type; &#125; //举例如下,下列定义的a、b、c三个变量都是int类型int i;remove_refrence&lt;decltype(42)&gt;::type a; //使用原版本，remove_refrence&lt;decltype(i)&gt;::type b; //左值引用特例版本remove_refrence&lt;decltype(std::move(i))&gt;::type b; //右值引用特例版本 举例：1nt var = 10; 转化过程： std::move(var)=&gt;std::move(int&amp;&amp; &amp;)=&gt;折叠后std::move(int&amp;) 此时：T的类型为int&amp;，typename remove_reference&lt;T&gt;::type为int，这里使用remove_reference的左值引用的特例化版本 通过static_cast将int&amp;强制转换为int&amp;&amp; 整个std::move被实例化如下1234string&amp;&amp; move(int&amp; t) &#123; return static_cast&lt;int&amp;&amp;&gt;(t); &#125;总结：std::move()实现原理： 利用引用折叠原理将右值经过 T&amp;&amp; 传递类型保持不变还是右值，而左值经过 T&amp;&amp; 变为普通的左值引用，以保证模板可以传递任意实参，且保持类型不变； 然后通过 remove_refrence 移除引用，得到具体的类型 T； 最后通过 static_cast&lt;&gt; 进行强制类型转换，返回 T&amp;&amp; 右值引用。 什么是指针？指针的大小及用法？Answer指针：指向另外一种类型的复合类型。指针的大小：在 64 位计算机中，指针占 8 个字节空间。 什么是野指针和悬空指针？Answer悬空指针：若指针指向一块内存空间，当这块内存空间被释放后，该指针依然指向这块内存空间，此时，称该指针为“悬空指针”。 举例： 123void *p = malloc(size);free(p); // 此时，p 指向的内存空间已释放， p 就是悬空指针。 野指针：“野指针”是指不确定其指向的指针，未初始化的指针为“野指针” 12void *p; // 此时 p 是“野指针”。 C++ 11 nullptr 比 NULL 优势AnswerNULL：预处理变量，是一个宏，它的值是 0，定义在头文件 中，即#define NULL 0。nullptr：C++ 11 中的关键字，是一种特殊类型的字面值，可以被转换成任意其他类型。 nullptr 的优势： 有类型，类型是 typdef decltype(nullptr) nullptr_t;，使用 nullptr 提高代码的健壮性。 函数重载：因为 NULL 本质上是 0，在函数调用过程中，若出现函数重载并且传递的实参是 NULL，可能会出现，不知和哪一个函数匹配的情况；但是传递实参 nullptr 就不会出现这种情况。 什么是数组指针？什么是指针数组？Answer 指针数组：指针数组可以说成是”指针的数组”，首先这个变量是一个数组，其次，”指针”修饰这个数组，意思是说这个数组的所有元素都是指针类型，在32位系统中，指针占四个字节。 数组指针：数组指针可以说成是”数组的指针”，首先这个变量是一个指针，其次，”数组”修饰这个指针，意思是说这个指针存放着一个数组的首地址，或者说这个指针指向一个数组的首地址。 函数指针和指针函数的区别？Answer指针函数：指针函数本质是一个函数，只不过该函数的返回值是一个指针。相对于普通函数而言，只是返回值是指针。 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;struct Type&#123; int var1; int var2;&#125;;Type * fun(int tmp1, int tmp2)&#123; Type * t = new Type(); t-&gt;var1 = tmp1; t-&gt;var2 = tmp2; return t;&#125;int main()&#123; Type *p = fun(5, 6); return 0;&#125; 函数指针：函数指针本质是一个指针变量，只不过这个指针指向一个函数。函数指针即指向函数的指针。 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;int fun1(int tmp1, int tmp2)&#123; return tmp1 * tmp2;&#125;int fun2(int tmp1, int tmp2)&#123; return tmp1 / tmp2;&#125;int main()&#123; int (*fun)(int x, int y); fun = fun1; cout &lt;&lt; fun(15, 5) &lt;&lt; endl; fun = fun2; cout &lt;&lt; fun(15, 5) &lt;&lt; endl; return 0;&#125;/*运行结果：753*/ 指针和引用的区别？Answer 指针所指向的内存空间在程序运行过程中可以改变，而引用所绑定的对象一旦绑定就不能改变。（是否可变） 指针本身在内存中占有内存空间，引用相当于变量的别名，在内存中不占内存空间。（是否占内存） 指针可以为空，但是引用必须绑定对象。（是否可为空） 指针可以有多级，但是引用只能一级。（是否能为多级） 常量指针和指针常量的区别Answer常量指针：常量指针本质上是个指针，只不过这个指针指向的对象是常量。 特点：const 的位置在指针声明运算符*的左侧。只要const位于*的左侧，无论它在类型名的左边或右边，都表示指向常量的指针。（可以这样理解*左侧表示指针指向的对象，该对象为常量，那么该指针为常量指针。）12const int * p;int const * p;注意 1：指针指向的对象不能通过这个指针来修改，也就是说常量指针可以被赋值为变量的地址，之所以叫做常量指针，是限制了通过这个指针修改变量的值。 注意 2：虽然常量指针指向的对象不能变化，可是因为常量指针本身是一个变量，因此，可以被重新赋值。 指针常量：指针常量的本质上是个常量，只不过这个常量的值是一个指针。特点：const位于指针声明操作符右侧，表明该对象本身是一个常量，*左侧表示该指针指向的类型，即以*为分界线，其左侧表示指针指向的类型，右侧表示指针本身的性质。12const int var;int * const c_p = &amp;var; 注意 1：指针常量的值是指针，这个值因为是常量，所以指针本身不能改变。 注意 2：指针的内容可以改变。 请说出const char *p、char const *p 与 char * const p的区别？Answerconst char *p和char const *p是常量指针，即指向常量的指针，char * const p是指针常量，即指针本身是常量 TIPS《C++ Primer Plus》一书中提到一种方法，从右往左读，遇到 “p” 就翻译为 “p is a”，遇到 ““ 就翻译为 “point to”。所以`const char p`可以翻译为”p is a point to char const”，也就是指向常量字符的指针。 强制类型转换有哪几种？Answer static_cast：用于数据的强制类型转换，强制将一种数据类型转换为另一种数据类型。 用于基本数据类型的转换。 用于类层次之间的基类和派生类之间指针或者引用的转换（不要求必须包含虚函数，但必须是有相互联系的类），进行上行转换（派生类的指针或引用转换成基类表示）是安全的；进行下行转换（基类的指针或引用转换成派生类表示）由于没有动态类型检查，所以是不安全的，最好用 dynamic_cast 进行下行转换。 可以将空指针转化成目标类型的空指针。 可以将任何类型的表达式转化成 void 类型 const_cast：强制去掉常量属性，不能用于去掉变量的常量性，只能用于去除指针或引用的常量性，将常量指针转化为非常量指针或者将常量引用转化为非常量引用（注意：表达式的类型和要转化的类型是相同的）。 reinterpret_cast：改变指针或引用的类型、将指针或引用转换为一个足够长度的整型、将整型转化为指针或引用类型。 dynamic_cast： 其他三种都是编译时完成的，动态类型转换是在程序运行时处理的，运行时会进行类型检查。 只能用于带有虚函数的基类或派生类的指针或者引用对象的转换，转换成功返回指向类型的指针或引用，转换失败返回 NULL；不能用于基本数据类型的转换。 在向上进行转换时，即派生类类的指针转换成基类类的指针和 static_cast 效果是一样的，（注意：这里只是改变了指针的类型，指针指向的对象的类型并未发生改变）12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;class Base&#123;&#125;;class Derive : public Base&#123;&#125;;int main()&#123; Base *p1 = new Derive(); Derive *p2 = new Derive(); //向上类型转换 p1 = dynamic_cast&lt;Base *&gt;(p2); if (p1 == NULL) &#123; cout &lt;&lt; &quot;NULL&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;NOT NULL&quot; &lt;&lt; endl; //输出 &#125; return 0;&#125; 在下行转换时，基类的指针类型转化为派生类类的指针类型，只有当要转换的指针指向的对象类型和转化以后的对象类型相同时，才会转化成功。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;class Base&#123;public: virtual void fun() &#123; cout &lt;&lt; &quot;Base::fun()&quot; &lt;&lt; endl; &#125;&#125;;class Derive : public Base&#123;public: virtual void fun() &#123; cout &lt;&lt; &quot;Derive::fun()&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; Base *p1 = new Derive(); Base *p2 = new Base(); Derive *p3 = new Derive(); //转换成功 p3 = dynamic_cast&lt;Derive *&gt;(p1); if (p3 == NULL) &#123; cout &lt;&lt; &quot;NULL&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;NOT NULL&quot; &lt;&lt; endl; // 输出 &#125; //转换失败 p3 = dynamic_cast&lt;Derive *&gt;(p2); if (p3 == NULL) &#123; cout &lt;&lt; &quot;NULL&quot; &lt;&lt; endl; // 输出 &#125; else &#123; cout &lt;&lt; &quot;NOT NULL&quot; &lt;&lt; endl; &#125; return 0;&#125; 参数传递时，值传递、引用传递、指针传递的区别？Answer参数传递的三种方式： 值传递：形参是实参的拷贝，函数对形参的所有操作不会影响实参。 指针传递：本质上是值传递，只不过拷贝的是指针的值，拷贝之后，实参和形参是不同的指针，通过指针可以间接的访问指针所指向的对象，从而可以修改它所指对象的值。 引用传递：当形参是引用类型时，我们说它对应的实参被引用传递。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;void fun1(int tmp)&#123; // 值传递 cout &lt;&lt; &amp;tmp &lt;&lt; endl;&#125;void fun2(int * tmp)&#123; // 指针传递 cout &lt;&lt; tmp &lt;&lt; endl;&#125;void fun3(int &amp;tmp)&#123; // 引用传递 cout &lt;&lt; &amp;tmp &lt;&lt; endl;&#125;int main()&#123; int var = 5; cout &lt;&lt; &quot;var 在主函数中的地址：&quot; &lt;&lt; &amp;var &lt;&lt; endl; cout &lt;&lt; &quot;var 值传递时的地址：&quot;; fun1(var); cout &lt;&lt; &quot;var 指针传递时的地址：&quot;; fun2(&amp;var); cout &lt;&lt; &quot;var 引用传递时的地址：&quot;; fun3(var); return 0;&#125;/*运行结果：var 在主函数中的地址：0x23fe4cvar 值传递时的地址：0x23fe20var 指针传递时的地址：0x23fe4cvar 引用传递时的地址：0x23fe4c*/ 说明：从上述代码的运行结果可以看出，只有在值传递时，形参和实参的地址不一样，在函数体内操作的不是变量本身。引用传递和指针传递，在函数体内操作的是变量本身。 什么是模板？如何实现？Answer模板：创建类或者函数的蓝图或者公式，分为函数模板和类模板。 实现方式：模板定义以关键字 template 开始，后跟一个模板参数列表。 模板参数列表不能为空； 模板类型参数前必须使用关键字 class 或者 typename，在模板参数列表中这两个关键字含义相同，可互换使用。1template &lt;typename T, typename U, ...&gt; 函数模板：通过定义一个函数模板，可以避免为每一种类型定义一个新函数。 对于函数模板而言，模板类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换。 函数模板实例化：当调用一个模板时，编译器用函数实参来推断模板实参，从而使用实参的类型来确定绑定到模板参数的类型12345678910111213141516171819#include&lt;iostream&gt;using namespace std;template &lt;typename T&gt;T add_fun(const T &amp; tmp1, const T &amp; tmp2)&#123; return tmp1 + tmp2;&#125;int main()&#123; int var1, var2; cin &gt;&gt; var1 &gt;&gt; var2; cout &lt;&lt; add_fun(var1, var2); double var3, var4; cin &gt;&gt; var3 &gt;&gt; var4; cout &lt;&lt; add_fun(var3, var4); return 0;&#125; 类模板：类似函数模板，类模板以关键字 template 开始，后跟模板参数列表。但是，编译器不能为类模板推断模板参数类型，需要在使用该类模板时，在模板名后面的尖括号中指明类型。123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;class Complex&#123;public: //构造函数 Complex(T a, T b) &#123; this-&gt;a = a; this-&gt;b = b; &#125; //运算符重载 Complex&lt;T&gt; operator+(Complex &amp;c) &#123; Complex&lt;T&gt; tmp(this-&gt;a + c.a, this-&gt;b + c.b); cout &lt;&lt; tmp.a &lt;&lt; &quot; &quot; &lt;&lt; tmp.b &lt;&lt; endl; return tmp; &#125;private: T a; T b;&#125;;int main()&#123; Complex&lt;int&gt; a(10, 20); Complex&lt;int&gt; b(20, 30); Complex&lt;int&gt; c = a + b; return 0;&#125; 函数模板和类模板的区别？Answer 实例化方式不同：函数模板实例化由编译程序在处理函数调用时自动完成，类模板实例化需要在程序中显式指定。 实例化的结果不同：函数模板实例化后是一个函数，类模板实例化后是一个类。 默认参数：类模板在模板参数列表中可以有默认参数。 特化：函数模板只能全特化；而类模板可以全特化，也可以偏特化。 调用方式不同：函数模板可以隐式调用，也可以显式调用；类模板只能显式调用。 什么是模板特化？为什么特化？Answer模板特化：模板参数在某种特定类型下的具体实现。分为函数模板特化和类模板特化 函数模板特化：将函数模板中的全部类型进行特例化，称为函数模板特化。 类模板特化：将类模板中的部分或全部类型进行特例化，称为类模板特化。 模板特化的原因：模板并非对任何模板实参都合适、都能实例化，某些情况下，通用模板的定义对特定类型不合适，可能会编译失败，或者得不到正确的结果。因此，当不希望使用模板版本时，可以定义类或者函数模板的一个特例化版本。 特化分为全特化和偏特化： 全特化：模板中的模板参数全部特例化。 偏特化：模板中的模板参数只确定了一部分，剩余部分需要在编译器编译时确定。 说明：要区分下函数重载与函数模板特化 定义函数模板的特化版本，本质上是接管了编译器的工作，为原函数模板定义了一个特殊实例，而不是函数重载，函数模板特化并不影响函数匹配。 实例： 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;//函数模板template &lt;class T&gt;bool compare(T t1, T t2)&#123; cout &lt;&lt; &quot;通用版本：&quot;; return t1 == t2;&#125;template &lt;&gt; //函数模板特化bool compare(char *t1, char *t2)&#123; cout &lt;&lt; &quot;特化版本：&quot;; return strcmp(t1, t2) == 0;&#125;int main(int argc, char *argv[])&#123; char arr1[] = &quot;hello&quot;; char arr2[] = &quot;abc&quot;; cout &lt;&lt; compare(123, 123) &lt;&lt; endl; cout &lt;&lt; compare(arr1, arr2) &lt;&lt; endl; return 0;&#125;/*运行结果：通用版本：1特化版本：0*/ switch 的 case 里为何不能定义变量Answerswitch 下面的这个花括号表示一块作用域，而不是每一个 case 表示一块作用域。如果在某一 case 中定义了变量，其作用域在这块花括号内，按理说在另一个 case 内可以使用该变量，但是在实际使用时，每一个 case 之间互不影响，是相对封闭的，参考如下实例。 迭代器的作用？Answer作用：在无需知道容器底层原理的情况下，遍历容器中的元素。 泛型编程如何实现？Answer泛型编程实现的基础：模板。模板是创建类或者函数的蓝图或者说公式，当时用一个 vector 这样的泛型，或者 find 这样的泛型函数时，编译时会转化为特定的类或者函数。 泛型编程涉及到的知识点较广，例如：容器、迭代器、算法等都是泛型编程的实现实例。面试者可选择自己掌握比较扎实的一方面进行展开。 容器：涉及到 STL 中的容器，例如：vector、list、map 等，可选其中熟悉底层原理的容器进行展开讲解。 迭代器：在无需知道容器底层原理的情况下，遍历容器中的元素。 模板：可参考本章节中的模板相关问题。 说说STL的基本组成部分？Answer标准模板库STL主要由六大部分组成（前三种最主要）： 容器（Container） 一种数据结构，比如list、vector和deques，以模板类的形式提供。 算法（Algorithm） 用来操作容器中的数据的模板函数。 迭代器（Iterator） 提供了访问容器中对象的方法。 仿函数（Function Object） 仿函数又称为函数对象，就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()。 适配器（Adaptor） 简单来说就是一种接口类，专门用来修改现有类的接口，提供一种新的接口；或者调用现有的函数来实现所需要的功能。主要包括三种适配器 Container Adaptor、Iterator Adaptor、Function Adaptor。 空间适配器（Allocator） 主要负责：1.对象的创建与销毁；内存的获取与释放。 容器有哪几种类型？Answer有顺序容器、关联式容器、容器适配器三种，三种类型容器特性分别如下： 顺序容器：容器并非排序的，元素的插入位置同元素的值无关。 vector：动态数组。元素在内存连续存放，随机存取任何元素都能在常数时间内完成。在尾端增删元素具有较佳的性能 deque：双向队列。元素在内存连续存放，随机存取任何元素都能在常数时间内完成（仅次于vector） 。在两端增删元素具有较佳的性能（大部分情况下是常数时间）。 list：双向链表。元素在内存不连续存放。在任何位置增删元素都能在常数时间完成。不支持随机存取。 关联式容器：元素是排序的：插入任何元素，都按相应的排序规则来确定其位置。在查找时具有非常好的性能，通常以平衡二叉树的方式实现。 set/multiset：集合。set中不允许相同元素，multiset中允许存在相同元素。 map/multimap：map根据first值对元素从小到大排序。map中不允许相同first值，multimap中允许存在相同first值。 容器适配器：封装了一些基本的容器，使之具备了新的函数功能，比如把deque封装一下变为一个具有 stack 功能的数据结构。这新得到的数据结构就叫适配器。 stack：栈。后进先出。 queue：队列。先进先出。 priority_queue：优先队列。内部维持某种有序，然后确保优先级最高（通常是最小或最大，对应小顶堆和大顶堆）的元素总是位于头部。最高优先级元素总是第一个出列。 map的实现原理Answer红黑树。红黑树是非严格平衡的二叉搜索树，具有自动排序的功能，因此map内部所有元素都是有序的。 hashtable（散列表、哈希表）的实现原理Answerhashtable采用了函数映射的思想记录的存储位置与记录的关键字关联起来，从而能够很快速地进行查找。 deque实现原理Answer双向队列。 list实现原理Answer双向链表。 STL各个容器查找的时间复杂度是多少？Answer 容器 原理 插入 查看 删除 vector 采用一维数组实现，元素在内存连续存放 O(N) O(1) O(N) deque 采用双向队列实现，元素在内存连续存放 O(N) O(1) O(N) list 采用双向链表实现，元素在内存不连续存放，并且存放在堆中 O(1) O(N) O(1) map、set、multimap、multiset 采用红黑树实现，红黑树是平衡二叉树的一种 O(logN) O(logN) O(logN) unordered_map、unordered_set、unordered_multimap、unordered_multiset 采用哈希表实现 O(1)，最坏情况O(N) O(1)，最坏情况O(N) O(1)，最坏情况O(N) 说一下STL中迭代器的作用，有指针为何还要迭代器？Answer迭代器的作用： 用于指向顺序容器和关联容器中的元素 通过迭代器可以读取它指向的元素 通过非const迭代器还可以修改其指向的元素 迭代器和指针的区别： 迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，重载了指针的一 些操作符，—&gt;、++、—等。迭代器封装了指针，是一个“可遍历STL( Standard Template Library)容器内全部或部分元素”的对象，本质是封装了原生指针，是指针概念的一种提升，提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的 ++，—等操作。 迭代器返回的是对象引用而不是对象的值，所以cout只能输出迭代器使用取值后的值而不能直接输出其自身。 迭代器的功能分类？Answer常用的迭代器按功能强弱分为输入、输出、正向、双向、随机访问五种。 输入迭代器（input iterator） 只读，在每个被遍历的位置上只能读取一次，只能向前移动。 支持的操作符有：*p、++p、p++、p != q 和 p == q 输出迭代器（output iterator） 只写，在每个被遍历的位置上只能解析一次，只能向前移动。 支持的操作符有：*p、++p、p++、p != q 和 p == q 正向迭代器（forward iterator） 输入和输出迭代器的结合，可多次读写，但是也只能向前移动。 支持的操作符有：*p、++p、p++、p != q 和 p == q 双向迭代器（bidirectional iterator） 双向迭代器具有正向迭代器的全部功能，并且能向后移动。 在正向迭代器的基础上，额外支持--p 和 p-- 随机存取迭代器（random access iterator） 功能如其名，在双线迭代器的功能上，支持随机访问序列的任意值。指针就是这样一个迭代器。 支持以上所有操作 只有顺序容器和关联容器支持迭代器遍历，各容器支持的迭代器类别如下表： 容器 支持迭代器类别 vector 随机访问 deque 随机访问 list 双向 set 双向 multiset 双向 map 双向 multimap 双向 stack 不支持 queue 不支持 priority_queue 不支持 操作系统进程和线程有什么区别？Answer 进程（Process）是对运行时程序的封装，是系统进行资源分配和调度的基本单位；线程（Thread）是进程的子任务，是CPU调度和分派的基本单位； 线程依赖于进程而存在，一个进程至少有一个线程； 进程有自己的独立地址空间，线程共享所属进程的地址空间； 进程是拥有系统资源的一个独立单位，而线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，和其他线程共享本进程的相关资源如内存、I/O、CPU等； 在进程切换时，涉及到整个当前进程CPU环境的保存环境的设置以及新被调度运行的CPU环境的设置，而线程切换只需保存和设置少量的寄存器的内容，并不涉及存储器管理方面的操作，可见，进程切换的开销远大于线程切换的开销； 线程之间的通信更方便，同一进程下的线程共享全局变量等数据，而进程之间的通信需要以进程间通信(IPC)的方式进行； 多线程程序只要有一个线程崩溃，整个程序就崩溃了，但多进程程序中一个进程崩溃并不会对其它进程造成影响，因为进程有自己的独立地址空间，因此多进程更加健壮 什么是协程？Answer协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。 协程多与线程进行比较 一个线程可以拥有多个协程，一个进程也可以单独拥有多个协程 线程进程都是同步机制，而协程则是异步 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态 进程的异常控制流：陷阱、中断、异常和信号Answer 陷阱是有意造成的“异常”，是执行一条指令的结果。陷阱是同步的。陷阱的主要作用是实现系统调用。比如，进程可以执行syscall n指令向内核请求服务。当进程执行这条指令后，会中断当前的控制流，陷入到内核态，执行相应的系统调用。内核的处理程序在执行结束后，会将结果返回给进程，同时退回到用户态。进程此时继续执行下一条指令。 中断由处理器外部的硬件产生，不是执行某条指令的结果，也无法预测发生时机。由于中断独立于当前执行的程序，因此中断是异步事件。中断包括 I/O 设备发出的 I/O 中断、各种定时器引起的时钟中断、调试程序中设置的断点等引起的调试中断等。 异常是一种错误情况，是执行当前指令的结果，可能被错误处理程序修正，也可能直接终止应用程序。异常是同步的。这里特指因为执行当前指令而产生的错误情况，比如除法异常、缺页异常等。有些书上为了区分，也将这类“异常”称为“故障”。 信号是一种更高层的软件形式的异常，同样会中断进程的控制流，可以由进程进行处理。一个信号代表了一个消息。信号的作用是用来通知进程发生了某种系统事件。 同一进程中的线程可以共享哪些数据？Answer 进程的代码段 进程的公有数据（全局变量、静态变量…） 进程打开的文件描述符 文件描述符是一个简单的整数，用以标明每一个被进程所打开的文件和socket。第一个打开的文件是0，第二个是1，依此类推。 进程的当前目录 信号处理器/信号处理函数：对收到的信号的处理方式 进程ID与进程组ID 线程独占哪些资源？Answer 线程ID 一组寄存器的值 线程自身的栈（堆是共享的） 错误返回码：线程可能会产生不同的错误返回码，一个线程的错误返回码不应该被其它线程修改； 信号掩码/信号屏蔽字(Signal mask)：表示是否屏蔽/阻塞相应的信号（SIGKILL,SIGSTOP除外） 进程间通信有哪些方式？Answer 管道(Pipe) 管道是半双工[2]的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道；一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据；只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程) 命名管道 有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，以有名管道的文件形式存在于文件系统中，这样，即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信， 消息队列 消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。 与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺。 信号(Signal) 信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。 Linux系统中常用信号： SIGHUP：用户从终端注销，所有已启动进程都将收到该进程。系统缺省状态下对该信号的处理是终止进程。 SIGINT：程序终止信号。 SIGQUIT：程序退出信号。 SIGBUS：进程访问非法地址。 SIGFPE：运算中出现致命错误，如除零操作、数据溢出等。 SIGKILL：用户终止进程执行信号。shell下执行kill -9发送该信号。 SIGTERM：结束进程信号。shell下执行kill 进程pid发送该信号。 SIGALRM：定时器信号。 共享内存 使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。 信号量(Semaphore) 初始化操作、P（通过）操作、V（释放）操作；P操作：信号量-1，检测是否小于0，小于则进程进入阻塞状态；V操作：信号量+1，若小于等于0，则从队列中唤醒一个等待的进程进入就绪态 信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。 为了获得共享资源，进程需要执行下列操作：（1）创建一个信号量：这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0。（2）等待一个信号量：该操作会测试这个信号量的值，如果小于0，就阻塞。也称为P操作。（3）挂出一个信号量：该操作将信号量的值加1，也称为V操作。 套接字(Socket) 套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。 进程同步问题Answer 进程的同步[3]是目的，进程间通信是实现进程同步的手段 管程 Monitor 管程将共享变量以及对这些共享变量的操作封装起来，形成一个具有一定接口的功能模块，这样只能通过管程提供的某个过程才能访问管程中的资源。进程只能互斥地使用管程，使用完之后必须释放管程并唤醒入口等待队列中的进程。 当一个进程试图进入管程时，在入口等待队列等待。若P进程唤醒了Q进程，则Q进程先执行，P在紧急等待队列中等待。（HOARE管程） wait操作：执行wait操作的进程进入条件变量链末尾，唤醒紧急等待队列或者入口队列中的进程； signal操作：唤醒条件变量链中的进程，自己进入紧急等待队列，若条件变量链为空，则继续执行。（HOARE管程） MESA管程：将HOARE中的signal换成了notify（或者broadcast通知所有满足条件的），进行通知而不是立马交换管程的使用权，在合适的时候，条件队列首位的进程可以进入，进入之前必须用while检查条件是否合适。优点：没有额外的进程切换 线程同步有哪些方式？Answer为什么需要线程同步：线程有时候会和其他线程共享一些资源，比如内存、数据库等。当多个线程同时读写同一份共享资源的时候，可能会发生冲突。因此需要线程的同步，多个线程按顺序访问资源。 互斥量 Mutex：互斥量是内核对象，只有拥有互斥对象的线程才有访问互斥资源的权限。因为互斥对象只有一个，所以可以保证互斥资源不会被多个线程同时访问；当前拥有互斥对象的线程处理完任务后必须将互斥对象交出，以便其他线程访问该资源； 信号量 Semaphore：信号量是内核对象，它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。信号量对象保存了最大资源计数和当前可用资源计数，每增加一个线程对共享资源的访问，当前可用资源计数就减1，只要当前可用资源计数大于0，就可以发出信号量信号，如果为0，则将线程放入一个队列中等待。线程处理完共享资源后，应在离开的同时通过ReleaseSemaphore函数将当前可用资源数加1。如果信号量的取值只能为0或1，那么信号量就成为了互斥量； 事件 Event：允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。事件分为手动重置事件和自动重置事件。手动重置事件被设置为激发状态后，会唤醒所有等待的线程，而且一直保持为激发状态，直到程序重新把它设置为未激发状态。自动重置事件被设置为激发状态后，会唤醒一个等待中的线程，然后自动恢复为未激发状态。 临界区 Critical Section：任意时刻只允许一个线程对临界资源进行访问。拥有临界区对象的线程可以访问该临界资源，其它试图访问该资源的线程将被挂起，直到临界区对象被释放。 互斥量和临界区有什么区别？Answer互斥量是可以命名的，可以用于不同进程之间的同步；而临界区只能用于同一进程中线程的同步。创建互斥量需要的资源更多，因此临界区的优势是速度快，节省资源。 生产者-消费者问题Answer 问题描述：使用一个缓冲区来存放数据，只有缓冲区没有满，生产者才可以写入数据；只有缓冲区不为空，消费者才可以读出数据 代码实现（C++版）： 单生产者-单消费者 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;unistd.h&gt;#include &lt;condition_variable&gt;#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;queue&gt;struct resource &#123; std::queue&lt;int&gt; buf; // 缓冲区 const int bufCapacity = 10; const int productsNum = 20; int bufSize = 0; // 现在缓存区里有多少产品 std::mutex mtx; // 互斥量，同一时间只能读或写 std::condition_variable able_to_write; // 缓存区没满时，可以写 std::condition_variable able_to_read; // 缓存区不为空时，可以读&#125; res; // 产品库全局变量, 生产者和消费者操作该变量.void produce(int item) &#123; std::unique_lock&lt;std::mutex&gt; lock(res.mtx); while (res.bufSize &gt;= res.bufCapacity) &#123; std::cout &lt;&lt; &quot;缓存区已满，等待消费...&quot; &lt;&lt; std::endl; res.able_to_write.wait(lock); // 等待缓存区空位 &#125; std::cout &lt;&lt; &quot;正在生产产品 &quot; &lt;&lt; item &lt;&lt; std::endl; res.buf.emplace(item); ++res.bufSize; res.able_to_read.notify_all();&#125;void consume() &#123; std::unique_lock&lt;std::mutex&gt; lock(res.mtx); while (res.bufSize &lt;= 0) &#123; std::cout &lt;&lt; &quot;缓存区为空，等待生产...&quot; &lt;&lt; std::endl; res.able_to_read.wait(lock); // 等待缓存区空位 &#125; int item = res.buf.front(); std::cout &lt;&lt; &quot;正在消费产品 &quot; &lt;&lt; item &lt;&lt; std::endl; res.buf.pop(); --res.bufSize; res.able_to_write.notify_all();&#125;void Producer() &#123; // 生产者 for (int i = 1; i &lt;= res.productsNum; ++i) &#123; produce(i); &#125;&#125;void Consumer() &#123; // 消费者 for (int i = 1; i &lt;= res.productsNum; ++i) &#123; sleep(1); consume(); &#125;&#125;int main() &#123; std::thread producer(Producer); // 创建生产者线程. std::thread consumer(Consumer); // 创建消费之线程. producer.join(); consumer.join();&#125; 什么叫临界资源和临界区？Answer 临界资源是指每次仅允许一个进程访问的资源。 每个进程中访问临界资源的那段代码称为临界区。 同步与互斥的概念？Answer 同步：多个进程因为合作而使得进程的执行有一定的先后顺序。比如某个进程需要另一个进程提供的消息，获得消息之前进入阻塞态； 互斥：多个进程在同一时刻只有一个进程能进入临界区 并发、并行、异步的区别？Answer 并发：在一个时间段中同时有多个程序在运行，但其实任一时刻，只有一个程序在CPU上运行，宏观上的并发是通过不断的切换实现的。 多线程：并发运行的一段代码。是实现异步的手段。 并行（和串行相比）：在多CPU系统中，多个程序无论宏观还是微观上都是同时执行的。 异步（和同步相比）：同步是顺序执行，异步是在等待某个资源的时候继续做自己的事。 进程有哪几种状态？Answer 就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源 运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数 阻塞状态： 进程等待某种条件，在条件满足之前无法执行 进程调度策略有哪些？Answer 批处理系统： 先来先服务 first-come first-serverd（FCFS） 按照请求的顺序进行调度。 非抢占式，开销小，无饥饿问题[4]，响应时间不确定（可能很慢）； 对短进程不利，对IO密集型进程不利。 最短作业优先 shortest job first（SJF） 按估计运行时间最短的顺序进行调度。 非抢占式，吞吐量高，开销可能较大，可能导致饥饿问题； 对短进程提供好的响应时间，对长进程不利。 最短剩余时间优先 shortest remaining time next（SRTN） 按剩余运行时间的顺序进行调度。 (最短作业优先的抢占式版本)。吞吐量高，开销可能较大，提供好的响应时间； 可能导致饥饿问题，对长进程不利。 最高响应比优先 Highest Response Ratio Next（HRRN） 按照队列中响应比的顺序进行调度。 响应比=（等待时间+要求服务时间）/要求服务时间。 既考虑作业的执行时间也考虑作业的等待时间，综合了先来先服务和最短作业优先两种算法的特点。 交互式系统： 交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。 时间片轮转 Round Robin 将所有就绪进程按 FCFS 的原则排成一个队列，用完时间片的进程排到队列最后。 抢占式（时间片用完时），开销小，无饥饿问题，为短进程提供好的响应时间； 若时间片小，进程切换频繁，吞吐量低；若时间片太长，实时性得不到保证 优先级调度算法 为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。 多级反馈队列调度算法 Multilevel Feedback Queue 设置多个就绪队列1、2、3…，优先级递减，时间片递增。只有等到优先级更高的队列为空时才会调度当前队列中的进程。如果进程用完了当前队列的时间片还未执行完，则会被移到下一队列。 抢占式（时间片用完时），开销可能较大，对IO型进程有利，可能会出现饥饿问题。 什么叫优先级反转？如何解决？Answer高优先级的进程等待被一个低优先级进程占用的资源时，就会出现优先级反转，即优先级较低的进程比优先级较高的进程先执行。此处详细解释优先级反转带来的问题：如果有一个中等优先级的进程将低优先级的进程抢占，那么此时低优先级的进程无法正常进行并在后续释放被占用的资源，导致高优先级的任务一直被挂起，直到中等优先级的进程完成后，低优先级的进程才可以继续并在后续释放占用的资源，最后高优先级的进程才可以执行。导致的问题就是高优先级的进程在中等优先级的进程调度之后。 解决方法： 优先级天花板(priority ceiling)：当任务申请某资源时，把该任务的优先级提升到可访问这个资源的所有任务中的最高优先级，这个优先级称为该资源的优先级天花板。简单易行。 优先级继承(priority inheritance)：当任务A申请共享资源S时，如果S正在被任务C使用，通过比较任务C与自身的优先级，如发现任务C的优先级小于自身的优先级，则将任务C的优先级提升到自身的优先级，任务C释放资源S后，再恢复任务C的原优先级。 什么是僵尸进程？Answer一个子进程结束后，他的父进程没有通过wait()系统调用回收他的进程描述符的信息，该进程会继续停留在系统的进程表中，占用内核资源，那么这个子进程将成为一个僵尸进程。僵尸进程是一个已经死亡的进程，但是并没有真正被销毁。它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程表中保留一个位置，记载该进程的进程ID、终止状态以及资源利用信息(CPU时间，内存使用量等等)供父进程收集，除此之外，僵尸进程不再占有任何内存空间。这个僵尸进程可能会一直留在系统中直到系统重启。 危害：占用进程号，而系统所能使用的进程号是有限的。 以下情况不会产生僵尸进程： 该进程的父进程先结束了。每个进程结束的时候，系统都会扫描是否存在子进程，如果有则用Init进程接管，成为该进程的父进程，并且会调用wait等待其结束。 父进程调用wait或者waitpid等待子进程结束（需要每隔一段时间查询子进程是否结束）。wait系统调用会使父进程暂停执行，直到它的一个子进程结束为止。waitpid则可以加入WNOHANG(wait-no-hang)选项，如果没有发现结束的子进程，就会立即返回，不会将调用waitpid的进程阻塞。同时，waitpid还可以选择是等待任一子进程（同wait），还是等待指定pid的子进程，还是等待同一进程组下的任一子进程，还是等待组ID等于pid的任一子进程； 子进程结束时，系统会产生SIGCHLD(signal-child)信号，可以注册一个信号处理函数，在该函数中调用waitpid，等待所有结束的子进程（注意：一般都需要循环调用waitpid，因为在信号处理函数开始执行之前，可能已经有多个子进程结束了，而信号处理函数只执行一次，所以要循环调用将所有结束的子进程回收）； 也可以用signal(SIGCLD, SIG_IGN)(signal-ignore)通知内核，表示忽略SIGCHLD信号，那么子进程结束后，内核会进行回收。 什么是孤儿进程？Answer一个父进程已经结束了，但是它的子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程会被Init（进程ID为1）接管，当这些孤儿进程结束时由Init完成状态收集工作。 什么是用户态和内核态？Answer为了限制不同程序的访问能力，防止一些程序访问其它程序的内存数据，CPU划分了用户态和内核态两个权限等级。 用户态只能受限地访问内存，且不允许访问外围设备，没有占用CPU的能力，CPU资源可以被其它程序获取； 内核态可以访问内存所有数据以及外围设备，也可以进行程序的切换。 所有用户程序都运行在用户态，但有时需要进行一些内核态的操作，比如从硬盘或者键盘读数据，这时就需要进行系统调用，使用陷阱指令，CPU&gt;切换到内核态，执行相应的服务，再切换为用户态并返回系统调用的结果。 为什么要分用户态和内核态？Answer 安全性：防止用户程序恶意或者不小心破坏系统/内存/硬件资源； 封装性：用户程序不需要实现更加底层的代码； 利于调度：如果多个用户程序都在等待键盘输入，这时就需要进行调度；统一交给操作系统调度更加方便。 如何从用户态切换到内核态？Answer 系统调用：比如读取命令行输入。本质上还是通过中断实现 用户程序发生异常时：比如缺页异常 外围设备的中断：外围设备完成用户请求的操作之后，会向CPU发出中断信号，这时CPU会转去处理对应的中断处理程序 什么是IO多路复用？怎么实现？AnswerIO多路复用（IO Multiplexing）是指单个进程/线程就可以同时处理多个IO请求。 实现原理：用户将想要监视的文件描述符（File Descriptor）添加到select/poll/epoll函数中，由内核监视，函数阻塞。一旦有文件描述符就绪（读就绪或写就绪），或者超时（设置timeout），函数就会返回，然后该进程可以进行相应的读/写操作。 操作系统为每一个进程维护了一个文件描述符表，该表的索引值都从从0开始的 select poll epoll 操作方式 遍历 遍历 回调 底层实现 数组 链表 红黑树 IO效率 每次调用都进行线性遍历，时间复杂度为O(n) 每次调用都进行线性遍历，时间复杂度为O(n) 事件通知方式，每当fd就绪，系统注册的回调[5]函数就会被调用，将就绪fd放到readyList里面，时间复杂度为O(1) 最大连接数 1024(x86)或2048(x64) 无上限 无上限 fd拷贝 每次调用select，都需要把fd集合从用户态拷贝到内核态 每次调用poll，都需要把fd集合从用户态拷贝到内核态 调用epoll_ctl时拷贝进内核并保存，之后每次epoll_wait不拷贝 select/poll/epoll三者的区别？Answer select：将文件描述符放入一个集合中，调用select时，将这个集合从用户空间拷贝到内核空间（缺点1：每次都要复制，开销大），由内核根据就绪状态修改该集合的内容。（缺点2）集合大小有限制，32位机默认是1024（64位：2048）；采用水平触发机制。select函数返回后，需要通过遍历这个集合，找到就绪的文件描述符（缺点3：轮询的方式效率较低），当文件描述符的数量增加时，效率会线性下降； poll：和select几乎没有区别，区别在于文件描述符的存储方式不同，poll采用链表的方式存储，没有最大存储数量的限制； epoll：通过内核和用户空间共享内存，避免了不断复制的问题；支持的同时连接数上限很高（1G左右的内存支持10W左右的连接数）；文件描述符就绪时，采用回调机制，避免了轮询（回调函数将就绪的描述符添加到一个链表中，执行epoll_wait时，返回这个链表）；支持水平触发和边缘触发，采用边缘触发机制时，只有活跃的描述符才会触发回调函数。 总结，区别主要在于： 一个线程/进程所能打开的最大连接数 文件描述符传递方式（是否复制） 水平触发 or 边缘触发 水平触发:就是只有高电平(1)或低电平(0)时才触发通知,只要在这两种状态就能得到通知.上面提到的只要有数据可读(描述符就绪)那么水平触发的epoll就立即返回. 边缘触发:只有电平发生变化(高电平到低电平,或者低电平到高电平)的时候才触发通知.上面提到即使有数据可读,但是io状态没有变化epoll也不会立即返回. 查询就绪的描述符时的效率（是否轮询） 什么时候使用select/poll，什么时候使用epoll？Answer当连接数较多并且有很多的不活跃连接时，epoll的效率比其它两者高很多； 但是当连接数较少并且都十分活跃的情况下，由于epoll需要很多回调，因此性能可能低于其它两者。 什么是文件描述符？Answer文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。 内核通过文件描述符来访问文件。文件描述符指向一个文件。 什么是水平触发？什么是边缘触发？Answer 水平触发（LT，Level Trigger）模式下，只要一个文件描述符就绪，就会触发通知，如果用户程序没有一次性把数据读写完，下次还会通知； 边缘触发（ET，Edge Trigger）模式下，当描述符从未就绪变为就绪时通知一次，之后不会再通知，直到再次从未就绪变为就绪（缓冲区从不可读/写变为可读/写）。区别：边缘触发效率更高，减少了被重复触发的次数，函数不会返回大量用户程序可能不需要的文件描述符。 有哪些常见的IO模型？Answer 同步阻塞IO（Blocking IO）：用户线程发起IO读/写操作之后，线程阻塞，直到可以开始处理数据；对CPU资源的利用率不够； 同步非阻塞IO（Non-blocking IO）：发起IO请求之后可以立即返回，如果没有就绪的数据，需要不断地发起IO请求直到数据就绪；不断重复请求消耗了大量的CPU资源； IO多路复用 异步IO（Asynchronous IO）：用户线程发出IO请求之后，继续执行，由内核进行数据的读取并放在用户指定的缓冲区内，在IO完成之后通知用户线程直接使用。 为什么边缘触发一定要用非阻塞（non-block）IO?Answer使用边缘触发，读数据的时候必须读完。剩余在 buffer 里的数据并不会使得 epoll_wait 返回。如果不读完就去 wait ，可能之后没有新事件过来，那么 epoll_wait 一直不返回，剩在 buffer 里的数据就读不到了。而读完所有数据可能需要很长时间，在这段时间里没有机会去 wait ，也没有机会处理 epoll 里可能发生的其它事件 使用非阻塞 fd ，read 不会阻塞，read 过程中可以继续去查看 epoll 中的事件。 使用水平触发，可以一次读一点，然后去 epoll_wait 。只有缓存还有数据，epoll_wait 就会立即返回，不会阻塞。这样可以保证 epoll 里所有 fd 的事件都有处理机会。 操作系统有几种内存管理方式？Answer 页式存储：用户空间划分为大小相等的部分称为页（page），内存空间划分为同样大小的区域称为页框，分配时以页为单位，按进程需要的页数分配，逻辑上相邻的页物理上不一定相邻； 段式存储：用户进程地址空间按照自身逻辑关系划分为若干个段（segment）（如代码段，数据段，堆栈段），内存空间被动态划分为长度不同的区域，分配时以段为单位，每段在内存中占据连续空间，各段可以不相邻； 段页式存储：用户进程先按段划分，段内再按页划分，内存划分和分配按页。 区别： 目的不同：分页的目的是管理内存，用于虚拟内存以获得更大的地址空间；分段的目的是满足用户的需要，使程序和数据可以被划分为逻辑上独立的地址空间； 大小不同：段的大小不固定，由其所完成的功能决定；页的大小固定，由系统决定； 地址空间维度不同：分段是二维地址空间（段号+段内偏移），分页是一维地址空间（每个进程一个页表/多级页表，通过一个逻辑地址就能找到对应的物理地址）； 分段便于信息的保护和共享；分页的共享收到限制； 碎片：分段没有内碎片，但会产生外碎片；分页没有外碎片，但会产生内碎片（一个页填不满） 什么是内碎片和外碎片？Answer“碎片的内存”描述一个系统中所有不可用的空闲内存。这些资源之所以仍然未被使用，是因为负责分配内存的分配器使这些内存无法使用。这一问题通常都会发生，原因在于空闲内存以小而不连续方式出现在不同的位置。 在内存管理中，内部碎片是已经被分配出去的的内存空间大于请求所需的内存空间。 外部碎片是指还没有分配出去，但是由于太小而无法分配给申请空间的新进程的内存空间空闲块。 什么是虚拟内存？Answer每个程序都拥有自己的地址空间，这个地址空间被分成大小相等的页，这些页被映射到物理内存；但不需要所有的页都在物理内存中，当程序引用到不在物理内存中的页时，由操作系统将缺失的部分装入物理内存。这样，对于程序来说，逻辑上似乎有很大的内存空间，只是实际上有一部分是存储在磁盘上，因此叫做虚拟内存。 虚拟内存的优点是让程序可以获得更多的可用内存。 如何进行地址空间到物理内存的映射？Answer内存管理单元（MMU）管理着逻辑地址和物理地址的转换，其中的页表（Page table）存储着页（逻辑地址）和页框（物理内存空间）的映射表，页表中还包含包含有效位（是在内存还是磁盘）、访问位（是否被访问过）、修改位（内存中是否被修改过）、保护位（只读还是可读写）。逻辑地址：页号+页内地址（偏移）；每个进程一个页表，放在内存，页表起始地址在PCB/寄存器中。 有哪些页面置换算法？Answer在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘中来腾出空间。页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。 最佳页面置换算法OPT（Optimal replacement algorithm）：置换以后不需要或者最远的将来才需要的页面，是一种理论上的算法，是最优策略； 先进先出FIFO：置换在内存中驻留时间最长的页面。缺点：有可能将那些经常被访问的页面也被换出，从而使缺页率升高； 第二次机会算法SCR：按FIFO选择某一页面，若其访问位为1，给第二次机会，并将访问位置0； 时钟算法 Clock：SCR中需要将页面在链表中移动（第二次机会的时候要将这个页面从链表头移到链表尾），时钟算法使用环形链表，再使用一个指针指向最老的页面，避免了移动页面的开销； 最近未使用算法NRU（Not Recently Used）：检查访问位R、修改位M，优先置换R=M=0，其次是（R=0, M=1）； 最近最少使用算法LRU（Least Recently Used）：置换出未使用时间最长的一页；实现方式：维护时间戳，或者维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。 最不经常使用算法NFU：置换出访问次数最少的页面 什么是局部性原理？Answer 时间上：最近被访问的页在不久的将来还会被访问； 空间上：内存中被访问的页周围的页也很可能被访问。 什么是颠簸现象？Answer颠簸本质上是指频繁的页调度行为。进程发生缺页中断时必须置换某一页。然而，其他所有的页都在使用，它置换一个页，但又立刻再次需要这个页。因此会不断产生缺页中断，导致整个系统的效率急剧下降，这种现象称为颠簸。内存颠簸的解决策略包括： 修改页面置换算法； 降低同时运行的程序的数量； 终止该进程或增加物理内存容量。 什么是缓冲区溢出？AnswerC 语言使用运行时栈来存储过程信息。每个函数的信息存储在一个栈帧中，包括寄存器、局部变量、参数、返回地址等。C 对于数组引用不进行任何边界检查，因此对越界的数组元素的写操作会破坏存储在栈中的状态信息，这种现象称为缓冲区溢出。缓冲区溢出会破坏程序运行，也可以被用来进行攻击计算机，如使用一个指向攻击代码的指针覆盖返回地址。 怎么防治缓冲区溢出？Answer防范缓冲区溢出攻击的机制有三种：随机化、栈保护和限制可执行代码区域。 随机化：包括栈随机化（程序开始时在栈上分配一段随机大小的空间）和地址空间布局随机化（Address-Space Layout Randomization，ASLR，即每次运行时程序的不同部分，包括代码段、数据段、栈、堆等都会被加载到内存空间的不同区域），但只能增加攻击一个系统的难度，不能完全保证安全。 栈保护：在每个函数的栈帧的局部变量和栈状态之间存储一个随机产生的特殊的值，称为金丝雀值（canary）。在恢复寄存器状态和函数返回之前，程序检测这个金丝雀值是否被改变了，如果是，那么程序异常终止。 限制可执行代码区域：内存页的访问形式有三种：可读、可写、可执行，只有编译器产生的那部分代码所处的内存才是可执行的，其他页限制为只允许读和写。 什么是磁盘调度？Answer磁盘调度算法是为了提高磁盘的访问性能，一般是通过优化磁盘的访问请求顺序来做的。其中寻道是磁盘较为耗时的部分，因此如果请求顺序得当，可以节省一些不必要的寻道时间。 寻道算法有： 先来先服务 最短寻道时间优先 电梯算法（扫描算法）：电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。 LOOK与C-LOOK算法：LOOK算法和C-LOOK算法分别是对扫描算法和循环扫描算法的优化，优化的思路就是：磁头移动到最远的请求位置，然后立刻向反方向移动。 LOOK算法反向移动途中会响应请求 C-LOOK反向移动途中不响应请求 什么是死锁？Answer在两个或者多个并发进程中，每个进程持有某种资源而又等待其它进程释放它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁(deadlock)。 死锁产生的必要条件？Answer 互斥：一个资源一次只能被一个进程使用； 占有并等待：一个进程至少占有一个资源，并在等待另一个被其它进程占用的资源； 非抢占：已经分配给一个进程的资源不能被强制性抢占，只能由进程完成任务之后自愿释放； 循环等待：若干进程之间形成一种头尾相接的环形等待资源关系，该环路中的每个进程都在等待下一个进程所占有的资源。 死锁有哪些处理方法？Answer鸵鸟策略 直接忽略死锁。因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。 死锁预防 基本思想是破坏形成死锁的四个必要条件： 破坏互斥条件：允许某些资源同时被多个进程访问。但是有些资源本身并不具有这种属性，因此这种方案实用性有限； 破坏占有并等待条件： 实行资源预先分配策略（当一个进程开始运行之前，必须一次性向系统申请它所需要的全部资源，否则不运行）； 或者只允许进程在没有占用资源的时候才能申请资源（申请资源前先释放占有的资源）； 缺点：很多时候无法预知一个进程所需的全部资源；同时，会降低资源利用率，降低系统的并发性； 破坏非抢占条件：允许进程强行抢占被其它进程占有的资源。会降低系统性能； 破坏循环等待条件：对所有资源统一编号，所有进程对资源的请求必须按照序号递增的顺序提出，即只有占有了编号较小的资源才能申请编号较大的资源。这样避免了占有大号资源的进程去申请小号资源。 死锁避免 动态地检测资源分配状态，以确保系统处于安全状态，只有处于安全状态时才会进行资源的分配。所谓安全状态是指：即使所有进程突然请求需要的所有资源，也能存在某种对进程的资源分配顺序，使得每一个进程运行完毕。 银行家算法：银行家算法的实质就是要设法保证系统动态分配资源后不进入不安全状态，以避免可能产生的死锁。即没当进程提出资源请求且系统的资源能够满足该请求时，系统将判断满足此次资源请求后系统状态是否安全，如果判断结果为安全，则给该进程分配资源，否则不分配资源，申请资源的进程将阻塞。 银行家算法的执行有个前提条件，即要求进程预先提出自己的最大资源请求，并假设系统拥有固定的资源总量。 死锁解除 如何检测死锁：检测有向图是否存在环；或者使用类似死锁避免的检测算法。 死锁解除的方法： 利用抢占：挂起某些进程，并抢占它的资源。但应防止某些进程被长时间挂起而处于饥饿状态； 利用回滚：让某些进程回退到足以解除死锁的地步，进程回退时自愿释放资源。要求系统保持进程的历史信息，设置还原点； 利用杀死进程：强制杀死某些进程直到死锁解除为止，可以按照优先级进行。 计算机网络简述计算机网络体系结构Answer计算机网络体系结构分为3种：OSI体系结构（七层），TCP/IP体系结构（四层），五层体系结构。 OSI体系结构: 概念清楚，理论也比较完整，但是它既复杂又不实用。 TCP/IP体系结构:TCP/IP是一个四层体系结构，得到了广泛的运用。 五层体系结构:为了方便学习，折中OSI体系结构和TCP/IP体系结构，综合二者的优点，这样既简洁，又能将概念讲清楚。 TCP/IP与OSI最大的不同在于：OSI是一个理论上的网络通信模型，而TCP/IP则是实际运行的网络协议。 说一下五层体系结构每一层的主要功能Answer 应用层：应用层是网络协议的最高层，主要任务通过进程间的交互完成特定网络应用。应用层协议定义的是应用程序（进程）间通信和交互的规则。应用层交互的数据单元称为报文。对于不同的网络应用需要有不同的应用层协议，在互联网中的应用层协议很多: FTP(21端口)：文件传输协议 SSH(22端口)：远程登录 更安全 TELNET(23端口)：远程登录 更高效 SMTP(25端口)：发送邮件 POP3(110端口)：接收邮件 HTTP(80端口)：超文本传输协议 DNS(53端口)：运行在UDP上，域名解析服务 运输层：有时也译为传输层，它负责为两台主机中的进程提供通信服务。该层主要有以下两种协议： 传输控制协议 (Transmission Control Protocol，TCP)：提供面向连接的、可靠的数据传输服务，数据传输的基本单位是报文段（segment）； 用户数据报协议 (User Datagram Protocol，UDP)：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性，数据传输的基本单位是用户数据报。 网络层：网络层负责为分组网络中的不同主机提供通信服务，并通过选择合适的路由将数据传递到目标主机。在发送数据时，网络层把运输层产生的报文段或用户数据封装成分组或包进行传送。 在TCP/IP体系中，由于网络层使用IP协议，因此分组也叫IP数据报。 数据链路层：数据链路层通常简称为链路层。数据链路层在两个相邻节点传输数据时，将网络层交下来的IP数据报组装成帧，在两个相邻节点之间的链路上传送帧。 物理层：保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境。 IP地址怎么分类？Answer 路由器仅根据网络号net-id来转发分组，当分组到达目的网络的路由器之后，再按照主机号host-id将分组交付给主机；同一网络上的所有主机的网络号相同。 什么叫划分子网？什么是子网掩码？Answer从主机号host-id借用若干个比特作为子网号subnet-id；子网掩码：网络号和子网号都为1，主机号为0；数据报仍然先按照网络号找到目的网络，发送到路由器，路由器再按照网络号和子网号找到目的子网：将子网掩码与目标地址逐比特与操作，若结果为某个子网的网络地址，则送到该子网。 划分子网时，随着子网地址借用主机位数的增多，子网的数目随之增加，而每个子网中的可用主机数逐渐减少。以C类网络为例，原有8位主机位，2的8次方即256个主机地址，默认子网掩码255.255.255.0。借用1位主机位，产生2个子网，每个子网有126个主机地址；借用2位主机位（子网号），产生4个子网，每个子网有62个主机地址…… 每个子网中，第一个IP地址（即主机部分全部为0的IP）和最后一个IP（即主机部分全部为1的IP）不能分配给主机使用，所以每个子网的可用IP地址数为总IP地址数量减2；根据子网ID借用的主机位数，我们可以计算出划分的子网数、掩码、每个子网主机数，列表如下： 划分子网数 子网位数 子网掩码（二进制） 子网掩码（十进制） 每个子网主机数 1～2 1 11111111.11111111.11111111.10000000 255.255.255.128 126 3～4 2 11111111.11111111.11111111.11000000 255.255.255.192 62 5～8 3 11111111.11111111.11111111.11100000 255.255.255.224 30 9～16 4 11111111.11111111.11111111.11110000 255.255.255.240 14 17～32 5 11111111.11111111.11111111.11111000 255.255.255.248 6 33～64 6 11111111.11111111.11111111.11111100 255.255.255.252 2 如上表所示的C类网络中，若子网占用7位主机位时，主机位只剩一位，无论设为0还是1，都意味着主机位是全0或全1。由于主机位全0表示本网络，全1留作广播地址，这时子网实际没有可用主机地址，所以主机位至少应保留2位。 什么是ARP协议 (Address Resolution Protocol)？AnswerARP协议完成了IP地址与物理地址的映射。每一个主机都设有一个 ARP 高速缓存，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。当源主机要发送数据包到目的主机时，会先检查自己的 ARP 高速缓存中有没有目的主机的 MAC 地址，如果有，就直接将数据包发到这个 MAC 地址，如果没有，就向所在的局域网发起一个 ARP 请求的广播包（在发送自己的 ARP 请求时，同时会带上自己的 IP 地址到硬件地址的映射），收到请求的主机检查自己的 IP 地址和目的主机的 IP 地址是否一致，如果一致，则先保存源主机的映射到自己的 ARP 缓存，然后给源主机发送一个 ARP 响应数据包。源主机收到响应数据包之后，先添加目的主机的 IP 地址与 MAC 地址的映射，再进行数据传送。如果源主机一直没有收到响应，表示 ARP 查询失败。 如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。 什么是NAT (Network Address Translation, 网络地址转换)？Answer用于解决内网中的主机要和因特网上的主机通信。由NAT路由器将主机的本地IP地址转换为全球IP地址，分为静态转换（转换得到的全球IP地址固定不变）和动态NAT转换。 什么是三次握手？Answer 第一次握手：Client将SYN置1，随机产生一个初始序列号seq发送给Server，进入SYN_SENT状态； 第二次握手：Server收到Client的SYN=1之后，知道客户端请求建立连接，将自己的SYN置1，ACK置1，产生一个acknowledge number=seq+1，并随机产生一个自己的初始序列号，发送给Client，进入SYN_RCVD状态； 第三次握手：Client检查acknowledge number是否为序列号+1，ACK是否为1，检查正确之后将自己的ACK置为1，产生一个acknowledge number=Server序列号+1，发送给Server，进入ESRABLISHED状态；Server检查ACK为1和acknowledge number为序列号+1之后，也进入ESTABLISHED；完成三次握手，连接建立。 TCP建立连接可以两次握手吗？为什么？Answer不可以。原因有二：首先，可能会出现已失效的连接请求报文段又传到了Server。 client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用 “三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用 “三次握手” 的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。 其次，两次握手无法保证Client正确接收第二次握手的报文，即Server无法确认Client是否收到，也无法保证Client和Server之间成功互换初始序列号。 可以采用四次握手吗？为什么？Answer可以。但是会降低传输的效率。四次握手是指：第二次握手：Server只发送ACK和acknowledge number；而Server的SYN和初始序列号在第三次握手时发送；原来协议中的第三次握手变为第四次握手。出于优化目的，四次握手中的二、三可以合并。 第三次握手中，如果客户端的ACK未送达服务器，会怎样？Answer server端：由于server没有收到ACK确认，因此会重发之前的SYN+ACK（默认重发五次，之后自动关闭连接进入CLOSED状态），Client收到后会重新传ACK给Server。 client端，有两种情况： 在Server进行超时重发的过程中，如果Client向Server发送数据，数据头部的ACK为1，则Server收到数据之后会读取acknowledge number，进入ESTABLISHED状态； 在Server进入CLOSED状态之后，如果Client向Server发送数据，Server会以RST包应答。 如果已经建立了连接，但Client端出现了故障怎么办？AnswerServer每收到一次Client的请求后都会重新复位一个计时器，时间通常设置为两个小时，如果两小时内还没收到Client的任何数据，Server就会发送一个探测报文段，之后每隔75秒发送一次。若连续10个探测报文都没有回应，Server就会认为Client端出了故障，接着就关闭连接。 初始序列是什么？AnswerTCP连接的一方A，随机选择一个32位的序列号（Sequence Number）作为发送数据的初始序列号（Initial Sequence Number，ISN），比如为1000，以该序列号为原点，对要传送的数据进行编号：1001、1002…三次握手时，把这个初始序列号传送给另一方B，以便在传输数据时，B可以确认什么样的数据编号是合法的；同时在进行数据传输时，A还可以确认B收到的每一个字节，如果A收到了B的确认编号（acknowledge number）是2001，就说明编号为1001-2000的数据已经被B成功接受。 什么是四次挥手？Answer 第一次挥手：Client将FIN置为1，发送一个序列号seq给Server；进入FIN_WAIT_1状态； 第二次挥手：Server收到FIN之后，发送一个ACK=1，acknowledge number=收到的序列号+1；进入CLOSE_WAIT状态；此时Client已经没有要发送的数据了，但仍可以接受Server发来的数据。 第三次挥手：Server将FIN置1，发送一个序列号给Client；进入LAST_ACK状态； 第四次挥手：Client收到服务器的FIN后，进入TIME_WAIT状态；接着将ACK置1，发送一个acknowledge number=序列号+1给服务器；服务器收到后，确认acknowledge number，变为CLOSED状态，不再向客户端发送数据。客户端等待2*MSL[6]（报文最长寿命）事件后，也进入CLOSED状态。完成四次挥手。 为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE_WAIT状态意义是什么）？Answer因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复ACK，表示接收到了断开连接的请求。等到数据发完之后再发FIN，断开服务器到客户端的数据传送。 如果第二次挥手时服务器的ACK没有送达客户端，会怎样？Answer客户端没有收到ACK确认，会重新发送FIN请求。 客户端TIME_WAIT状态的意义是什么？Answer第四次挥手时，客户端发送给服务器的ACK有可能丢失，TIME_WAIT状态就是用来重发可能丢失的ACK报文。如果Server没有收到ACK，就会重发FIN，如果Client在2*MSL的时间内收到了FIN，就会重新发送ACK并再次等待2MSL，防止Server没有收到ACK而不断重发FIN。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。 TCP如何实现流量控制？Answer使用滑动窗口协议实现流量控制。防止发送方发送速率太快，接收方缓存区不够导致溢出。接收方会维护一个接收窗口 receiver window（窗口大小单位是字节），接受窗口的大小是根据自己的资源情况动态调整的，在返回ACK时将接受窗口大小放在TCP报文中的窗口字段告知发送方。发送窗口的大小不能超过接受窗口的大小，只有当发送方发送并收到确认之后，才能将发送窗口右移。发送窗口的上限为接受窗口和拥塞窗口中的较小值。接受窗口表明了接收方的接收能力，拥塞窗口表明了网络的传送能力。 什么是零窗口（接收窗口为0时会怎样）？Answer如果接收方没有能力接收数据，就会将接收窗口设置为0，这时发送方必须暂停发送数据，但是会启动一个持续计时器(persistence timer)，到期后发送一个大小为1字节的探测数据包，以查看接收窗口状态。如果接收方能够接收数据，就会在返回的报文中更新接收窗口大小，恢复数据传送。 TCP的拥塞控制是怎么实现的？Answer拥塞控制主要由四个算法组成：慢启动（Slow Start）、拥塞避免（Congestion voidance）、快重传 （Fast Retransmit）、快恢复（Fast Recovery） 慢启动：刚开始发送数据时，先把拥塞窗口（congestion window）设置为一个最大报文段MSS的数值，每收到一个新的确认报文之后，就把拥塞窗口加1个MSS。这样每经过一个传输轮次（或者说是每经过一个往返时间RTT），拥塞窗口的大小就会加倍 拥塞避免：当拥塞窗口的大小达到慢开始门限(slow start threshold)时，开始执行拥塞避免算法，拥塞窗口大小不再指数增加，而是线性增加，即每经过一个传输轮次只增加1MSS. 无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。（这是不使用快重传的情况） 快重传：快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。 快恢复：当发送方连续收到三个重复确认时，就把慢开始门限减半，然后执行拥塞避免算法。不执行慢开始算法的原因：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方认为现在网络可能没有出现拥塞。 TCP如何最大利用带宽？AnswerTCP速率受到三个因素影响 窗口：即滑动窗口大小，见TCP如何实现流量控制？ 带宽：这里带宽是指单位时间内从发送端到接收端所能通过的“最高数据率”，是一种硬件限制。TCP发送端和接收端的数据传输数不可能超过两点间的带宽限制。发送端和接收端之间带宽取所通过线路的带宽最小值（如通过互联网连接）。 RTT：即Round Trip Time，表示从发送端到接收端的一去一回需要的时间，TCP在数据传输过程中会对RTT进行采样（即对发送的数据包及其ACK的时间差进行测量，并根据测量值更新RTT值），TCP根据得到的RTT值更新RTO值，即Retransmission TimeOut，就是重传间隔，发送端对每个发出的数据包进行计时，如果在RTO时间内没有收到所发出的数据包的对应ACK，则认为数据包丢失，将重传数据。一般RTO值都比采样得到的RTT值要大。 带宽时延乘积怎么算？Answer设滑动窗口大小为$W$， 发送端和接收端的带宽为$B$， RTT为$T_r$。 前面已经说过了，TCP发送数据时受滑动窗口的限制，当TCP将滑动窗口中的数据都发出后，在收到第一个ACK之前，滑动窗口大小是0，不能再发送数据了，必须等待ACK包使滑动窗口移动。那么在理想情况下，ACK包应该在什么时候到达呢？显然，就是在数据发出后的RTT时间后，ACK包到达。这也就是说，现在在不考虑丢包和拥塞情况下，TCP在一个RTT时间内能发出的最大数据量为$W$，所以不考虑带宽限制下，TCP能一个时刻能达到的最大速度是$V=\\frac{W}{T_r}$。 现在再考虑带宽限制，前面说过当马路上摆满车的时候，就无法再往里放车了，同理，TCP发送端在$\\frac{T_r}{2}$时间内，能往通道上放的最大数据量为$\\frac{V \\ast T_r}{2}$，通过带宽时延乘积得到的容积限制为$\\frac{B \\ast T_r}{2}$。当$\\frac{B \\ast T_r}{2}\\geq\\frac{V \\ast T_r}{2}$时，单向通道容积不构成瓶颈，速率的限制主要来源于窗口大小限制。而当$\\frac{B\\ast T_r}{2}\\leq\\frac{V\\ast T_r}{2}$时，则就受到容积限制，即此时速率限制来源于带宽限制。 因此，TCP的最大速率为$V=min(\\frac{W}{T_r}, B)$。 在我们平时生活中使用的宽带网络，ADSL（非对称数字用户线路）等环境下，因为带宽都比较小，从而$B\\ast T_r$也比较小，再加上网络情况比较复杂，拥塞情况比较常见，所以这些网络环境下，TCP速率的主要限制因素在于带宽，丢包率等。在这些网络中速率的主要限制因素就是窗口大小了，这也是传统TCP在这些网络环境中不能充分利用带宽的原因所在（因为传统TCP的窗口大小是用2字节表示的，所以最大只有65535（不考虑窗口扩大选项）），除了专线网络外，随着网络硬件技术的发展，万兆交换机的出现，局域网中也可能会出现带宽时延乘积较大的情况。 TCP与UDP的区别Answer TCP是面向连接的，UDP是无连接的； 什么叫无连接？UDP发送数据之前不需要建立连接 TCP是可靠的，UDP不可靠； 什么叫不可靠？UDP接收方收到报文后，不需要给出任何确认 TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多； TCP是面向字节流的，UDP是面向报文的； 什么意思？面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。 TCP有拥塞控制机制，UDP没有。网络出现的拥塞不会使源主机的发送速率降低，这对某些实时应用是很重要的，比如媒体通信，游戏； TCP首部开销（20字节）比UDP首部开销（8字节）要大 UDP 的主机不需要维持复杂的连接状态表 UDP报文结构和TCP报文结构？AnswerUDP头结构 源端口号，目的端口号：发送端和接收端的端口号 长度：UDP用户数据报的长度，最小值是8字节（只有首部） 校验和：检测UDP用户数据报在传输中是否出错，出错就丢弃TCP头结构 源端口号，目的端口号：发送端和接收方的窗口号 序列号：本报文段的数据第一个字节的序号 确认号：期望收到的对方下一个报文段的第一个数据字节的序号 首部长度：TCP报文段的数据起始处距离TCP报文段的起始处有多长，以4字节为计算单位 保留：保留为今后使用，目前置为0 紧急URG：此位置1，表明紧急指针字段有效，告诉系统此报文段有紧急数据，应尽快传送 确认ACK：=1时确认号字段有效，在连接建立后所有传达的报文段都必须把 ACK 置1 推送PSH：当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能够12. 收到对方的响应。在这种情况下，TCP 就可以使用推送（push）操作，这时，发送方TCP 把 PSH 置 1，并立即创建一个报文段发送出去，接收方收到 PSH = 1 的报文段，就尽快地（即“推送”向前）交付给接收应用进程，而不再等到整个缓存都填满后再向上交付 复位RST：用于复位相应的TCP连接 同步SYN：仅在三次握手建立TCP连接时有效。 SYN=1，ACK=0时，表明这是一个连接请求报文段，若对方同意建立连接，则应在相应的报文段中使用SYN=1和ACK=1 终止FIN：用来释放一个连接，当FIN=1时，表明此报文段发送方的数据已经发送完毕，并要求释放连接 窗口：指发送本报文段的一方的接受窗口（不是自己的发送窗口） 校验和：校验和字段检验的范围包括首部和数据两部分，在计算校验和时需要加上 12 字节的伪头部 紧急指针：仅在 URG = 1 时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据），即指出了紧急数据的末尾在报文中的位置，注意：即使窗口为零时也可发送紧急数据 选项：长度可变，最多40字节 什么时候选择TCP，什么时候选UDP？Answer对某些实时性要求比较高的情况，选择UDP，比如游戏，媒体通信，实时视频流（直播），即使出现传输错误也可以容忍；其它大部分情况下，HTTP都是用TCP，因为要求传输的内容可靠，不出现丢失 HTTP可以使用UDP吗？AnswerHTTP不可以使用UDP，HTTP需要基于可靠的传输协议，而UDP不可靠注：http 3.0 使用udp实现 HTTP3维基百科 面向连接和无连接的区别Answer无连接的网络服务（数据报服务）— 面向连接的网络服务（虚电路服务）数据报服务：每个数据包含目的地址，数据路由相互独立（路径可能变化）；网络尽最大努力交付数据，但不保证不丢失、不保证先后顺序、不保证在时限内交付；网络发生拥塞时，可能会将一些分组丢弃；虚电路（Virtual Circuit，VC）服务：首先建立连接，所有的数据包经过相同的路径，服务质量有较好的保证； TCP如何保证传输的可靠性？Answer 数据包校验 对失序数据包重新排序（TCP报文具有序列号） 丢弃重复数据 应答机制：接收方收到数据之后，会发送一个确认； 超时重传：发送方发出数据之后，启动一个定时器，超时未收到接收方的确认，则重新发送这个数据； 流量控制：确保接收端能够接收发送方的数据而不会缓冲区溢出 UDP怎么实现可靠传输？Answer在应用层实现发送/接收队列、确认机制、超时重传、流量控制（滑动窗口）、拥塞控制（拥塞窗口）等…… HTTP请求/响应格式是什么样的？AnswerHTTP协议客户端请求request消息包括以下格式：请求行（request line）、请求头部（header）、空行、请求数据； 服务端响应response也由四个部分组成，分别是：响应行、响应头、空行、响应体。 请求头部字段包括： Accept：能够接受的回应内容类型 Accept-Charset：能够接受的字符集 Accept-Encoding：能够接受的编码方式列表 Connection：该浏览器想要优先使用的连接类型 Date：发送该消息的日期和时间(按照 RFC 7231 中定义的”超文本传输协议日期”格式来发送) Host：服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号。如果所请求的端口是对应的服务的标准端口，则端口号可被省略 …… 响应头部字段包括： Age：这个对象在代理缓存中存在的时间，以秒为单位 Access-Control-Allow-Origin：指定哪些网站可参与到跨来源资源共享过程中 Accept-Patch：指定服务器支持的文件格式类型。 Date Allow：对于特定资源有效的动作。针对HTTP/405这一错误代码而使用 Connection …… HTTP有哪些请求方法？AnswerHTTP协议定义了多种请求方式，具体如下：GET：获取资源，用来请求访问已被URI（统一资源标志符，和URL是包含和被包含的关系，URL是最常见的URI）识别的资源。POST：用来传输实体的主体，虽然GET也可以实现，但是一般不用。PUT：传输文件。但是鉴于PUT方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，因此一般网站都不采用该方法。HEAD：获得报文首部。和GET请求一样，只是不返回报文主体部分。DELETE：删除文件。同样不带验证机制，存在安全性问题。OPTIONS：询问指定的请求URI支持哪些方法。TRACE：追踪路径，让Web服务器将之前的请求通信环回给客户端的方法。CONNECT：要求在与代理服务器通信时建立隧道，实现隧道协议进行TCP通信。 GET与POST有什么区别？Answer GET是幂等的，即读取同一个资源，总是得到相同的数据，POST不是幂等的； 幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同 GET一般用于从服务器获取资源，而POST可以改变服务器上的资源； 请求形式上：GET请求的数据附在URL之后，在HTTP请求头中；POST请求的数据在请求体中； 安全性：GET请求可被缓存、收藏、保留到历史记录，且其请求数据明文出现在URL中。POST的参数不会被保存，安全性相对较高； GET只允许ASCII字符，POST对数据类型没有要求，也允许二进制数据； GET的长度有限制（操作系统或者浏览器），而POST数据大小无限制 Get和Head有什么区别？AnswerHEAD和GET本质是一样的，区别在于HEAD不含有呈现数据，而仅仅是HTTP头信息。有的人可能觉得这个方法没什么用，其实不是这样的。想象一个业务情景：欲判断某个资源是否存在，用HEAD意义更加明确。 HTTP和HTTPS有什么区别？Answer 端口不同：HTTP使用的是80端口，HTTPS使用443端口； HTTP（超文本传输协议）信息是明文传输，HTTPS运行在SSL(Secure Socket Layer)之上，添加了加密和认证机制，更加安全； HTTPS由于加密解密会带来更大的CPU和内存开销； HTTPS通信需要证书，一般需要向证书颁发机构（CA）购买 Https的连接过程（即SSL建立连接过程）？Answer 客户端向服务器发送请求，同时附带支持的加密规则（包括对称加密、非对称加密、摘要算法）； 服务器从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥（用于非对称加密），以及证书的颁发机构等信息（证书中的私钥只能用于服务器端进行解密）； 客户端验证服务器的合法性，包括：证书是否过期，CA（证书颁发机构） 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配； 如果证书受信任，或者用户接受了不受信任的证书，浏览器会生成一个随机密钥（用于对称算法），并用服务器提供的公钥加密（采用非对称算法对密钥加密）；使用Hash算法对握手消息进行摘要计算，并对摘要使用之前产生的密钥加密（对称算法）；将加密后的随机密钥和摘要一起发送给服务器； 服务器使用自己的私钥解密，得到对称加密的密钥，用这个密钥解密出Hash摘要值，并验证握手消息是否一致；如果一致，服务器使用对称加密的密钥加密握手消息发给浏览器； 浏览器解密并验证摘要，若一致，则握手结束。之后的数据传送都使用对称加密的密钥进行加密。总结：非对称加密算法用于在握手过程中加密生成的密码；对称加密算法用于对真正传输的数据进行加密；HASH算法用于验证数据的完整性。 浏览器怎么验证SSL证书？Answer由于证书是分等级的，网站拥有者可能从根证书颁发机构领到证书，也可能从根证书的下一级(如某个国家的认证中心，或者是某个省发出的证书)领到证书。假设我们正在访问某个使用了SSL证书的网站，IE浏览器就会收到了一个SSL证书，如果这个证书是由根证书颁发机构签发的，IE浏览器就会按照下面的步骤来检查:浏览器使用内置的根证书中的公钥来对收到的证书进行认证，如果一致，就表示该安全证书是由可信任的颁证机构签发的，这个网站就是安全可靠的；如果该SSL证书不是根服务器签发的，浏览器就会自动检查上一级的发证机构，直到找到相应的根证书颁发机构，如果该根证书颁发机构是可信的，这个网站的SSL证书也是可信的。 浏览器验证SSL证书5个方面： 第一，检查SSL证书是否是由浏览器中“受信任的根证书颁发机构”颁发。 检查到如果网站部署的SSL证书不是浏览器受信任的根证书颁发机构，则会有安全警告，为IE7浏览器的警告信息为“此网站出具的安全证书不是受信任的证书颁发机构颁发的，安全证书问题可能显示试图欺骗您或截获您向服务器发送的数据，建议关闭此网页，并且不要继续浏览该网站。”IE6浏览器会提示“该安全证书由您没有选定信任的公司颁发”。一般自签名SSL证书和其它不是全球浏览器信任的证书多会出现此种情况。 第二，检查SSL证书中的证书吊销列表，检查证书是否被证书颁发机构吊销。 检查SSL证书中的证书吊销列表，如果已经被吊销，则会显示警告信息：“此组织的证书已被吊销。安全证书问题可能显示试图欺骗您或截获您向服务器发送的数据。建议关闭此网页，并且不要继续浏览该网站。” 第三，检查此SSL证书是否过期。 检查网站SSL证书的有效期限，如果证书已经过了有效期，则会显示警告信息：“此网站出具的安全证书已过期或还未生效。安全证书问题可能显示试图欺骗您或截获您向服务器发送的数据。建议关闭此网页，并且不要继续浏览该网站。” 第四，检查部署此SSL证书的网站的域名是否与证书中的域名一致。 检查部署此SSL证书的网站的域名是否与证书中的域名一致，如果不一致，则浏览器也会显示警告信息：“此网站出具的安全证书是为其他网站地址颁发的。安全证书问题可能显示试图欺骗您或截获您向服务器发送的数据。建议关闭此网页，并且不要继续浏览该网站。” 第五，到欺诈网站数据库查询此网站是否已经被列入欺诈网站黑名单。 如果发现此网站已经被列入欺诈网站黑名单，则会显示：“IE已发现一个已报告的仿冒网站。仿冒网站假冒其他网站并试图欺骗您泄漏个人信息或财务信息。建议关闭此网页，并且不要继续浏览该网站。” 浏览器需经过以上5个方面的检查后，才会在页面显示安全锁标志，正常显示部署了SSL证书的加密页面。 HTTP 怎么切换到 HTTPS ？Answer一种是原始的302跳转，服务器把所有的HTTP流量跳转到HTTPS。但这样有一个漏洞，就是中间人可能在第一次访问站点的时候就劫持。 302重定向又称之为暂时性转移(Temporarily Moved )，英文名称：302 redirect。 也被认为是暂时重定向（temporary redirect） 第二种是引入HSTS （HTTP 严格传输安全，HTTP Strict Transport Security）机制，用户浏览器在访问站点的时候强制使用HTTPS。 HTTPS连接的时候，怎么确定收到的包是服务器发来的（中间人攻击）？Answer使用双向认证。 攻击者在传输过程中伪造服务器的证书，将服务器的公钥替换成自己的公钥，但是对于客户端来说，如果中间人伪造了证书，在校验证书过程中会提示证书错误。 HTTPS因为增加了CA证书，可以在会话前通过证书验证证明通信的彼此就是所声称的人，因此可以防范中间人攻击。这种防范中间人攻击的前提是在HTTPs协议的双向认证上。如果仅仅实现了HTTPs的单向认证，如不验证客户端，只验证服务器，这种情况下还是不能抵御中间人攻击的，这种情况下就会出现SSL剥离攻击（SSLTrip）和SSL劫持攻击。 SSL剥离攻击剥离SSL协议，表现为用户和攻击者之间使用HTTP，攻击者和服务器之间使用https协议。 如何防止SSL剥离攻击？可以（1）在服务器上开启HSTS，使服务器只接收使用HTTPS的连接。（2）将 HSTS 站点列表内置到浏览器中，这样只要浏览器离线判断该站点启用了 HSTS，就会跳过原先的 HTTP 重定向，直接发起 HTTPS 请求。 SSL劫持攻击表现为用户和攻击者之间使用攻击者伪造的CA证书使用其https协议进行通信，（其中重要的步骤是把burpsuit的CA根证书导入用户浏览器，这样用户浏览器就能信任假CA发给中间人的证书(即信任中间人burpsuit)，建立客户端和中间人之间的会话信道）。而攻击者和服务器之间使用真正的CA证书创建的对称秘钥进行加密，攻击者收到客户端信息先用前者会话秘钥解密，再使用后者之间的会话秘钥加密。这样使得客户端和服务器都以为是和真正的对方通信。 如何防止SSL劫持攻击？使用https双向认证 什么是对称加密、非对称加密？区别是什么？Answer 对称加密：加密和解密采用相同的密钥。如：DES、RC2、RC4 非对称加密：需要两个密钥：公钥和私钥。如果用公钥加密，需要用私钥才能解密。如：RSA区别：对称加密速度更快，通常用于大量数据的加密；非对称加密安全性更高（不需要传送私钥） 数字签名、报文摘要的原理？Answer 发送者A用私钥进行签名，接收者B用公钥验证签名。因为除A外没有人有私钥，所以B相信签名是来自A。A不可抵赖，B也不能伪造报文。 摘要算法:MD5、SHA MD5信息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致 Session与Cookie的区别？AnswerSession是服务器端保持状态的方案，Cookie是客户端保持状态的方案 Cookie保存在客户端本地，客户端请求服务器时会将Cookie一起提交；Session保存在服务端，通过检索Sessionid查看状态。保存Sessionid的方式可以采用Cookie，如果禁用了Cookie，可以使用URL重写机制（把会话ID保存在URL中）。 由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session。第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。URL重写的技术来进行会话跟踪，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。Session是在服务端保存的一个数据结构，用来跟踪用户的状态；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。 从输入网址到展示页面的过程 (包括DNS如何解析成IP)？Answer 输入网址 当我们开始在浏览器中输入网址的时候，浏览器其实就已经在智能的匹配可能得 url 了，他会从历史记录，书签等地方，找到已经输入的字符串可能对应的 url，然后给出智能提示，让你可以补全url地址。对于 google的chrome 的浏览器，他甚至会直接从缓存中把网页展示出来，就是说，你还没有按下 enter，页面就出来了。 浏览器查找域名的 IP 地址 请求一旦发起，浏览器首先要做的事情就是解析这个域名，一般来说，浏览器会首先查看本地硬盘的 hosts 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。 如果在本地的 hosts 文件没有能够找到对应的 ip 地址，浏览器会发出一个 DNS请求到本地DNS服务器 。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。 查询你输入的网址的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是递归的方式进行查询。如果没有，本地DNS服务器还要向DNS根服务器进行查询。 根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到域服务器上去继续查询，并给出域服务器的地址。这种过程是迭代的过程。 本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。 最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。 浏览器向web服务器发送一个HTTP请求 拿到域名对应的IP地址之后，浏览器会以一个随机端口（1024&lt;端口&lt;65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口发起TCP的连接请求。这个连接请求到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。 建立了TCP连接之后，发起一个http请求。一个典型的 http request header 一般需要包括请求的方法，例如 GET 或者 POST 等，不常用的还有 PUT 和 DELETE 、HEAD、OPTION以及 TRACE 方法，一般的浏览器只能发起 GET 或者 POST 请求。 客户端向服务器发起http请求的时候，会有一些请求信息，请求信息包含三个部分： 请求行 请求头(Request Header) 空行（发送回车符和换行符，通知服务器以下不再有请求头） 请求正文 下面是一个完整的HTTP请求例子： 123456789GET/sample.jspHTTP/1.1Accept:image/gif.image/jpeg,*/*Accept-Language:zh-cnConnection:Keep-AliveHost:localhostUser-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0)Accept-Encoding:gzip,deflateusername=wangtianyang&amp;password=1234 服务器的永久重定向响应 服务器给浏览器响应一个301永久重定向响应，这样浏览器就会访问 http://www.google.com/ 而非 http://google.com/ 。 为什么服务器一定要重定向而不是直接发送用户想看的网页内容呢？其中一个原因跟搜索引擎排名有关。如果一个页面有两个地址，就像 http://www.google.com/ 和 http://google.com/ ，搜索引擎会认为它们是两个网站，结果造成每个搜索链接都减少从而降低排名。而搜索引擎知道301永久重定向是什么意思，这样就会把访问带www的和不带www的地址归到同一个网站排名下。还有就是用不同的地址会造成缓存友好性变差，当一个页面有好几个名字时，它可能会在缓存里出现好几次。 浏览器跟踪重定向地址 现在浏览器知道了 http://www.google.com/ 才是要访问的正确地址，所以它会发送另一个http请求。 服务器处理请求 经过前面的重重步骤，我们终于将我们的http请求发送到了服务器这里，其实前面的重定向已经是到达服务器了，那么，服务器是如何处理我们的请求的呢？ 后端从在固定的端口接收到TCP报文开始，它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。 一些大一点的网站会将你的请求到反向代理服务器中，因为当网站访问量非常大，网站越来越慢，一台服务器已经不够用了。于是将同一个应用部署在多台服务器上，将大量用户的请求分配给多台机器处理。 此时，客户端不是直接通过HTTP协议访问某网站应用服务器，而是先请求到Nginx，Nginx再请求应用服务器，然后将结果返回给客户端，这里Nginx的作用是反向代理服务器。同时也带来了一个好处，其中一台服务器万一挂了，只要还有其他服务器正常运行，就不会影响用户使用。 通过Nginx的反向代理，我们到达了web服务器，服务端脚本处理我们的请求，访问我们的数据库，获取需要获取的内容等等，当然，这个过程涉及很多后端脚本的复杂操作。由于对这一块不熟，所以这一块只能介绍这么多了。 如图所示： 服务器返回一个 HTTP 响应 经过前面的6个步骤，服务器收到了我们的请求，也处理我们的请求，到这一步，它会把它的处理结果返回，也就是返回一个HTTP响应。 HTTP响应与HTTP请求相似，HTTP响应也由3个部分构成，分别是： 状态行 响应头(Response Header) 空行 响应正文 12345678910111213HTTP/1.1 200 OKDate: Sat, 31 Dec 2005 23:59:59 GMTContent-Type: text/html;charset=ISO-8859-1Content-Length: 122＜html＞＜head＞＜title＞http＜/title＞＜/head＞＜body＞＜!-- body goes here --＞＜/body＞＜/html＞ 浏览器解析、渲染、展示页面 什么是DNS？AnswerDNS（Domain Name System，域名系统）是因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。 通俗地讲，我们更习惯于记住一个网站的名字，比如 www.baidu.com，而不是记住它的ip地址，比如：167.23.10.2。而计算机更擅长记住网站的ip地址，而不是像 http://www.baidu.com 等链接。因为，DNS就相当于一个电话本，比如你要找 http://www.baidu.com 这个域名，那我翻一翻我的电话本，我就知道，哦，它的电话（ip）是167.23.10.2。 DNS有几种查询方式？Answer两种：递归查询和迭代查询。 递归解析 当局部DNS服务器自己不能回答客户机的DNS查询时，它就需要向其他DNS服务器进行查询。此时有两种方式，如图所示的是递归方式。局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根域服务器查询，再由根域名服务器一级级向下查询。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端。 迭代解析 当局部DNS服务器自己不能回答客户机的DNS查询时，也可以通过迭代查询的方式进行解析，如图所示。局部DNS服务器不是自己向其他DNS服务器进行查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。也就是说，迭代解析只是帮你找到相关的服务器而已，而不会帮你去查。比如说：http://baidu.com 的服务器ip地址在192.168.4.5这里，你自己去查吧，本人比较忙，只能帮你到这里了。 什么是DNS负载均衡？Answer当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会蹦掉。处理办法就是用DNS负载均衡技术，它的原理是在DNS服务器中为同一个主机名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。 什么是反向代理？Answer客户端本来可以直接通过HTTP协议访问某网站应用服务器，网站管理员可以在中间加上一个Nginx，客户端请求Nginx，Nginx请求应用服务器，然后将结果返回给客户端，此时Nginx就是反向代理服务器。 全球一共有多少台根域名服务器？Answer全球只有13台（这13台IPv4根域名服务器名字分别为“A”至“M”），1个为主根服务器在美国，由美国互联网机构Network Solutions运作。其余12个均为辅根服务器，其中9个在美国，2个在欧洲(位于英国和瑞典)，1个在亚洲(位于日本)。 HTTP请求有哪些常见状态码？AnswerHTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型。响应分为五类：信息响应(100–199)，成功响应(200–299)，重定向(300–399)，客户端错误(400–499)和服务器错误 (500–599)： 分类 分类描述 1xx 信息，服务器收到请求，需要请求者继续执行操作 2xx 成功，操作被成功接收并处理 3xx 重定向，需要进一步的操作以完成请求 4xx 客户端错误，请求包含语法错误或无法完成请求 5xx 服务器错误，服务器在处理请求的过程中发生了错误 HTTP状态码列表： 状态码 状态码英文名称 中文描述 100 Continue 继续。客户端应继续其请求 101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 200 OK 请求成功。一般用于GET与POST请求 201 Created 已创建。成功请求并创建了新的资源 202 Accepted 已接受。已经接受请求，但未处理完成 203 Non-Authoritative Information 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 204 No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 205 Reset Content 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 206 Partial Content 部分内容。服务器成功处理了部分GET请求 300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI 303 See Other 查看其它地址。与301类似。使用GET和POST请求查看 304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 305 Use Proxy 使用代理。所请求的资源必须通过代理访问 306 Unused 已经被废弃的HTTP状态码 307 Temporary Redirect 临时重定向。与302类似。使用GET请求重定向 400 Bad Request 客户端请求的语法错误，服务器无法理解 401 Unauthorized 请求要求用户的身份认证 402 Payment Required 保留，将来使用 403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求 404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面 405 Method Not Allowed 客户端请求中的方法被禁止 406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求 407 Proxy Authentication Required 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 408 Request Time-out 服务器等待客户端发送的请求时间过长，超时 409 Conflict 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突 410 Gone 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 411 Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息 412 Precondition Failed 客户端请求信息的先决条件错误 413 Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 414 Request-URI Too Large 请求的URI过长（URI通常为网址），服务器无法处理 415 Unsupported Media Type 服务器无法处理请求附带的媒体格式 416 Requested range not satisfiable 客户端请求的范围无效 417 Expectation Failed 服务器无法满足Expect的请求头信息 500 Internal Server Error 服务器内部错误，无法完成请求 501 Not Implemented 服务器不支持请求的功能，无法完成请求 502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 503 Service Unavailabe 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求 505 HTTP Version not supported 服务器不支持请求的HTTP协议的版本，无法完成处理 301 和 302 的区别？Answer301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。 他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址； 302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。SEO302好于301 什么是RIP (Routing Information Protocol, 距离矢量路由协议)? 算法是什么？Answer每个路由器维护一张表，记录该路由器到其它网络的”跳数“，路由器到与其直接连接的网络的跳数是1，每多经过一个路由器跳数就加1；更新该表时和相邻路由器交换路由信息；路由器允许一个路径最多包含15个路由器，如果跳数为16，则不可达。交付数据报时优先选取距离最短的路径。 （PS：RIP是应用层协议：https://www.zhihu.com/question/19645407 ） 优缺点 实现简单，开销小 随着网络规模扩大开销也会增大； 最大距离为15，限制了网络的规模； 当网络出现故障时，要经过较长的时间才能将此信息传递到所有路由器 数据库数据库分为哪两种？Answer关系型 &amp; 非关系型 关系型： 表 非关系型： 文档 关系型数据库和非关系型数据库的区别？Answer非关系型数据库的优势： 性能 NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。 可扩展性 同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。 关系型数据库的优势： 复杂查询 可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。 事务支持 使得对于安全性能很高的数据访问要求得以实现。 事务的概念和特性？Answer概念：数据库事务(transaction)是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行，要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。以BEGIN TRANSACTION开始，以ROLLBACK/COMMIT结束 特性（ACID）： 原子性（Atomicity）：逻辑上是不可分割的操作单元，事务的所有操作要么全部提交成功，要么全部失败回滚（用回滚日志实现，反向执行日志中的操作）； 一致性（Consistency）：事务的执行必须使数据库保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的； 隔离性（Isolation）：一个事务所做的修改在最终提交以前，对其它事务是不可见的（并发执行的事务之间不能相互影响）； 持久性（Durability）：一旦事务提交成功，对数据的修改是永久性的 有哪些并发一致性问题？Answer 丢失修改：一个事务对数据进行了修改，在事务提交之前，另一个事务对同一个数据进行了修改，覆盖了之前的修改； 脏读（Dirty Read）：一个事务读取了被另一个事务修改、但未提交（进行了回滚）的数据，造成两个事务得到的数据不一致； 不可重复读（Nonrepeatable Read）：在同一个事务中，某查询操作在一个时间读取某一行数据和之后一个时间读取该行数据，发现数据已经发生修改（针对update操作）； 幻读（Phantom Read）：当同一查询多次执行时，由于其它事务在这个数据范围内执行了插入操作，会导致每次返回不同的结果集（和不可重复读的区别：针对的是一个数据表整体/范围；并且针对insert/delete操作） 不可重复读和幻读的区别？Answer 不可重复读是读取了其他事务更改的数据，针对update操作 解决：使用行级锁，锁定该行，事务A多次读取操作完成后才释放该锁，这个时候才允许其他事务更改刚才的数据。 幻读是读取了其他事务新增的数据，针对insert和delete操作 解决：使用表级锁，锁定整张表，事务A多次读取数据总量之后才释放该锁，这个时候才允许其他事务新增数据。 数据库的四种隔离级别？Answer 未提交读（Read Uncommited）：在一个事务提交之前，它的执行结果对其它事务也是可见的。会导致脏读、不可重复读、幻读； 提交读（Read Commited）：一个事务只能看见已经提交的事务所作的改变。可避免脏读问题； 可重复读（Repeatable Read）：可以确保同一个事务在多次读取同样的数据时得到相同的结果。（MySQL的默认隔离级别）。可避免不可重复读；（实现：MVCC） 可串行化（序列化）（Serializable）：强制事务串行执行，使之不可能相互冲突，从而解决幻读问题。可能导致大量的超时现象和锁竞争，实际很少使用。 什么是锁？Answer 当数据库有并发事务的时候，可能会产生数据的不一致，这时候需要一些机制来保证访问的次序，锁机制就是这样的一个机制。 就像酒店的房间，如果大家随意进出，就会出现多人抢夺同一个房间的情况，而在房间上装上锁，申请到钥匙的人才可以入住并且将房间锁起来，其他人只有等他使用完毕才可以再次使用。 锁的作用：用于管理对共享资源的并发访问，保证数据库的完整性和一致性。 什么是乐观锁和悲观锁？Answer 悲观锁：认为数据随时会被修改，因此每次读取数据之前都会上锁，防止其它事务读取或修改数据；应用于数据更新比较频繁的场景； 乐观锁：操作数据时不会上锁，但是更新时会判断在此期间有没有别的事务更新这个数据，若被更新过，则失败重试；适用于读多写少的场景。乐观锁的实现方式有： 加一个版本号或者时间戳字段，每次数据更新时同时更新这个字段；（MVCC：多版本并发控制） 先读取想要更新的字段或者所有字段，更新的时候比较一下，只有字段没有变化才进行更新 封锁粒度的概念AnswerMySQL 中提供了两种封锁粒度：行级锁以及表级锁。InnoDB 支持多粒度锁（multiple granularity locking），它允许行级锁与表级锁共存。 封锁粒度小： 好处：锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高； 坏处：系统开销大（加锁、释放锁、检查锁的状态都需要消耗资源） 常见的锁类型？Answer分为排他锁、共享锁和意向锁。 排它锁（Exclusive Lock）/ X锁：事务对数据加上X锁时，只允许此事务读取和修改此数据，并且其它事务不能对该数据加任何锁； 共享锁（Shared Lock）/ S锁：加了S锁后，该事务只能对数据进行读取而不能修改，并且其它事务只能加S锁，不能加X锁 意向锁（Intention Locks）： 一个事务在获得某个数据行对象的 S 锁之前，必须先获得整个表的 IS 锁或更强的锁； 一个事务在获得某个数据行对象的 X 锁之前，必须先获得整个表的 IX 锁； IS/IX 锁之间都是兼容的； 好处：如果一个事务想要对整个表加X锁，就需要先检测是否有其它事务对该表或者该表中的某一行加了锁，这种检测非常耗时。有了意向锁之后，只需要检测整个表是否存在IX/IS/X/S锁就行了 事务可以通过以下语句显式给记录集加共享锁或排他锁： 共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE。其他 session 仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。 排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE。其他 session 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁。 什么是意向锁？Answer意向锁是一种不与行级锁冲突的表级锁,意向锁是有数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享 / 排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。意向锁分为两种： 意向共享锁（intention shared lock, IS）：事务有意向对表中的某些行加共享锁（S锁）— 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。 1SELECT column FROM table ... LOCK IN SHARE MODE; 意向排他锁（intention exclusive lock, IX）：事务有意向对表中的某些行加排他锁（X锁）— 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。 1SELECT column FROM table ... FOR UPDATE; 意向锁的作用？Answer假设事务A获取了某一行的排他锁，但并未提交，此时事务B想获取整张表的表锁： 因为共享锁与排他锁互斥，所以事务 B 在试图对表加共享锁的时候，必须保证： 当前没有其他事务持有 users 表的排他锁。（表粒度） 当前没有其他事务持有 users 表中任意一行的排他锁 。（行粒度） 为了检测是否满足第二个条件，事务 B 必须在确保不存在任何表级排他锁的前提下，去检测表中的每一行是否存在排他锁。很明显这是一个效率很差的做法，但是有了意向锁之后，情况就不一样了： 当事务A在操作某一行的排他锁时，同时获取了整张表的意向排他锁，而意向排他锁和表级共享/排他锁 是互斥的！也就不需要去检查每一行是否有排他锁，而只要检查整张表的意向锁就好了。 注意！！！意向锁与行级锁不互斥！！！意向锁之间也不互斥！！！ 锁之间的兼容度？ 意向共享锁 意向排他锁 表级共享锁 表级排他锁 行级共享锁 行级排他锁 意向共享锁 兼容 兼容 兼容 互斥 兼容 兼容 意向排他锁 兼容 兼容 互斥 互斥 兼容 兼容 表级共享锁 兼容 互斥 兼容 互斥 兼容 互斥 表级排他锁 互斥 互斥 互斥 互斥 互斥 互斥 行级共享锁 兼容 兼容 兼容 互斥 兼容 互斥 行级排他锁 兼容 兼容 互斥 互斥 互斥 互斥 什么是三级封锁协议？Answer 一级封锁协议 一级封锁协议是：事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。事务结束包括正常结束（COMMIT）和非正常结束（ROLLBACK）。 一级封锁协议可以防止丢失修改，并保证事务T是可恢复的。使用一级封锁协议可以解决丢失修改问题。 在一级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，它不能保证可重复读和不读“脏”数据。 二级封锁协议 二级封锁协议是：一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，读完后方可释放S锁。 二级封锁协议除防止了丢失修改，还可以进一步防止读“脏”数据。但在二级封锁协议中，由于读完数据后即可释放S锁，所以它不能保证可重复读。 三级封锁协议 三级封锁协议是：一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放。 三级封锁协议除防止了丢失修改和不读“脏”数据外，还进一步防止了不可重复读。 上述三级协议的主要区别在于什么操作需要申请封锁，以及何时释放。 什么是两段锁协议？Answer事务必须严格分为两个阶段对数据进行加锁和解锁的操作，第一阶段加锁，第二阶段解锁。也就是说一个事务中一旦释放了锁，就不能再申请新锁了。 可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。事务遵循两段锁协议是保证可串行化调度的充分条件。 计算机系统对并发事务中并发操作的调度是随机的，而不同的调度可能会产生不同的结果。在计算机中，多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行它们时的结果相同，我们称这种调度策略为可串行化（Serializable）调度。 并发事务都遵守两段锁协议，则对这些事务的任何并发调度策略都是可串行化的 。 并发事务的一个调度是可串行化的，不一定所有事务都符合两段锁协议 。 什么是 MVCC？Answer多版本并发控制（Multi-Version Concurrency Control, MVCC），MVCC在每行记录后面都保存有两个隐藏的列，用来存储创建版本号和删除版本号。 创建版本号：创建一个数据行时的事务版本号（事务版本号：事务开始时的系统版本号；系统版本号：每开始一个新的事务，系统版本号就会自动递增）； 删除版本号：删除操作时的事务版本号； 各种操作： 插入操作时，记录创建版本号； 删除操作时，记录删除版本号； 更新操作时，先记录删除版本号，再新增一行记录创建版本号； 查询操作时，要符合以下条件才能被查询出来：删除版本号未定义或大于当前事务版本号（删除操作是在当前事务启动之后做的）；创建版本号小于或等于当前事务版本号（创建操作是事务完成或者在事务启动之前完成） 什么是版本链？Answer我们先来理解一下版本链的概念。在InnoDB引擎表中，它的聚簇索引记录中有两个必要的隐藏列： trx_id这个id用来存储的每次对某条聚簇索引记录进行修改的时候的事务id。 roll_pointer每次对哪条聚簇索引记录有修改的时候，都会把老版本写入undo日志中。这个roll_pointer就是存了一个指针，它指向这条聚簇索引记录的上一个版本的位置，通过它来获得上一个版本的记录信息。(注意插入操作的undo日志没有这个属性，因为它没有老版本) ReadView说了版本链我们再来看看ReadView。已提交读和可重复读的区别就在于它们生成ReadView的策略不同。 通过版本号减少了锁的争用，提高了系统性能；可以实现提交读和可重复读两种隔离级别，未提交读无需使用MVCC。 ReadView中主要就是有个列表来存储我们系统中当前活跃着的读写事务，也就是begin了还未提交的事务。通过这个列表来判断记录的某个版本是否对当前事务可见。假设当前列表里的事务id为[80,100]。 如果你要访问的记录版本的事务id为50，比当前列表最小的id80小，那说明这个事务在之前就提交了，所以对当前活动的事务来说是可访问的。如果你要访问的记录版本的事务id为70,发现此事务在列表id最大值和最小值之间，那就再判断一下是否在列表内，如果在那就说明此事务还未提交，所以版本不能被访问。如果不在那说明事务已经提交，所以版本可以被访问。如果你要访问的记录版本的事务id为110，那比事务列表最大id100都大，那说明这个版本是在ReadView生成之后才发生的，所以不能被访问。 举个例子 ，在已提交读隔离级别下： 比如此时有一个事务id为100的事务，修改了name,使得的name等于小明2，但是事务还没提交。则此时的版本链是那此时另一个事务发起了select 语句要查询id为1的记录，那此时生成的ReadView 列表只有[100]。那就去版本链去找了，首先肯定找最近的一条，发现trx_id是100,也就是name为小明2的那条记录，发现在列表内，所以不能访问。 这时候就通过指针继续找下一条，name为小明1的记录，发现trx_id是60，小于列表中的最小id,所以可以访问，直接访问结果为小明1。 那这时候我们把事务id为100的事务提交了，并且新建了一个事务id为110也修改id为1的记录，并且不提交事务这时候版本链就是这时候之前那个select事务又执行了一次查询,又要查询id为1的记录。 这个时候关键的地方来了 如果你是已提交读隔离级别，这时候你会重新一个ReadView，那你的活动事务列表中的值就变了，变成了[110]。 按照上的说法，你去版本链通过trx_id对比查找到合适的结果就是小明2。 如果你是可重复读隔离级别，这时候你的ReadView还是第一次select时候生成的ReadView,也就是列表的值还是[100]。所以select的结果是小明1。所以第二次select结果和第一次一样，所以叫可重复读！ 也就是说已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的ReadView,而可重复读隔离级别则在第一次读的时候生成一个ReadView，之后的读都复用之前的ReadView。 什么是快照读与当前读？Answer快照读(snapshot read)使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销： 简单的select操作(不包括 select … lock in share mode, select … for update)1select * from table ...; 当前读(current read)更新数据时，都是先读后写，而这个读，就是当前读。当前读读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁：12345select * from table where ? lock in share mode;select * from table where ? for update;insert;update;delete; 数据库三大范式是什么？Answer 第一范式(确保每列保持原子性) 第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。 第一范式的合理遵循需要根据系统的实际需求来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式，如下表所示。 上表所示的用户信息遵循了第一范式的要求，这样在对用户使用城市进行分类的时候就非常方便，也提高了数据库的性能。 第二范式(确保表中的每列都和主键相关) 第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。 比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键，如下表所示。 这样就产生一个问题：这个表中是以订单编号和商品编号作为联合主键。这样在该表中商品名称、单位、商品价格等信息不与该表的主键相关，而仅仅是与商品编号相关。所以在这里违反了第二范式的设计原则。 而如果把这个订单信息表进行拆分，把商品信息分离到另一个表中，把订单项目表也分离到另一个表中，就非常完美了。如下所示。 这样设计，在很大程度上减小了数据库的冗余。如果要获取订单的商品信息，使用商品编号到商品信息表中查询即可。 第三范式(确保每列都和主键列直接相关,而不是间接相关) 第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。 比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。如下面这两个表所示的设计就是一个满足第三范式的数据库表。 不符合范式会出现哪些异常？Answer 冗余数据：某些同样的数据多次出现（如学生姓名）； 修改异常：修改了一个记录中的信息，另一个记录中相同的信息却没有修改； 删除异常：删除一个信息，那么也会丢失其它信息（删除一个课程，丢失了一个学生的信息）； 插入异常：无法插入（插入一个还没有课程信息的学生） 表连接有几种方式？Answer 内连接（Inner Join）：仅将两个表中满足连接条件的行组合起来作为结果集 自然连接：只考虑属性相同的元组对； 等值连接：给定条件进行查询 外连接（Outer Join） 左连接：左边表的所有数据都有显示出来，右边的表数据只显示共同有的那部分，没有对应的部分补NULL； 右连接：和左连接相反； 全外连接（Full Outer Join）：查询出左表和右表所有数据，但是去除两表的重复数据 交叉连接（Cross Join）：返回两表的笛卡尔积（对于所含数据分别为m、n的表，返回m*n的结果） 什么是存储过程？有哪些优缺点？Answer存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合。想要实现相应的功能时，只需要调用这个存储过程就行了（类似于函数，输入具有输出参数）。 优点： 预先编译，而不需要每次运行时编译，提高了数据库执行效率； 封装了一系列操作，对于一些数据交互比较多的操作，相比于单独执行SQL语句，可以减少网络通信量； 具有可复用性，减少了数据库开发的工作量； 安全性高，可以让没有权限的用户通过存储过程间接操作数据库； 更易于维护 缺点： 可移植性差，存储过程将应用程序绑定到了数据库上； 开发调试复杂：没有好的IDE； 修改复杂，需要重新编译，有时还需要更新程序中的代码以更新调用 Drop/Delete/Truncate的区别？Answer Delete用来删除表的全部或者部分数据，执行delete之后，用户需要提交之后才会执行，会触发表上的DELETE触发器（包含一个OLD的虚拟表，可以只读访问被删除的数据），DELETE之后表结构还在，删除很慢，一行一行地删，因为会记录日志，可以利用日志还原数据； Truncate删除表中的所有数据，这个操作不能回滚，也不会触发这个表上的触发器。操作比DELETE快很多（直接把表drop掉，再创建一个新表，删除的数据不能找回）。如果表中有自增（AUTO_INCREMENT）列，则重置为1； Drop命令从数据库中删除表，所有的数据行，索引和约束都会被删除；不能回滚，不会触发触发器； 什么是触发器？Answer触发器（TRIGGER）是由事件（比如INSERT/UPDATE/DELETE）来触发运行的操作（不能被直接调用，不能接收参数）。在数据库里以独立的对象存储，用于保证数据完整性（比如可以检验或转换数据）。 有哪些约束类型？Answer约束（Constraint）类型：主键（Primary Key）约束，唯一约束（Unique），检查约束，非空约束，外键（Foreign Key）约束。 什么是视图？什么是游标？Answer 视图：从数据库的基本表中通过查询选取出来的数据组成的虚拟表（数据库中存放视图的定义）。可以对其进行增/删/改/查等操作。视图是对若干张基本表的引用，一张虚表，查询语句执行的结果，不存储具体的数据（基本表数据发生了改变，视图也会跟着改变）；可以跟基本表一样，进行增删改查操作(ps:增删改操作有条件限制)；如连表查询产生的视图无法进行，对视图的增删改会影响原表的数据。好处： 通过只给用户访问视图的权限，保证数据的安全性； 简化复杂的SQL操作，隐藏数据的复杂性（比如复杂的连接）； 游标（Cursor）：用于定位在查询返回的结果集的特定行，以对特定行进行操作。使用游标可以方便地对结果集进行移动遍历，根据需要滚动或对浏览/修改任意行中的数据。主要用于交互式应用。 三级模式/二级映像Answer MySql三种核心日志是什么？AnswerBinlog、Undo Log 和 Redo Log。 Undo LogUndo Log的字面意思就是撤销操作的日志，指的是使MySQL中的数据回到某个状态。 在MySQL数据库中，事务开始之前，MySQL会将待修改的记录保存到Undo Log中，如果数据库崩溃或者事务需要回滚时，MySQL可以通过利用Undo Log日志，将数据库中的数据回滚到之前的状态。 MySQL新增、修改和删除数据时，在事务开始前，就会将信息写入Undo Log中。事务提交时，并不会立刻删除Undo Log，InnoDB存储引擎会将事务对应的Undo Log放入待删除列表中，之后会通过后台的purge thread对待删除的列表进行删除处理。Undo Log是一种逻辑日志，记录的是一个变化过程。比如，MySQL执行一个delete操作，Undo Log就会记录一个insert操作；MySQL执行一个insert操作，Undo Log就会记录一个delete操作；MySQL执行一个update操作，Undo Log就会记录一个相反的update操作。 Undo Log实现了事务的原子性和多版本并发控制，也就是我们经常说的MVCC。 Redo LogRedo Log的字面意思就是重做日志，指的是在数据库出现意外情况时能够对重新执行某种操作。在MySQL中，事务中修改的任何数据，都会将最新的数据写入Redo Log中进行备份。在MySQL中，随着事务操作的执行，就会产生Redo Log日志，在事务提交时会产生Redo Log并将其写入Redo Buffer，Redo Buffer也并不是随着事务的提交就会被立刻写入到磁盘中，而是等事务操作的脏页写入到磁盘之后，Redo Log的使命也就完成了，此时，Redo Log日志占用的空间可以重新利用，会被后续产生的Redo Log日志覆盖。 Redo Log 能够实现事务的持久性，防止在发生故障的时间点，有脏页未写入表的 ibd 文件中，在重启 MySQL 服务的时候，根据Redo Log进行重做，从而将未提交的事务进行持久化。 BinlogBinlog记录所有MySQL数据库表结构变更以及表数据修改的二进制日志，不会记录select和show这类查询操作的日志。Binlog日志是以事件形式记录，还包含语句所执行的消耗时间。开启Binlog日志有以下两个最重要的使用场景: 主从复制：在主库中开启Binlog功能，这样主库就可以把Binlog传递给从库，从库拿到Binlog后实现数据恢复达到主从数据一致性。 数据恢复：通过mysql binlog等工具来恢复数据 数据库索引的实现原理？Answer通常是B+树索引，偶尔也有哈希索引。 在介绍B+树之前， 先简单的介绍一下B树。 B树概念描述一颗B树时需要指定它的阶数，阶数表示了一个节点最多有多少个孩子节点，一般用字母m表示阶数。 B树也称B-树,它是一颗多路平衡查找树。首先，B树和B+树都是从最简单的二叉树变换而来的，我们来看看B树的定义： 每个节点最多有m-1个关键字（可以存有的键值对）。 根节点最少可以只有1个关键字。 非根节点至少有m/2个关键字。 每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。 所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。 每个节点都存有索引和数据，也就是对应的key和value。 所以，根节点的关键字数量范围：1 &lt;= k &lt;= m-1，非根节点的关键字数量范围：m/2 &lt;= k &lt;= m-1。 B树插入插入的时候，我们需要记住一个规则：判断当前结点key的个数是否小于等于m-1，如果满足，直接插入即可，如果不满足，将节点的中间的key将这个节点分为左右两部分，中间的节点放到父节点中即可。 例子：在5阶B树中，结点最多有4个key,最少有2个key（注意：下面的节点统一用一个节点表示key和value）。 插入18，70，50, 40 插入22 插入22时，发现这个节点的关键字已经大于4了，所以需要进行分裂，分裂的规则在上面已经讲了，分裂之后，如下 接着插入23，25，39 分裂，得到下面的 B树删除B树的删除操作相对于插入操作是相对复杂一些的，但是，你知道记住几种情况，一样可以很轻松的掌握的。 例子：现在有一个初始状态是下面这样的B树，然后进行删除操作。 删除15，这种情况是删除叶子节点的元素，如果删除之后，节点数还是大于m/2，这种情况只要直接删除即可。 接着，我们把22删除，这种情况的规则：22是非叶子节点，对于非叶子节点的删除，我们需要用后继key（元素）覆盖要删除的key，然后在后继key所在的子支中删除该后继key。对于删除22，需要将后继元素24移到被删除的22所在的节点。 此时发现26所在的节点只有一个元素，小于2个（m/2），这个节点不符合要求，这时候的规则（向兄弟节点借元素）：如果删除叶子节点，如果删除元素后元素个数少于（m/2），并且它的兄弟节点的元素大于（m/2），也就是说兄弟节点的元素比最少值m/2还多，将先将父节点的元素移到该节点，然后将兄弟节点的元素再移动到父节点。这样就满足要求了。 接着删除28，删除叶子节点，删除后不满足要求，所以，我们需要考虑向兄弟节点借元素，但是，兄弟节点也没有多的节点（2个），借不了，怎么办呢？如果遇到这种情况，首先，还是将先将父节点的元素移到该节点，然后，将当前节点及它的兄弟节点中的key合并，形成一个新的节点。 B+树相同点： 根节点至少一个元素 非根节点元素范围：m/2 &lt;= k &lt;= m-1 不同点： B+树有两种类型的节点：内部结点（也称索引结点）和叶子结点。内部节点就是非叶子节点，内部节点不存储数据，只存储索引，数据都存储在叶子节点。 内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。 每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。 父节点存有右孩子的第一个元素的索引。 插入对于插入操作很简单，只需要记住一个技巧即可：当节点元素数量大于m-1的时候，按中间元素分裂成左右两部分，中间元素分裂到父节点当做索引存储，但是，本身中间元素还是分裂右边这一部分的。 下面以一颗5阶B+树的插入过程为例，5阶B+树的节点最少2个元素，最多4个元素。 插入5，10，15，20 插入25，此时元素数量大于4个了，分裂 接着插入26，30，继续分裂 删除对于删除操作是比B树简单一些的，因为叶子节点有指针的存在，向兄弟节点借元素时，不需要通过父节点了，而是可以直接通过兄弟节移动即可（前提是兄弟节点的元素大于m/2），然后更新父节点的索引；如果兄弟节点的元素不大于m/2（兄弟节点也没有多余的元素），则将当前节点和兄弟节点合并，并且删除父节点中的key，下面我们看看具体的实例。 初始状态 删除10，删除后，不满足要求，发现左边兄弟节点有多余的元素，所以去借元素，最后，修改父节点索引 删除元素5，发现不满足要求，并且发现左右兄弟节点都没有多余的元素，所以，可以选择和兄弟节点合并，最后修改父节点索引 发现父节点索引也不满足条件，所以，需要做跟上面一步一样的操作 B和B+树的区别？AnswerB+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。 B+ 树的优点 B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子几点上关联的数据也具有更好的缓存命中率。 B树的优点在于：由于B树的每一个节点都包含key和value，因此如果经常访问的元素离根节点更近，这种情况下访问也更迅速： 使用B树和B+树的比较InnoDB的索引使用的是B+树实现，B+树对比B树的好处： IO次数少：B+树的中间结点只存放索引，数据都存在叶结点中，因此中间结点可以存更多的数据，让索引树更加矮胖； 范围查询效率更高：B树需要中序遍历整个树，只B+树需要遍历叶结点中的链表； 查询效率更加稳定：每次查询都需要从根结点到叶结点，路径长度相同，所以每次查询的效率都差不多 使用B树索引和哈希索引的比较Answer哈希索引能以 O(1) 时间进行查找，但是只支持精确查找，无法用于部分查找和范围查找，无法用于排序与分组；B树索引支持大于小于等于查找，范围查找。哈希索引遇到大量哈希值相等的情况后查找效率会降低。哈希索引不支持数据的排序。 使用索引的优点Answer 大大加快了数据的检索速度； 可以显著减少查询中分组和排序的时间； 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性； 将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起） 缺点：建立和维护索引耗费时间空间，更新索引很慢。 哪些情况下索引会失效？Answer 以%(表示任意0个或多个字符)开头的LIKE语句； OR语句前后没有同时使用索引； 数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）； 对于多列索引，必须满足最左匹配原则/最左前缀原则 (最左优先：多列索引col1、col2和col3，则 索引生效的情形包括 col1或col1，col2或col1，col2，col3)； 如果MySQL估计全表扫描比索引快，则不使用索引（比如非常小的表） 在哪些地方适合创建索引？Answer 某列经常作为最大最小值； 经常被查询的字段； 经常用作表连接的字段； 经常出现在ORDER BY/GROUP BY/DISTINCT后面的字段 创建索引时需要注意什么？Answer 只应建立在小字段上，而不要对大文本或图片建立索引（一页存储的数据越多一次IO操作获取的数据越大效率越高）； 建立索引的字段应该非空，在MySQL中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。应该用0、一个特殊的值或者一个空串代替NULL； 选择数据密度大（唯一值占总数的百分比很大）的字段作索引 索引的分类？Answer 普通索引 唯一索引 UNIQUE：索引列的值必须唯一，但允许有空值； 主键索引 PRIMARY KEY：必须唯一，不允许空值（是一种特殊的唯一索引；MySQL创建主键时默认为聚集索引，但主键也可以是非聚集索引）； 单列索引和多列索引/复合索引（Composite）：索引的列数； 覆盖（Covering）索引：索引包含了所有满足查询所需要的数据，查询的时候只需要读取索引而不需要回表读取数据； 聚集（Clustered）索引/非聚集索引：对磁盘上存放数据的物理地址重新组织以使这些数据按照指定规则排序的一种索引（数据的物理排列顺序和索引排列顺序一致）。因此每张表只能创建一个聚集索引（因为要改变物理存储顺序）。优点是查询速度快，因为可以直接按照顺序得到需要数据的物理地址。缺点是进行修改的速度较慢。对于需要经常搜索范围的值很有效。非聚集索引只记录逻辑顺序，并不改变物理顺序； 虚拟索引（Virtual）：模拟索引的存在而不用真正创建一个索引，用于快速测试创建索引对执行计划的影响。没有相关的索引段，不增加存储空间的使用 MySQL的两种存储引擎 InnoDB 和 MyISAM 的区别？Answer InnoDB支持事务，可以进行Commit和Rollback； MyISAM 只支持表级锁，而 InnoDB 还支持行级锁，提高了并发操作的性能； InnoDB 支持外键； MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢； MyISAM 支持压缩表和空间数据索引，InnoDB需要更多的内存和存储； InnoDB 支持在线热备份 应用场景 MyISAM管理非事务表。它提供高速存储和检索（MyISAM强调的是性能，每次查询具有原子性，其执行速度比InnoDB更快），以及全文搜索能力。如果表比较小，或者是只读数据（有大量的SELECT），还是可以使用MyISAM； InnoDB支持事务，并发情况下有很好的性能，基本可以替代MyISAM 什么是热备份和冷备份？ 热备份：在数据库运行的情况下备份的方法。优点：可按表或用户备份，备份时数据库仍可使用，可恢复至任一时间点。但是不能出错 冷备份：数据库正常关闭后，将关键性文件复制到另一位置的备份方式。优点：操作简单快速，恢复简单 如何优化数据库？AnswerSQL 语句的优化 分析慢查询日志：记录了在MySQL中响应时间超过阀值long_query_time的SQL语句，通过日志去找出IO大的SQL以及发现未命中索引的SQL 使用 Explain 进行分析：通过explain命令可以得到表的读取顺序、数据读取操作的操作类型、哪些索引可以使用、哪些索引被实际使用、表之间的引用以及被扫描的行数等问题； 应尽量避免在 where 子句中使用!=、&lt;、&gt;操作符或对字段进行null值判断，否则将引擎放弃使用索引而进行全表扫描； 只返回必要的列：最好不要使用 SELECT * 语句； 只返回必要的行：使用 LIMIT 语句来限制返回的数据； 将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有： 让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用； 分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余的查询； 减少锁竞争 索引的优化注意会引起索引失效的情况，以及在适合的地方建立索引 数据库表结构的优化 设计表时遵循三大范式； 选择合适的数据类型：尽可能不要存储NULL字段；使用简单的数据类型（int, varchar/ text）； 表的水平切分（Sharding）：将同一个表中的记录拆分到多个结构相同的表中（策略：哈希取模；根据ID范围来分）。当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓解单个数据库的压力； 表的垂直切分：将一张表按列切分成多个表。可以将不常用的字段单独放在同一个表中；把大字段独立放入一个表中；或者把经常使用的字段（关系密切的）放在一张表中。垂直切分之后业务更加清晰，系统之间整合或扩展容易，数据维护简单 系统配置的优化 操作系统：增加TCP支持的队列数； MySQL配置文件优化：缓存池大小和个数设置 硬件的优化 磁盘性能：固态硬盘； CPU：多核且高频； 内存：增大内存 什么是主从复制？实现原理是什么？Answer主从复制（Replication）是指数据可以从一个MySQL数据库主服务器复制到一个或多个从服务器，从服务器可以复制主服务器中的所有数据库或者特定的数据库，或者特定的表。默认采用异步模式。 实现原理： 主服务器 binary log dump 线程：将主服务器中的数据更改（增删改）日志写入 Binary log 中； 从服务器 I/O 线程：负责从主服务器读取binary log，并写入本地的 Relay log； 从服务器 SQL 线程：负责读取 Relay log，解析出主服务器已经执行的数据更改，并在从服务器中重新执行（Replay），保证主从数据的一致性 为什么要主从复制？Answer 读写分离：主服务器负责写，从服务器负责读 缓解了锁的争用，即使主服务器中加了锁，依然可以进行读操作； 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销； 增加冗余，提高可用性 数据实时备份，当系统中某个节点发生故障时，可以方便的故障切换 降低单个服务器磁盘I/O访问的频率，提高单个机器的I/O性能 设计模式工厂模式(Factory)在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。工厂模式作为一种创建模式，一般在创建复杂对象时，考虑使用；在创建简单对象时，建议直接new完成一个实例对象的创建。 简单工厂模式主要特点是需要在工厂类中做判断，从而创造相应的产品，当增加新产品时，需要修改工厂类。使用简单工厂模式，我们只需要知道具体的产品型号就可以创建一个产品。 缺点：工厂类集中了所有产品类的创建逻辑，如果产品量较大，会使得工厂类变的非常臃肿。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/*关键代码：创建过程在工厂类中完成。*/#include &lt;iostream&gt;using namespace std;//定义产品类型信息typedef enum&#123; Tank_Type_56, Tank_Type_96, Tank_Type_Num&#125;Tank_Type;//抽象产品类class Tank&#123;public: virtual const string&amp; type() = 0;&#125;;//具体的产品类class Tank56 : public Tank&#123;public: Tank56():Tank(),m_strType(&quot;Tank56&quot;) &#123; &#125; // 在派生类的成员函数中使用override时，如果基类中无此函数，或基类中的函数并不是虚函数，编译器会给出相关错误信息。 const string&amp; type() override &#123; cout &lt;&lt; m_strType.data() &lt;&lt; endl; return m_strType; &#125;private: string m_strType;&#125;;//具体的产品类class Tank96 : public Tank&#123;public: Tank96():Tank(),m_strType(&quot;Tank96&quot;) &#123; &#125; const string&amp; type() override &#123; cout &lt;&lt; m_strType.data() &lt;&lt; endl; return m_strType; &#125;private: string m_strType;&#125;; //工厂类class TankFactory&#123;public: //根据产品信息创建具体的产品类实例，返回一个抽象产品类 Tank* createTank(Tank_Type type) &#123; switch(type) &#123; case Tank_Type_56: return new Tank56(); case Tank_Type_96: return new Tank96(); default: return nullptr; &#125; &#125;&#125;;int main()&#123; TankFactory* factory = new TankFactory(); Tank* tank56 = factory-&gt;createTank(Tank_Type_56); tank56-&gt;type(); Tank* tank96 = factory-&gt;createTank(Tank_Type_96); tank96-&gt;type(); delete tank96; tank96 = nullptr; delete tank56; tank56 = nullptr; delete factory; factory = nullptr; return 0;&#125; 工厂方法模式定义一个创建对象的接口，其子类去具体现实这个接口以完成具体的创建工作。如果需要增加新的产品类，只需要扩展一个相应的工厂类即可。 缺点：产品类数据较多时，需要实现大量的工厂类，这无疑增加了代码量。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/*关键代码：创建过程在其子类执行。*/#include &lt;iostream&gt;using namespace std;//产品抽象类class Tank&#123;public: virtual const string&amp; type() = 0;&#125;;//具体的产品类class Tank56 : public Tank&#123;public: Tank56():Tank(),m_strType(&quot;Tank56&quot;) &#123; &#125; const string&amp; type() override &#123; cout &lt;&lt; m_strType.data() &lt;&lt; endl; return m_strType; &#125;private: string m_strType;&#125;;//具体的产品类class Tank96 : public Tank&#123;public: Tank96():Tank(),m_strType(&quot;Tank96&quot;) &#123; &#125; const string&amp; type() override &#123; cout &lt;&lt; m_strType.data() &lt;&lt; endl; return m_strType; &#125;private: string m_strType;&#125;; //抽象工厂类，提供一个创建接口class TankFactory&#123;public: //提供创建产品实例的接口，返回抽象产品类 virtual Tank* createTank() = 0;&#125;;//具体的创建工厂类，使用抽象工厂类提供的接口，去创建具体的产品实例class Tank56Factory : public TankFactory&#123;public: Tank* createTank() override &#123; return new Tank56(); &#125;&#125;;//具体的创建工厂类，使用抽象工厂类提供的接口，去创建具体的产品实例class Tank96Factory : public TankFactory&#123;public: Tank* createTank() override &#123; return new Tank96(); &#125;&#125;;int main()&#123; TankFactory* factory56 = new Tank56Factory(); Tank* tank56 = factory56-&gt;createTank(); tank56-&gt;type(); TankFactory* factory96 = new Tank96Factory(); Tank* tank96 = factory96-&gt;createTank(); tank96-&gt;type(); delete tank96; tank96 = nullptr; delete factory96; factory96 = nullptr; delete tank56; tank56 = nullptr; delete factory56; factory56 = nullptr; return 0;&#125; 抽象工厂模式抽象工厂模式提供创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 当存在多个产品系列，而客户端只使用一个系列的产品时，可以考虑使用抽象工厂模式。 缺点：当增加一个新系列的产品时，不仅需要现实具体的产品类，还需要增加一个新的创建接口，扩展相对困难。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125/** 关键代码：在一个工厂里聚合多个同类产品。* 以下代码以白色衣服和黑色衣服为例，白色衣服为一个产品系列，黑色衣服为一个产品系列。白色上衣搭配白色裤子， 黑色上衣搭配黑色裤字。每个系列的衣服由一个对应的工厂创建，这样一个工厂创建的衣服能保证衣服为同一个系列。*///抽象上衣类class Coat&#123;public: virtual const string&amp; color() = 0;&#125;;//黑色上衣类class BlackCoat : public Coat&#123;public: BlackCoat():Coat(),m_strColor(&quot;Black Coat&quot;) &#123; &#125; const string&amp; color() override &#123; cout &lt;&lt; m_strColor.data() &lt;&lt; endl; return m_strColor; &#125;private: string m_strColor;&#125;;//白色上衣类class WhiteCoat : public Coat&#123;public: WhiteCoat():Coat(),m_strColor(&quot;White Coat&quot;) &#123; &#125; const string&amp; color() override &#123; cout &lt;&lt; m_strColor.data() &lt;&lt; endl; return m_strColor; &#125;private: string m_strColor;&#125;; //抽象裤子类class Pants&#123;public: virtual const string&amp; color() = 0;&#125;;//黑色裤子类class BlackPants : public Pants&#123;public: BlackPants():Pants(),m_strColor(&quot;Black Pants&quot;) &#123; &#125; const string&amp; color() override &#123; cout &lt;&lt; m_strColor.data() &lt;&lt; endl; return m_strColor; &#125;private: string m_strColor;&#125;;//白色裤子类class WhitePants : public Pants&#123;public: WhitePants():Pants(),m_strColor(&quot;White Pants&quot;) &#123; &#125; const string&amp; color() override &#123; cout &lt;&lt; m_strColor.data() &lt;&lt; endl; return m_strColor; &#125;private: string m_strColor;&#125;;//抽象工厂类，提供衣服创建接口class Factory&#123;public: //上衣创建接口，返回抽象上衣类 virtual Coat* createCoat() = 0; //裤子创建接口，返回抽象裤子类 virtual Pants* createPants() = 0;&#125;;//创建白色衣服的工厂类，具体实现创建白色上衣和白色裤子的接口class WhiteFactory : public Factory&#123;public: Coat* createCoat() override &#123; return new WhiteCoat(); &#125; Pants* createPants() override &#123; return new WhitePants(); &#125;&#125;;//创建黑色衣服的工厂类，具体实现创建黑色上衣和白色裤子的接口class BlackFactory : public Factory&#123; Coat* createCoat() override &#123; return new BlackCoat(); &#125; Pants* createPants() override &#123; return new BlackPants(); &#125;&#125;; 单例模式(Singleton)单例模式顾名思义，保证一个类仅可以有一个实例化对象，并且提供一个可以访问它的全局接口。实现单例模式必须注意以下几点： 单例类只能由一个实例化对象。 单例类必须自己提供一个实例化对象。 单例类必须提供一个可以访问唯一实例化对象的接口。 单例模式分为懒汉和饿汉两种实现方式。 懒汉单例模式懒汉：故名思义，不到万不得已就不会去实例化类，也就是说在第一次用到类实例的时候才会去实例化一个对象。在访问量较小，甚至可能不会去访问的情况下，采用懒汉实现，这是以时间换空间。 非线程安全的懒汉单例模式1234567891011121314151617181920212223242526272829/** 关键代码：构造函数是私有的，不能通过赋值运算，拷贝构造等方式实例化对象。*///懒汉式一般实现：非线程安全，getInstance返回的实例指针需要deleteclass Singleton&#123;public: static Singleton* getInstance(); ~Singleton()&#123;&#125;private: Singleton()&#123;&#125; //构造函数私有 Singleton(const Singleton&amp; obj) = delete; //明确拒绝 Singleton&amp; operator=(const Singleton&amp; obj) = delete; //明确拒绝 static Singleton* m_pSingleton; // 静态(static)成员: 不是任意对象的组成部分,但由给定类的全体对象所共享的数据成员或函数成员。&#125;;Singleton* Singleton::m_pSingleton = NULL;Singleton* Singleton::getInstance()&#123; if(m_pSingleton == NULL) &#123; m_pSingleton = new Singleton; &#125; return m_pSingleton;&#125; 线程安全的懒汉单例模式1234567891011121314151617181920212223242526272829std::mutex mt;class Singleton&#123;public: static Singleton* getInstance();private: Singleton()&#123;&#125; //构造函数私有 Singleton(const Singleton&amp;) = delete; //明确拒绝 Singleton&amp; operator=(const Singleton&amp;) = delete; //明确拒绝 static Singleton* m_pSingleton; &#125;;Singleton* Singleton::m_pSingleton = NULL;Singleton* Singleton::getInstance()&#123; if(m_pSingleton == NULL) &#123; mt.lock(); if(m_pSingleton == NULL) &#123; m_pSingleton = new Singleton(); &#125; mt.unlock(); &#125; return m_pSingleton;&#125; 返回一个reference指向local static对象这种单例模式实现方式多线程可能存在不确定性：任何一种non-const static对象，不论它是local或non-local,在多线程环境下“等待某事发生”都会有麻烦。解决的方法：在程序的单线程启动阶段手工调用所有reference-returning函数。这种实现方式的好处是不需要去delete它。12345678910111213141516class Singleton&#123;public: static Singleton&amp; getInstance();private: Singleton()&#123;&#125; Singleton(const Singleton&amp;) = delete; //明确拒绝 Singleton&amp; operator=(const Singleton&amp;) = delete; //明确拒绝&#125;;Singleton&amp; Singleton::getInstance()&#123; static Singleton singleton; return singleton;&#125; 饿汉单例模式饿汉：饿了肯定要饥不择食。所以在单例类定义的时候就进行实例化。在访问量比较大，或者可能访问的线程比较多时，采用饿汉实现，可以实现更好的性能。这是以空间换时间。12345678910111213141516171819//饿汉式：线程安全，注意一定要在合适的地方去delete它class Singleton&#123;public: static Singleton* getInstance();private: Singleton()&#123;&#125; //构造函数私有 Singleton(const Singleton&amp;) = delete; //明确拒绝 Singleton&amp; operator=(const Singleton&amp;) = delete; //明确拒绝 static Singleton* m_pSingleton;&#125;;Singleton* Singleton::m_pSingleton = new Singleton();Singleton* Singleton::getInstance()&#123; return m_pSingleton;&#125; 外观模式(Facade)外观模式：为子系统中的一组接口定义一个一致的界面；外观模式提供一个高层的接口，这个接口使得这一子系统更加容易被使用；对于复杂的系统，系统为客户端提供一个简单的接口，把负责的实现过程封装起来，客户端不需要连接系统内部的细节。 以下情形建议考虑外观模式： 设计初期阶段，应有意识的将不同层分离，层与层之间建立外观模式。 开发阶段，子系统越来越复杂，使用外观模式提供一个简单的调用接口。 一个系统可能已经非常难易维护和扩展，但又包含了非常重要的功能，可以为其开发一个外观类，使得新系统可以方便的与其交互。 优点： 实现了子系统与客户端之间的松耦合关系。 客户端屏蔽了子系统组件，减少了客户端所需要处理的对象数据，使得子系统使用起来更方便容易。 更好的划分了设计层次，对于后期维护更加的容易。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/** 关键代码：客户与系统之间加一个外观层，外观层处理系统的调用关系、依赖关系等。*以下实例以电脑的启动过程为例，客户端只关心电脑开机的、关机的过程，并不需要了解电脑内部子系统的启动过程。*/#include &lt;iostream&gt;using namespace std;//抽象控件类，提供接口class Control&#123;public: virtual void start() = 0; virtual void shutdown() = 0;&#125;;//子控件， 主机class Host : public Control&#123;public: void start() override &#123; cout &lt;&lt; &quot;Host start&quot; &lt;&lt; endl; &#125; void shutdown() override &#123; cout &lt;&lt; &quot;Host shutdown&quot; &lt;&lt; endl; &#125;&#125;;//子控件， 显示屏class LCDDisplay : public Control&#123;public: void start() override &#123; cout &lt;&lt; &quot;LCD Display start&quot; &lt;&lt; endl; &#125; void shutdown() override &#123; cout &lt;&lt; &quot;LCD Display shutdonw&quot; &lt;&lt; endl; &#125;&#125;;//子控件， 外部设备class Peripheral : public Control&#123;public: void start() override &#123; cout &lt;&lt; &quot;Peripheral start&quot; &lt;&lt; endl; &#125; void shutdown() override &#123; cout &lt;&lt; &quot;Peripheral shutdown&quot; &lt;&lt; endl; &#125;&#125;;class Computer&#123;public: void start() &#123; m_host.start(); m_display.start(); m_peripheral.start(); cout &lt;&lt; &quot;Computer start&quot; &lt;&lt; endl; &#125; void shutdown() &#123; m_host.shutdown(); m_display.shutdown(); m_peripheral.shutdown(); cout &lt;&lt; &quot;Computer shutdown&quot; &lt;&lt; endl; &#125;private: Host m_host; LCDDisplay m_display; Peripheral m_peripheral;&#125;;int main()&#123; Computer computer; computer.start(); //do something computer.shutdown(); return 0;&#125; 模板模式(Template)模板模式：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 当多个类有相同的方法，并且逻辑相同，只是细节上有差异时，可以考虑使用模板模式。具体的实现上可以将相同的核心算法设计为模板方法，具体的实现细节有子类实现。 缺点:每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。 以生产电脑为例，电脑生产的过程都是一样的，只是一些装配的器件可能不同而已。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** 关键代码：在抽象类实现通用接口，细节变化在子类实现。*/#include &lt;iostream&gt;using namespace std;class Computer&#123;public: void product() &#123; installCpu(); installRam(); installGraphicsCard(); &#125;protected: virtual void installCpu() = 0; virtual void installRam() = 0; virtual void installGraphicsCard() = 0;&#125;;class ComputerA : public Computer&#123;protected: void installCpu() override &#123; cout &lt;&lt; &quot;ComputerA install Inter Core i5&quot; &lt;&lt; endl; &#125; void installRam() override &#123; cout &lt;&lt; &quot;ComputerA install 2G Ram&quot; &lt;&lt; endl; &#125; void installGraphicsCard() override &#123; cout &lt;&lt; &quot;ComputerA install Gtx940 GraphicsCard&quot; &lt;&lt; endl; &#125;&#125;;class ComputerB : public Computer&#123;protected: void installCpu() override &#123; cout &lt;&lt; &quot;ComputerB install Inter Core i7&quot; &lt;&lt; endl; &#125; void installRam() override &#123; cout &lt;&lt; &quot;ComputerB install 4G Ram&quot; &lt;&lt; endl; &#125; void installGraphicsCard() override &#123; cout &lt;&lt; &quot;ComputerB install Gtx960 GraphicsCard&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; ComputerB* c1 = new ComputerB(); c1-&gt;product(); delete c1; c1 = nullptr; return 0;&#125; 组合模式(Composite)组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得客户端对单个对象和组合对象的使用具有一直性。 既然讲到以树形结构表示“部分-整体”，那可以将组合模式想象成一根大树，将大树分成树枝和树叶两部分，树枝上可以再长树枝，也可以长树叶，树叶上则不能再长出别的东西。 以下情况可以考虑使用组合模式： 希望表示对象的部分-整体层次结构。 希望客户端忽略组合对象与单个对象的不同，客户端将统一的使用组合结构中的所有对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193/** 关键代码：树枝内部组合该接口，并且含有内部属性list，里面放Component。*/#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;memory&gt;using namespace std;//抽象类，提供组合和单个对象的一致接口class Company&#123;public: Company(const string&amp; name): m_name(name)&#123;&#125; virtual ~Company()&#123; cout &lt;&lt; &quot;~Company()&quot; &lt;&lt; endl;&#125; virtual void add(Company* ) = 0; virtual void remove(const string&amp;) = 0; virtual void display(int depth) = 0; virtual const string&amp; name() &#123; return m_name; &#125;protected: string m_name;&#125;;//具体的单个对象实现类，“树枝”类class HeadCompany : public Company&#123;public: HeadCompany(const string&amp; name): Company(name)&#123;&#125; virtual ~HeadCompany()&#123; cout &lt;&lt; &quot;~HeadCompany()&quot; &lt;&lt; endl;&#125; void add(Company* company) override &#123; shared_ptr&lt;Company&gt; temp(company); m_companyList.push_back(temp); &#125; void remove(const string&amp; strName) override &#123; list&lt;shared_ptr&lt;Company&gt;&gt;::iterator iter = m_companyList.begin(); for(; iter != m_companyList.end(); iter++) &#123; if((*iter).get()-&gt;name() == strName) &#123; //不应该在此处使用list&lt;T&gt;.erase(list&lt;T&gt;::iterator iter),会导致iter++错误，这里删除目 标元素之后，必须return。 m_companyList.erase(iter); return; &#125; &#125; &#125; void display(int depth) override &#123; for(int i = 0; i &lt; depth; i++) &#123; cout &lt;&lt; &quot;-&quot;; &#125; cout &lt;&lt; this-&gt;name().data() &lt;&lt; endl; list&lt;shared_ptr&lt;Company&gt;&gt;::iterator iter = m_companyList.begin(); for(; iter!= m_companyList.end(); iter++) &#123; (*iter).get()-&gt;display(depth + 1); &#125; &#125;private: list&lt;shared_ptr&lt;Company&gt;&gt; m_companyList;&#125;;//具体的单个对象实现类，“树叶”类class ResearchCompany : public Company&#123;public: ResearchCompany(const string&amp; name): Company(name)&#123;&#125; virtual ~ResearchCompany()&#123; cout &lt;&lt; &quot;~ResearchCompany()&quot; &lt;&lt; endl;&#125; void add(Company* ) override &#123; &#125; void remove(const string&amp;) override &#123; &#125; void display(int depth) override &#123; for(int i = 0; i &lt; depth; i++) &#123; cout &lt;&lt; &quot;-&quot;; &#125; cout &lt;&lt; m_name.data() &lt;&lt; endl; &#125;&#125;;//具体的单个对象实现类，“树叶”类class SalesCompany : public Company&#123;public: SalesCompany(const string&amp; name): Company(name)&#123;&#125; virtual ~SalesCompany()&#123; cout &lt;&lt; &quot;~SalesCompany()&quot; &lt;&lt; endl;&#125; void add(Company* ) override &#123; &#125; void remove(const string&amp;) override &#123; &#125; void display(int depth) override &#123; for(int i = 0; i &lt; depth; i++) &#123; cout &lt;&lt; &quot;-&quot;; &#125; cout &lt;&lt; m_name.data() &lt;&lt; endl; &#125;&#125;;//具体的单个对象实现类，“树叶”类class FinanceCompany : public Company&#123;public: FinanceCompany(const string&amp; name): Company(name)&#123;&#125; virtual ~FinanceCompany()&#123; cout &lt;&lt; &quot;~FinanceCompany()&quot; &lt;&lt; endl;&#125; void add(Company* ) override &#123; &#125; void remove(const string&amp;) override &#123; &#125; void display(int depth) override &#123; for(int i = 0; i &lt; depth; i++) &#123; cout &lt;&lt; &quot;-&quot;; &#125; cout &lt;&lt; m_name.data() &lt;&lt; endl; &#125;&#125;;int main()&#123; HeadCompany* headRoot = new HeadCompany(&quot;Head Root Company&quot;); HeadCompany* childRoot1 = new HeadCompany(&quot;Child Company A&quot;); ResearchCompany* r1 = new ResearchCompany(&quot;Research Company A&quot;); SalesCompany* s1 = new SalesCompany(&quot;Sales Company A&quot;); SalesCompany* s2 = new SalesCompany(&quot;Sales Company B&quot;); FinanceCompany* f1 = new FinanceCompany(&quot;FinanceCompany A&quot;); childRoot1-&gt;add(r1); childRoot1-&gt;add(s1); childRoot1-&gt;add(s2); childRoot1-&gt;add(f1); HeadCompany* childRoot2 = new HeadCompany(&quot;Child Company B&quot;); ResearchCompany* r2 = new ResearchCompany(&quot;Research Company B&quot;); SalesCompany* s3 = new SalesCompany(&quot;Sales Company C&quot;); SalesCompany* s4 = new SalesCompany(&quot;Sales Company D&quot;); FinanceCompany* f2 = new FinanceCompany(&quot;FinanceCompany B&quot;); childRoot2-&gt;add(r2); childRoot2-&gt;add(s3); childRoot2-&gt;add(s4); childRoot2-&gt;add(f2); headRoot-&gt;add(childRoot1); headRoot-&gt;add(childRoot2); headRoot-&gt;display(1); cout &lt;&lt; &quot;\\n***************\\n&quot; &lt;&lt; endl; childRoot1-&gt;remove(&quot;Sales Company B&quot;); headRoot-&gt;display(1); cout &lt;&lt; &quot;\\n***************\\n&quot; &lt;&lt; endl; delete headRoot; headRoot = nullptr; return 0;&#125; 代理模式代理模式：为其它对象提供一种代理以控制这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介作用。 优点： 职责清晰。真实的角色只负责实现实际的业务逻辑，不用关心其它非本职责的事务，通过后期的代理完成具体的任务。这样代码会简洁清晰。 代理对象可以在客户端和目标对象之间起到中介的作用，这样就保护了目标对象。 扩展性好。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** 关键代码：一个是真正的你要访问的对象(目标类)，一个是代理对象,真正对象与代理对象实现同一个接口,先访问代理* 类再访问真正要访问的对象。*/#include &lt;iostream&gt;using namespace std;class Gril&#123;public: Gril(const string&amp; name = &quot;gril&quot;):m_string(name)&#123;&#125; string getName() &#123; return m_string; &#125;private: string m_string;&#125;;class Profession&#123;public: virtual ~Profession()&#123;&#125; virtual void profess() = 0;&#125;;class YoungMan : public Profession&#123;public: YoungMan(const Gril&amp; gril):m_gril(gril)&#123;&#125; void profess() &#123; cout &lt;&lt; &quot;Young man love &quot; &lt;&lt; m_gril.getName().data() &lt;&lt; endl; &#125;private: Gril m_gril;&#125;;class ManProxy : public Profession&#123;public: ManProxy(const Gril&amp; gril):m_pMan(new YoungMan(gril))&#123;&#125; ~ManProxy() &#123; delete m_pMan; m_pMan = nullptr; &#125; void profess() &#123; m_pMan-&gt;profess(); &#125;private: YoungMan* m_pMan;&#125;;int main(int argc, char *argv[])&#123; Gril gril(&quot;heihei&quot;); ManProxy* proxy = new ManProxy(gril); proxy-&gt;profess(); delete proxy; proxy = nullptr; return 0;&#125; 观察者模式(Observer)观察者模式：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都要得到通知并自动更新。 观察者模式从根本上讲必须包含两个角色：观察者和被观察对象。 被观察对象自身应该包含一个容器来存放观察者对象，当被观察者自身发生改变时通知容器内所有的观察者对象自动更新。 观察者对象可以注册到被观察者的中，完成注册后可以检测被观察者的变化，接收被观察者的通知。当然观察者也可以被注销掉，停止对被观察者的监控。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138/** 关键代码：在目标类中增加一个ArrayList来存放观察者们。*/#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;memory&gt;using namespace std;class View;//被观察者抽象类 数据模型class DataModel&#123;public: virtual ~DataModel()&#123;&#125; virtual void addView(View* view) = 0; virtual void removeView(View* view) = 0; virtual void notify() = 0; //通知函数&#125;;//观察者抽象类 视图class View&#123;public: virtual ~View()&#123; cout &lt;&lt; &quot;~View()&quot; &lt;&lt; endl; &#125; virtual void update() = 0; virtual void setViewName(const string&amp; name) = 0; virtual const string&amp; name() = 0;&#125;;//具体的被观察类， 整数模型class IntDataModel:public DataModel&#123;public: ~IntDataModel() &#123; m_pViewList.clear(); &#125; virtual void addView(View* view) override &#123; shared_ptr&lt;View&gt; temp(view); auto iter = find(m_pViewList.begin(), m_pViewList.end(), temp); if(iter == m_pViewList.end()) &#123; m_pViewList.push_front(temp); &#125; else &#123; cout &lt;&lt; &quot;View already exists&quot; &lt;&lt; endl; &#125; &#125; void removeView(View* view) override &#123; auto iter = m_pViewList.begin(); for(; iter != m_pViewList.end(); iter++) &#123; if((*iter).get() == view) &#123; m_pViewList.erase(iter); cout &lt;&lt; &quot;remove view&quot; &lt;&lt; endl; return; &#125; &#125; &#125; virtual void notify() override &#123; auto iter = m_pViewList.begin(); for(; iter != m_pViewList.end(); iter++) &#123; (*iter).get()-&gt;update(); &#125; &#125;private: list&lt;shared_ptr&lt;View&gt;&gt; m_pViewList; &#125;;//具体的观察者类 表视图class TableView : public View&#123;public: TableView() : m_name(&quot;unknow&quot;)&#123;&#125; TableView(const string&amp; name) : m_name(name)&#123;&#125; ~TableView()&#123; cout &lt;&lt; &quot;~TableView(): &quot; &lt;&lt; m_name.data() &lt;&lt; endl; &#125; void setViewName(const string&amp; name) &#123; m_name = name; &#125; const string&amp; name() &#123; return m_name; &#125; void update() override &#123; cout &lt;&lt; m_name.data() &lt;&lt; &quot; update&quot; &lt;&lt; endl; &#125;private: string m_name;&#125;;int main()&#123; /* * 这里需要补充说明的是在此示例代码中，View一旦被注册到DataModel类之后，DataModel解析时会自动解析掉 * 内部容器中存储的View对象，因此注册后的View对象不需要在手动去delete，再去delete View对象会出错。 */ View* v1 = new TableView(&quot;TableView1&quot;); View* v2 = new TableView(&quot;TableView2&quot;); View* v3 = new TableView(&quot;TableView3&quot;); View* v4 = new TableView(&quot;TableView4&quot;); IntDataModel* model = new IntDataModel; model-&gt;addView(v1); model-&gt;addView(v2); model-&gt;addView(v3); model-&gt;addView(v4); model-&gt;notify(); cout &lt;&lt; &quot;-------------\\n&quot; &lt;&lt; endl; model-&gt;removeView(v1); model-&gt;notify(); delete model; model = nullptr; return 0;&#125; 策略模式(Strategy)策略模式是指定义一系列的算法，把它们单独封装起来，并且使它们可以互相替换，使得算法可以独立于使用它的客户端而变化，也是说这些算法所完成的功能类型是一样的，对外接口也是一样的，只是不同的策略为引起环境角色环境角色表现出不同的行为。 相比于使用大量的if…else，使用策略模式可以降低复杂度，使得代码更容易维护。 缺点：可能需要定义大量的策略类，并且这些策略类都要提供给客户端。 [环境角色] 持有一个策略类的引用，最终给客户端调用。 传统的策略模式实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116/** 关键代码：实现同一个接口。* 以下代码实例中，以游戏角色不同的攻击方式为不同的策略，游戏角色即为执行不同策略的环境角色。*/#include &lt;iostream&gt;using namespace std;//抽象策略类，提供一个接口class Hurt&#123;public: virtual void blood() = 0;&#125;;//具体的策略实现类，具体实现接口， Adc持续普通攻击class AdcHurt : public Hurt&#123;public: void blood() override &#123; cout &lt;&lt; &quot;Adc hurt, Blood loss&quot; &lt;&lt; endl; &#125;&#125;;//具体的策略实现类，具体实现接口， Apc技能攻击class ApcHurt : public Hurt&#123;public: void blood() override &#123; cout &lt;&lt; &quot;Apc Hurt, Blood loss&quot; &lt;&lt; endl; &#125;&#125;;//环境角色类， 游戏角色战士，传入一个策略类指针参数。class Soldier&#123;public: Soldier(Hurt* hurt):m_pHurt(hurt) &#123; &#125; //在不同的策略下，该游戏角色表现出不同的攻击 void attack() &#123; m_pHurt-&gt;blood(); &#125;private: Hurt* m_pHurt;&#125;;//定义策略标签typedef enum&#123; Hurt_Type_Adc, Hurt_Type_Apc, Hurt_Type_Num&#125;HurtType;//环境角色类， 游戏角色法师，传入一个策略标签参数。class Mage&#123;public: Mage(HurtType type) &#123; switch(type) &#123; case Hurt_Type_Adc: m_pHurt = new AdcHurt(); break; case Hurt_Type_Apc: m_pHurt = new ApcHurt(); break; default: break; &#125; &#125; ~Mage() &#123; delete m_pHurt; m_pHurt = nullptr; cout &lt;&lt; &quot;~Mage()&quot; &lt;&lt; endl; &#125; void attack() &#123; m_pHurt-&gt;blood(); &#125;private: Hurt* m_pHurt;&#125;;//环境角色类， 游戏角色弓箭手，实现模板传递策略。template&lt;typename T&gt;class Archer&#123;public: void attack() &#123; m_hurt.blood(); &#125;private: T m_hurt;&#125;;int main()&#123; Archer&lt;ApcHurt&gt;* arc = new Archer&lt;ApcHurt&gt;; arc-&gt;attack(); delete arc; arc = nullptr; return 0;&#125; 使用函数指针实现策略模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;functional&gt; void adcHurt()&#123; std::cout &lt;&lt; &quot;Adc Hurt&quot; &lt;&lt; std::endl;&#125;void apcHurt()&#123; std::cout &lt;&lt; &quot;Apc Hurt&quot; &lt;&lt; std::endl;&#125;//环境角色类， 使用传统的函数指针class Soldier&#123;public: typedef void (*Function)(); Soldier(Function fun): m_fun(fun) &#123; &#125; void attack() &#123; m_fun(); &#125;private: Function m_fun;&#125;;//环境角色类， 使用std::function&lt;&gt;class Mage&#123;public: typedef std::function&lt;void()&gt; Function; Mage(Function fun): m_fun(fun) &#123; &#125; void attack() &#123; m_fun(); &#125;private: Function m_fun;&#125;;int main()&#123; Soldier* soldier = new Soldier(apcHurt); soldier-&gt;attack(); delete soldier; soldier = nullptr; return 0;&#125; 建造者模式(Builder)建造者模式：将复杂对象的构建和其表示分离，使得相同的构建过程可以产生不同的表示。 以下情形可以考虑使用建造者模式： 对象的创建复杂，但是其各个部分的子对象创建算法一定。 需求变化大，构造复杂对象的子对象经常变化，但将其组合在一起的算法相对稳定。 建造者模式的优点： 将对象的创建和表示分离，客户端不需要了解具体的构建细节。 增加新的产品对象时，只需要增加其具体的建造类即可，不需要修改原来的代码，扩展方便。 产品之间差异性大，内部变化较大、较复杂时不建议使用建造者模式。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158/**关键代码：建造者类：创建和提供实例； Director类：管理建造出来的实例的依赖关系。*/#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//具体的产品类class Order&#123;public: void setFood(const string&amp; food) &#123; m_strFood = food; &#125; const string&amp; food() &#123; cout &lt;&lt; m_strFood.data() &lt;&lt; endl; return m_strFood; &#125; void setDrink(const string&amp; drink) &#123; m_strDrink = drink; &#125; const string&amp; drink() &#123; cout &lt;&lt; m_strDrink &lt;&lt; endl; return m_strDrink; &#125;private: string m_strFood; string m_strDrink;&#125;;//抽象建造类，提供建造接口。class OrderBuilder&#123;public: virtual ~OrderBuilder() &#123; cout &lt;&lt; &quot;~OrderBuilder()&quot; &lt;&lt; endl; &#125; virtual void setOrderFood() = 0; virtual void setOrderDrink() = 0; virtual Order* getOrder() = 0;&#125;;//具体的建造类class VegetarianOrderBuilder : public OrderBuilder &#123;public: VegetarianOrderBuilder() &#123; m_pOrder = new Order; &#125; ~VegetarianOrderBuilder() &#123; cout &lt;&lt; &quot;~VegetarianOrderBuilder()&quot; &lt;&lt; endl; delete m_pOrder; m_pOrder = nullptr; &#125; void setOrderFood() override &#123; m_pOrder-&gt;setFood(&quot;vegetable salad&quot;); &#125; void setOrderDrink() override &#123; m_pOrder-&gt;setDrink(&quot;water&quot;); &#125; Order* getOrder() override &#123; return m_pOrder; &#125;private: Order* m_pOrder;&#125;;//具体的建造类class MeatOrderBuilder : public OrderBuilder&#123;public: MeatOrderBuilder() &#123; m_pOrder = new Order; &#125; ~MeatOrderBuilder() &#123; cout &lt;&lt; &quot;~MeatOrderBuilder()&quot; &lt;&lt; endl; delete m_pOrder; m_pOrder = nullptr; &#125; void setOrderFood() override &#123; m_pOrder-&gt;setFood(&quot;beef&quot;); &#125; void setOrderDrink() override &#123; m_pOrder-&gt;setDrink(&quot;beer&quot;); &#125; Order* getOrder() override &#123; return m_pOrder; &#125;private: Order* m_pOrder;&#125;;//Director类，负责管理实例创建的依赖关系，指挥构建者类创建实例class Director&#123;public: Director(OrderBuilder* builder) : m_pOrderBuilder(builder) &#123; &#125; void construct() &#123; m_pOrderBuilder-&gt;setOrderFood(); m_pOrderBuilder-&gt;setOrderDrink(); &#125;private: OrderBuilder* m_pOrderBuilder;&#125;;int main()&#123;// MeatOrderBuilder* mBuilder = new MeatOrderBuilder; OrderBuilder* mBuilder = new MeatOrderBuilder; //注意抽象构建类必须有虚析构函数，解析时才会 调用子类的析构函数 Director* director = new Director(mBuilder); director-&gt;construct();Order* order = mBuilder-&gt;getOrder();order-&gt;food();order-&gt;drink();delete director;director = nullptr;delete mBuilder;mBuilder = nullptr;return 0;&#125; 适配器模式(Adapter)适配器模式可以将一个类的接口转换成客户端希望的另一个接口，使得原来由于接口不兼容而不能在一起工作的那些类可以在一起工作。通俗的讲就是当我们已经有了一些类，而这些类不能满足新的需求，此时就可以考虑是否能将现有的类适配成可以满足新需求的类。适配器类需要继承或依赖已有的类，实现想要的目标接口。 缺点：过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 使用复合实现适配器模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** 关键代码：适配器继承或依赖已有的对象，实现想要的目标接口。* 以下示例中，假设我们之前有了一个双端队列，新的需求要求使用栈和队列来完成。 双端队列可以在头尾删减或增加元素。而栈是一种先进后出的数据结构，添加数据时添加到栈的顶部，删除数据时先删 除栈顶部的数据。因此我们完全可以将一个现有的双端队列适配成一个栈。*///双端队列， 被适配类class Deque&#123;public: void push_back(int x) &#123; cout &lt;&lt; &quot;Deque push_back:&quot; &lt;&lt; x &lt;&lt; endl; &#125; void push_front(int x) &#123; cout &lt;&lt; &quot;Deque push_front:&quot; &lt;&lt; x &lt;&lt; endl; &#125; void pop_back() &#123; cout &lt;&lt; &quot;Deque pop_back&quot; &lt;&lt; endl; &#125; void pop_front() &#123; cout &lt;&lt; &quot;Deque pop_front&quot; &lt;&lt; endl; &#125;&#125;;//顺序类，抽象目标类class Sequence &#123;public: virtual void push(int x) = 0; virtual void pop() = 0;&#125;;//栈,后进先出, 适配类class Stack:public Sequence &#123;public: //将元素添加到堆栈的顶部。 void push(int x) override &#123; m_deque.push_front(x); &#125; //从堆栈中删除顶部元素 void pop() override &#123; m_deque.pop_front(); &#125;private: Deque m_deque;&#125;;//队列，先进先出，适配类class Queue:public Sequence &#123;public: //将元素添加到队列尾部 void push(int x) override &#123; m_deque.push_back(x); &#125; //从队列中删除顶部元素 void pop() override &#123; m_deque.pop_front(); &#125;private: Deque m_deque;&#125;; 使用继承实现适配器模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//双端队列，被适配类class Deque &#123;public: void push_back(int x) &#123; cout &lt;&lt; &quot;Deque push_back:&quot; &lt;&lt; x &lt;&lt; endl; &#125; void push_front(int x) &#123; cout &lt;&lt; &quot;Deque push_front:&quot; &lt;&lt; x &lt;&lt; endl; &#125; void pop_back() &#123; cout &lt;&lt; &quot;Deque pop_back&quot; &lt;&lt; endl; &#125; void pop_front() &#123; cout &lt;&lt; &quot;Deque pop_front&quot; &lt;&lt; endl; &#125;&#125;;//顺序类，抽象目标类class Sequence &#123;public: virtual void push(int x) = 0; virtual void pop() = 0;&#125;;//栈,后进先出, 适配类class Stack:public Sequence, private Deque &#123;public: void push(int x) &#123; push_front(x); &#125; void pop() &#123; pop_front(); &#125;&#125;;//队列，先进先出，适配类class Queue:public Sequence, private Deque &#123;public: void push(int x) &#123; push_back(x); &#125; void pop() &#123; pop_front(); &#125;&#125;; 桥接模式(Bridge)桥接模式：将抽象部分与实现部分分离，使它们都可以独立变换。 以下情形考虑使用桥接模式： 当一个对象有多个变化因素的时候，考虑依赖于抽象的实现，而不是具体的实现。 当多个变化因素在多个对象间共享时，考虑将这部分变化的部分抽象出来再聚合/合成进来。 当一个对象的多个变化因素可以动态变化的时候。 优点： 将实现抽离出来，再实现抽象，使得对象的具体实现依赖于抽象，满足了依赖倒转原则。 更好的可扩展性。 可动态的切换实现。桥接模式实现了抽象和实现的分离，在实现桥接模式时，就可以实现动态的选择具体的实现。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/** 关键代码：将现实独立出来，抽象类依赖现实类。* 以下示例中，将各类App、各类手机独立开来，实现各种App和各种手机的自由桥接。*/#include &lt;iostream&gt;using namespace std;//抽象App类，提供接口class App&#123;public: virtual ~App()&#123; cout &lt;&lt; &quot;~App()&quot; &lt;&lt; endl; &#125; virtual void run() = 0;&#125;;//具体的App实现类class GameApp:public App&#123;public: void run() &#123; cout &lt;&lt; &quot;GameApp Running&quot; &lt;&lt; endl; &#125;&#125;;//具体的App实现类class TranslateApp:public App&#123;public: void run() &#123; cout &lt;&lt; &quot;TranslateApp Running&quot; &lt;&lt; endl; &#125;&#125;;//抽象手机类，提供接口class MobilePhone&#123;public: virtual ~MobilePhone()&#123; cout &lt;&lt; &quot;~MobilePhone()&quot; &lt;&lt; endl;&#125; virtual void appRun(App* app) = 0; //实现App与手机的桥接&#125;;//具体的手机实现类class XiaoMi:public MobilePhone&#123;public: void appRun(App* app) &#123; cout &lt;&lt; &quot;XiaoMi: &quot;; app-&gt;run(); &#125;&#125;;//具体的手机实现类class HuaWei:public MobilePhone&#123;public: void appRun(App* app) &#123; cout &lt;&lt; &quot;HuaWei: &quot;; app-&gt;run(); &#125;&#125;;int main()&#123; App* gameApp = new GameApp; App* translateApp = new TranslateApp; MobilePhone* mi = new XiaoMi; MobilePhone* hua = new HuaWei; mi-&gt;appRun(gameApp); mi-&gt;appRun(translateApp); hua-&gt;appRun(gameApp); hua-&gt;appRun(translateApp); delete hua; hua = nullptr; delete mi; mi = nullptr; delete gameApp; gameApp = nullptr; delete translateApp; translateApp = nullptr; return 0;&#125; 装饰模式(Decorator)装饰模式：动态地给一个对象添加一些额外的功能，它是通过创建一个包装对象，也就是装饰来包裹真实的对象。新增加功能来说，装饰器模式比生产子类更加灵活。 以下情形考虑使用装饰模式： 需要扩展一个类的功能，或给一个类添加附加职责。 需要动态的给一个对象添加功能，这些功能可以再动态的撤销。 需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变的不现实。 当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122/** 关键代码：1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。*/#include &lt;iostream&gt;using namespace std;//抽象构件（Component）角色：给出一个抽象接口，以规范准备接收附加责任的对象。class Component&#123;public: virtual ~Component()&#123;&#125; virtual void configuration() = 0;&#125;;//具体构件（Concrete Component）角色：定义一个将要接收附加责任的类。class Car : public Component&#123;public: void configuration() override &#123; cout &lt;&lt; &quot;A Car&quot; &lt;&lt; endl; &#125;&#125;;//装饰（Decorator）角色：持有一个构件（Component）对象的实例，并实现一个与抽象构件接口一致的接口。class DecorateCar : public Component&#123;public: DecorateCar(Component* car) : m_pCar(car)&#123;&#125; void configuration() override &#123; m_pCar-&gt;configuration(); &#125;private: Component* m_pCar;&#125;;//具体装饰（Concrete Decorator）角色：负责给构件对象添加上附加的责任。class DecorateLED : public DecorateCar&#123;public: DecorateLED(Component* car) : DecorateCar(car)&#123;&#125; void configuration() override &#123; DecorateCar::configuration(); addLED(); &#125;private: void addLED() &#123; cout &lt;&lt; &quot;Install LED&quot; &lt;&lt; endl; &#125;&#125;;//具体装饰（Concrete Decorator）角色：负责给构件对象添加上附加的责任。class DecoratePC : public DecorateCar&#123;public: DecoratePC(Component* car) : DecorateCar(car)&#123;&#125; void configuration() override &#123; DecorateCar::configuration(); addPC(); &#125;private: void addPC() &#123; cout &lt;&lt; &quot;Install PC&quot; &lt;&lt; endl; &#125;&#125;;//具体装饰（Concrete Decorator）角色：负责给构件对象添加上附加的责任。class DecorateEPB : public DecorateCar&#123;public: DecorateEPB(Component* car) : DecorateCar(car)&#123;&#125; void configuration() override &#123; DecorateCar::configuration(); addEPB(); &#125;private: void addEPB() &#123; cout &lt;&lt; &quot;Install Electrical Park Brake&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; Car* car = new Car; DecorateLED* ledCar = new DecorateLED(car); DecoratePC* pcCar = new DecoratePC(ledCar); DecorateEPB* epbCar = new DecorateEPB(pcCar); epbCar-&gt;configuration(); delete epbCar; epbCar = nullptr; delete pcCar; pcCar = nullptr; delete ledCar; ledCar = nullptr; delete car; car = nullptr; return 0;&#125; 中介者模式(Mediator)中介者模式：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之前的交互。 如果对象与对象之前存在大量的关联关系，若一个对象改变，常常需要跟踪与之关联的对象，并做出相应的处理，这样势必会造成系统变得复杂，遇到这种情形可以考虑使用中介者模式。当多个对象存在关联关系时，为它们设计一个中介对象，当一个对象改变时，只需要通知它的中介对象，再由它的中介对象通知每个与它相关的对象。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131/** 关键代码：将相关对象的通信封装到一个类中单独处理。*/#include &lt;iostream&gt;using namespace std;class Mediator;//抽象同事类。class Businessman&#123;public: Businessman()&#123;&#125; Businessman(Mediator* mediator) : m_pMediator(mediator)&#123;&#125; virtual ~Businessman()&#123;&#125; virtual void setMediator(Mediator* m) &#123; m_pMediator = m; &#125; virtual void sendMessage(const string&amp; msg) = 0; virtual void getMessage(const string&amp; msg) = 0;protected: Mediator* m_pMediator;&#125;;//抽象中介者类。class Mediator&#123;public: virtual ~Mediator()&#123;&#125; virtual void setBuyer(Businessman* buyer) = 0; virtual void setSeller(Businessman* seller) = 0; virtual void send(const string&amp; msg, Businessman* man) = 0;&#125;;//具体同事类class Buyer : public Businessman&#123;public: Buyer() : Businessman()&#123;&#125; Buyer(Mediator* mediator) : Businessman(mediator)&#123;&#125; void sendMessage(const string&amp; msg) override &#123; m_pMediator-&gt;send(msg, this); &#125; void getMessage(const string&amp; msg) &#123; cout &lt;&lt; &quot;Buyer recv: &quot; &lt;&lt; msg.data() &lt;&lt; endl; &#125;&#125;;//具体同事类class Seller : public Businessman&#123;public: Seller() : Businessman()&#123;&#125; Seller(Mediator* mediator) : Businessman(mediator)&#123;&#125; void sendMessage(const string&amp; msg) override &#123; m_pMediator-&gt;send(msg, this); &#125; void getMessage(const string&amp; msg) &#123; cout &lt;&lt; &quot;Seller recv: &quot; &lt;&lt; msg.data() &lt;&lt; endl; &#125;&#125;;//具体中介者类class HouseMediator : public Mediator&#123;public: void setBuyer(Businessman* buyer) override &#123; m_pBuyer = buyer; &#125; void setSeller(Businessman* seller) override &#123; m_pSeller = seller; &#125; void send(const string&amp; msg, Businessman* man) override &#123; if(man == m_pBuyer) &#123; m_pSeller-&gt;getMessage(msg); &#125; else if(man == m_pSeller) &#123; m_pBuyer-&gt;getMessage(msg); &#125; &#125;private: Businessman* m_pBuyer; Businessman* m_pSeller;&#125;;int main()&#123; HouseMediator* hMediator = new HouseMediator; Buyer* buyer = new Buyer(hMediator); Seller* seller = new Seller(hMediator); hMediator-&gt;setBuyer(buyer); hMediator-&gt;setSeller(seller); buyer-&gt;sendMessage(&quot;Sell not to sell?&quot;); seller-&gt;sendMessage(&quot;Of course selling!&quot;); delete buyer; buyer = nullptr; delete seller; seller = nullptr; delete hMediator; hMediator = nullptr; return 0;&#125; 备忘录模式(Memento)备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原来保存的状态。 备忘录模式中需要定义的角色类： Originator(发起人)：负责创建一个备忘录Memento，用以记录当前时刻自身的内部状态，并可使用备忘录恢复内部状态。Originator可以根据需要决定Memento存储自己的哪些内部状态。 Memento(备忘录)：负责存储Originator对象的内部状态，并可以防止Originator以外的其他对象访问备忘录。备忘录有两个接口：Caretaker只能看到备忘录的窄接口，他只能将备忘录传递给其他对象。Originator却可看到备忘录的宽接口，允许它访问返回到先前状态所需要的所有数据。 Caretaker(管理者):负责备忘录Memento，不能对Memento的内容进行访问或者操作。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/** 关键代码：Memento类、Originator类、Caretaker类；Originator类不与Memento类耦合，而是与Caretaker类耦合。*/include &lt;iostream&gt;using namespace std;//需要保存的信息typedef struct &#123; int grade; string arm; string corps;&#125;GameValue;//Memento类class Memento &#123;public: Memento()&#123;&#125; Memento(GameValue value):m_gameValue(value)&#123;&#125; GameValue getValue() &#123; return m_gameValue; &#125;private: GameValue m_gameValue;&#125;;//Originator类class Game &#123;public: Game(GameValue value):m_gameValue(value) &#123;&#125; void addGrade() //等级增加 &#123; m_gameValue.grade++; &#125; void replaceArm(string arm) //更换武器 &#123; m_gameValue.arm = arm; &#125; void replaceCorps(string corps) //更换工会 &#123; m_gameValue.corps = corps; &#125; Memento saveValue() //保存当前信息 &#123; Memento memento(m_gameValue); return memento; &#125; void load(Memento memento) //载入信息 &#123; m_gameValue = memento.getValue(); &#125; void showValue() &#123; cout &lt;&lt; &quot;Grade: &quot; &lt;&lt; m_gameValue.grade &lt;&lt; endl; cout &lt;&lt; &quot;Arm : &quot; &lt;&lt; m_gameValue.arm.data() &lt;&lt; endl; cout &lt;&lt; &quot;Corps: &quot; &lt;&lt; m_gameValue.corps.data() &lt;&lt; endl; &#125;private: GameValue m_gameValue;&#125;;//Caretaker类class Caretake &#123;public: void save(Memento memento) //保存信息 &#123; m_memento = memento; &#125; Memento load() //读已保存的信息 &#123; return m_memento; &#125;private: Memento m_memento;&#125;;int main()&#123; GameValue v1 = &#123;0, &quot;Ak&quot;, &quot;3K&quot;&#125;; Game game(v1); //初始值 game.addGrade(); game.showValue(); cout &lt;&lt; &quot;----------&quot; &lt;&lt; endl; Caretake care; care.save(game.saveValue()); //保存当前值 game.addGrade(); //修改当前值 game.replaceArm(&quot;M16&quot;); game.replaceCorps(&quot;123&quot;); game.showValue(); cout &lt;&lt; &quot;----------&quot; &lt;&lt; endl; game.load(care.load()); //恢复初始值 game.showValue(); return 0;&#125; 原型模式(Prototype)原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。通俗的讲就是当需要创建一个新的实例化对象时，我们刚好有一个实例化对象，但是已经存在的实例化对象又不能直接使用。这种情况下拷贝一个现有的实例化对象来用，可能会更方便。 以下情形可以考虑使用原型模式： 当new一个对象，非常繁琐复杂时，可以使用原型模式来进行复制一个对象。比如创建对象时，构造函数的参数很多，而自己又不完全的知道每个参数的意义，就可以使用原型模式来创建一个新的对象，不必去理会创建的过程。 当需要new一个新的对象，这个对象和现有的对象区别不大，我们就可以直接复制一个已有的对象，然后稍加修改。 当需要一个对象副本时，比如需要提供对象的数据，同时又需要避免外部对数据对象进行修改，那就拷贝一个对象副本供外部使用。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** 关键代码：拷贝，return new className(*this);*/#include &lt;iostream&gt;using namespace std;//提供一个抽象克隆基类。class Clone&#123;public: virtual Clone* clone() = 0; virtual void show() = 0;&#125;;//具体的实现类class Sheep:public Clone&#123;public: Sheep(int id, string name):Clone(), m_id(id),m_name(name) &#123; cout &lt;&lt; &quot;Sheep() id address:&quot; &lt;&lt; &amp;m_id &lt;&lt; endl; cout &lt;&lt; &quot;Sheep() name address:&quot; &lt;&lt; &amp;m_name &lt;&lt; endl; &#125; ~Sheep() &#123; &#125; //关键代码拷贝构造函数 Sheep(const Sheep&amp; obj) &#123; this-&gt;m_id = obj.m_id; this-&gt;m_name = obj.m_name; cout &lt;&lt; &quot;Sheep(const Sheep&amp; obj) id address:&quot; &lt;&lt; &amp;m_id &lt;&lt; endl; cout &lt;&lt; &quot;Sheep(const Sheep&amp; obj) name address:&quot; &lt;&lt; &amp;m_name &lt;&lt; endl; &#125; //关键代码克隆函数，返回return new Sheep(*this) Clone* clone() &#123; return new Sheep(*this); &#125; void show() &#123; cout &lt;&lt; &quot;id :&quot; &lt;&lt; m_id &lt;&lt; endl; cout &lt;&lt; &quot;name:&quot; &lt;&lt; m_name.data() &lt;&lt; endl; &#125;private: int m_id; string m_name;&#125;;int main()&#123; Clone* s1 = new Sheep(1, &quot;abs&quot;); s1-&gt;show(); Clone* s2 = s1-&gt;clone(); s2-&gt;show(); delete s1; s1 = nullptr; delete s2; s2 = nullptr; return 0;&#125; 享元模式(Flyweight)享元模式：运用共享技术有效地支持大量细粒度的对象。在有大量对象时，把其中共同的部分抽象出来，如果有相同的业务请求，直接返回内存中已有的对象，避免重新创建。 以下情况可以考虑使用享元模式：*系统中有大量的对象，这些对象消耗大量的内存，且这些对象的状态可以被外部化。 对于享元模式，需要将对象的信息分为两个部分：内部状态和外部状态。内部状态是指被共享出来的信息，储存在享元对象内部且不随环境变化而改变；外部状态是不可以共享的，它随环境改变而改变，是由客户端控制的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/** 关键代码：将内部状态作为标识，进行共享。*/#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;memory&gt;using namespace std;//抽象享元类，提供享元类外部接口。class AbstractConsumer&#123;public: virtual ~AbstractConsumer()&#123;&#125; virtual void setArticle(const string&amp;) = 0; virtual const string&amp; article() = 0;&#125;;//具体的享元类class Consumer : public AbstractConsumer&#123;public: Consumer(const string&amp; strName) : m_user(strName)&#123;&#125; ~Consumer() &#123; cout &lt;&lt; &quot; ~Consumer()&quot; &lt;&lt; endl; &#125; void setArticle(const string&amp; info) override &#123; m_article = info; &#125; const string&amp; article() override &#123; return m_article; &#125;private: string m_user; string m_article;&#125;;//享元工厂类class Trusteeship&#123;public: ~Trusteeship() &#123; m_consumerMap.clear(); &#125; void hosting(const string&amp; user, const string&amp; article) &#123; if(m_consumerMap.count(user)) &#123; cout &lt;&lt; &quot;A customer named &quot; &lt;&lt; user.data() &lt;&lt; &quot; already exists&quot; &lt;&lt; endl; Consumer* consumer = m_consumerMap.at(user).get(); consumer-&gt;setArticle(article); &#125; else &#123; shared_ptr&lt;Consumer&gt; consumer(new Consumer(user)); consumer.get()-&gt;setArticle(article); m_consumerMap.insert(pair&lt;string, shared_ptr&lt;Consumer&gt;&gt;(user, consumer)); &#125; &#125; void display() &#123; map&lt;string, shared_ptr&lt;Consumer&gt;&gt;::iterator iter = m_consumerMap.begin(); for(; iter != m_consumerMap.end(); iter++) &#123; cout &lt;&lt; iter-&gt;first.data() &lt;&lt; &quot; : &quot;&lt;&lt; iter-&gt;second.get()-&gt;article().data() &lt;&lt; endl; &#125; &#125;private: map&lt;string, shared_ptr&lt;Consumer&gt;&gt; m_consumerMap;&#125;;int main()&#123; Trusteeship* ts = new Trusteeship; ts-&gt;hosting(&quot;zhangsan&quot;, &quot;computer&quot;); ts-&gt;hosting(&quot;lisi&quot;, &quot;phone&quot;); ts-&gt;hosting(&quot;wangwu&quot;, &quot;watch&quot;); ts-&gt;display(); ts-&gt;hosting(&quot;zhangsan&quot;, &quot;TT&quot;); ts-&gt;hosting(&quot;lisi&quot;, &quot;TT&quot;); ts-&gt;hosting(&quot;wangwu&quot;, &quot;TT&quot;); ts-&gt;display(); delete ts; ts = nullptr; return 0;&#125; 职责链模式(Chain of Resp.)职责链模式：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之前的耦合关系，将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。 职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无需关心请求的处理细节和请求的传递，所有职责链将请求的发送者和请求的处理者解耦了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/** 关键代码：Handler内指明其上级，handleRequest()里判断是否合适，不合适则传递给上级。*/#include &lt;iostream&gt;using namespace std;enum RequestLevel&#123; Level_One = 0, Level_Two, Level_Three, Level_Num&#125;;//抽象处理者（Handler）角色，提供职责链的统一接口。class Leader&#123;public: Leader(Leader* leader):m_leader(leader)&#123;&#125; virtual ~Leader()&#123;&#125; virtual void handleRequest(RequestLevel level) = 0;protected: Leader* m_leader;&#125;;//具体处理者（Concrete Handler）角色class Monitor:public Leader //链扣1&#123;public: Monitor(Leader* leader):Leader(leader)&#123;&#125; void handleRequest(RequestLevel level) &#123; if(level &lt; Level_Two) &#123; cout &lt;&lt; &quot;Mointor handle request : &quot; &lt;&lt; level &lt;&lt; endl; &#125; else &#123; m_leader-&gt;handleRequest(level); &#125; &#125;&#125;;//具体处理者（Concrete Handler）角色class Captain:public Leader //链扣2&#123;public: Captain(Leader* leader):Leader(leader)&#123;&#125; void handleRequest(RequestLevel level) &#123; if(level &lt; Level_Three) &#123; cout &lt;&lt; &quot;Captain handle request : &quot; &lt;&lt; level &lt;&lt; endl; &#125; else &#123; m_leader-&gt;handleRequest(level); &#125; &#125;&#125;;//具体处理者（Concrete Handler）角色class General:public Leader //链扣3&#123;public: General(Leader* leader):Leader(leader)&#123;&#125; void handleRequest(RequestLevel level) &#123; cout &lt;&lt; &quot;General handle request : &quot; &lt;&lt; level &lt;&lt; endl; &#125;&#125;;int main()&#123; Leader* general = new General(nullptr); Leader* captain = new Captain(general); Leader* monitor = new Monitor(captain); monitor-&gt;handleRequest(Level_One); delete monitor; monitor = nullptr; delete captain; captain = nullptr; delete general; general = nullptr; return 0;&#125; 算法LRU思路hashmap加双向链表 Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;utility&gt;#include &lt;list&gt;#include &lt;unordered_map&gt;using namespace std;class LRUCache &#123;public: LRUCache(int capacity) : cap(capacity) &#123;&#125; int get(int key) &#123; if (map.find(key) == map.end()) return -1; auto key_value = *map[key]; cache.erase(map[key]); cache.push_front(key_value); map[key] = cache.begin(); return key_value.second; &#125; void put(int key, int value) &#123; if (map.find(key) == map.end()) &#123; if (cache.size() == cap) &#123; map.erase(cache.back().first); cache.pop_back(); &#125; &#125; else &#123; cache.erase(map[key]); &#125; cache.push_front(&#123;key, value&#125;); map[key] = cache.begin(); &#125;private: int cap; list&lt;pair&lt;int, int&gt;&gt; cache; unordered_map&lt;int, list&lt;pair&lt;int, int&gt;&gt;::iterator&gt; map;&#125;; 快排思路 取基准值 比他小的放在左边，比他大的放右边 递归对左右子数组快排 可以通过随机取基准值和结合插入排序来优化 Code123456789101112131415161718192021222324252627282930313233#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;using namespace std;int partition(vector&lt;int&gt;&amp; nums, int begin, int end) &#123; int key = nums[end]; int i = begin-1, j = begin; while (j &lt; end) &#123; if (nums[j] &lt; key) &#123; swap(nums[++i], nums[j]); &#125; ++j; &#125; swap(nums[++i], nums[end]); return i;&#125;int randomPartition(vector&lt;int&gt;&amp; nums, int begin, int end) &#123; srand((unsigned) time(NULL)); int r = (rand() % (end-begin+1)) + begin; swap(nums[r], nums[end]); return partition(nums, begin, end);&#125;void quickSort(vector&lt;int&gt;&amp; nums, int begin, int end) &#123; if (begin &gt;= end) return; int key = randomPartition(nums, begin, end); quickSort(nums, begin, key-1); quickSort(nums, key+1, end);&#125; 堆排序（从小到大）12345678910111213141516171819202122232425262728293031#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;void buildHeap(vector&lt;int&gt;&amp; nums, int begin, int end) &#123; int parent = begin; int child = parent * 2 + 1; while (child &lt;= end) &#123; if (child + 1 &lt;= end &amp;&amp; nums[child+1] &gt; nums[child]) child += 1; if (nums[parent] &lt; nums[child]) &#123; swap(nums[parent], nums[child]); parent = child; child = parent * 2 + 1; &#125; else &#123; return; &#125; &#125;&#125;void heapSort(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); for (int i = n/2 - 1; i &gt;= 0; --i) &#123; buildHeap(nums, i, n-1); &#125; for (int i = n - 1; i &gt; 0; --i) &#123; swap(nums[i], nums[0]); buildHeap(nums, 0, i-1); &#125;&#125; 插入排序12345678910111213141516#include &lt;vector&gt;using namespace std;void insertionSort(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); for (int i = 1; i &lt; n; ++i) &#123; int j = i - 1; int key = nums[i]; while (j &gt;= 0 &amp;&amp; nums[j] &gt; key) &#123; nums[j+1] = nums[j]; --j; &#125; nums[j+1] = key; &#125;&#125; Socket编程什么是socket？Answersocket顾名思义就是套接字的意思，用于描述地址和端口，是一个通信链的句柄。应用程序通过socket向网络发出请求或者回应。也有人说，socket就是用来建立三次握手的。 有几种socket编程？Answersocket编程有三种，流式套接字（SOCK_STREAM），数据报套接字(SOCK_DGRAM)，原始套接字(SOCK_RAW)，前两者较常用。基于TCP的socket编程是流式套接字。 socket编程在TCP/IP模型的哪一层？Answer socket建立连接的过程？Answer socket需要哪些接口函数？Answer第一次握手：客户端需要发送一个syn X 包，试着去链接服务器端，于是在客户端我们需要提供一个链接函数。 第二次握手：服务器端需要接收客户端发送过来的syn X+1 包，然后在发送ack包，所以我们需要有服务器端接受处理函数 第三次握手：客户端的处理函数和服务器端的处理函数 三次握手只是一个数据传输的过程，但是，我们传输前需要一些准备工作，比如将创建一个套接字，收集一些计算机的资源，将一些资源绑定套接字里面，以及接受和发送数据的函数等等，这些功能接口在一起构成了socket的编程 TCP简易编程服务器端1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;iostream&gt;#include&lt;winsock.h&gt;#pragma comment(lib,&quot;ws2_32.lib&quot;)using namespace std;/*初始化套接字库*/void initialization() &#123; WORD w_req = MAKEWORD(2,2);//版本号 WSADATA wsadata; int err; err = WSAStartup(w_req,&amp;wsadata); if (err != 0) &#123; cout &lt;&lt; &quot;初始化套接字库失败！&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;初始化套接字库成功！&quot; &lt;&lt; endl; &#125; //检测版本号 if (LOBYTE(wsadata.wVersion) != 2 || HIBYTE(wsadata.wHighVersion) != 2) &#123; cout &lt;&lt; &quot;套接字库版本号不符！&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;套接字库版本正确！&quot; &lt;&lt; endl; &#125;&#125;int main() &#123; //定义长度变量 int send_len = 0; int recv_len = 0; int len = 0; //定义发送缓冲区和接受缓冲区 char send_buf[100]; char recv_buf[100]; //定义服务端套接字，接受请求套接字 SOCKET s_server; SOCKET s_accept; //服务端地址客户端地址 SOCKADDR_IN server_addr; SOCKADDR_IN accept_addr; initialization(); //填充服务端信息 server_addr.sin_family = AF_INET; server_addr.sin_addr.S_un.S_addr = htonl(INADDR_ANY); server_addr.sin_port = htons(12341); //创建套接字 s_server = socket(AF_INET,SOCK_STREAM,0); if (bind(s_server, (SOCKADDR*)&amp;server_addr, sizeof(SOCKADDR)) == SOCKET_ERROR) &#123; cout &lt;&lt; &quot;套接字绑定失败！&quot; &lt;&lt; endl; WSACleanup(); &#125; else &#123; cout &lt;&lt; &quot;套接字绑定成功！&quot; &lt;&lt; endl; &#125; //设置套接字为监听状态 if (listen(s_server, SOMAXCONN) &lt; 0) &#123; cout &lt;&lt; &quot;设置监听失败！&quot; &lt;&lt; endl; WSACleanup(); &#125; else &#123; cout &lt;&lt; &quot;设置监听成功！&quot; &lt;&lt; endl; &#125; cout &lt;&lt; &quot;服务端正在监听连接，请稍等---&quot; &lt;&lt; endl; //接受连接请求 len = sizeof(SOCKADDR); s_accept = accept(s_server, (SOCKADDR*)&amp;accept_addr, &amp;len); if (s_accept == SOCKET_ERROR) &#123; cout &lt;&lt; &quot;连接失败！&quot; &lt;&lt; endl; WSACleanup(); return 0; &#125; cout &lt;&lt; &quot;连接建立，准备接受数据&quot; &lt;&lt; endl; //接受数据 while (1) &#123; recv_len = recv(s_accept,recv_buf,100,0); if (recv_len &lt; 0) &#123; cout &lt;&lt; &quot;接受失败！&quot; &lt;&lt; endl; break; &#125; else &#123; cout &lt;&lt; &quot;客户端信息：&quot; &lt;&lt; recv_buf &lt;&lt; endl; &#125; cout &lt;&lt; &quot;请输入回复信息：&quot;; cin &gt;&gt; send_buf; send_len = send(s_accept,send_buf,100,0); if (send_len &lt; 0) &#123; cout &lt;&lt; &quot;发送失败！&quot; &lt;&lt; endl; break; &#125; &#125; return 0;&#125; 客户端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;winsock.h&gt;#pragma comment(lib,&quot;ws2_32.lib&quot;)using namespace std;void initialization() &#123; //初始化套接字库 WORD w_req = MAKEWORD(2,2);//版本号 WSADATA wsadata; int err; err = WSAStartup(w_req,&amp;wsadata); if (err != 0) &#123; cout &lt;&lt; &quot;初始化套接字库失败!&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;初始化套接字库成功！&quot; &lt;&lt; endl; &#125; //检测版本号 if (LOBYTE(wsadata.wVersion) != 2 || HIBYTE(wsadata.wHighVersion) != 2) &#123; cout &lt;&lt; &quot;套接字库版本号不符！&quot; &lt;&lt; endl; WSACleanup(); &#125; else &#123; cout &lt;&lt; &quot;套接字符版本号正确！&quot; &lt;&lt; endl; &#125;&#125;int main() &#123; //定义长度变量 int send_len = 0; int recv_len = 0; //定义发送缓冲区和接受缓冲区 char send_buf[100]; char recv_buf[100]; //定义服务端套接字，接受请求套接字 SOCKET s_server; //服务端地址客户端地址 SOCKADDR_IN server_addr; initialization(); //填充服务端信息 server_addr.sin_family = AF_INET; server_addr.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;); server_addr.sin_port = htons(12341); //创建套接字 s_server = socket(AF_INET, SOCK_STREAM, 0); if (connect(s_server, (SOCKADDR*)&amp;server_addr, sizeof(SOCKADDR)) == SOCKET_ERROR) &#123; cout &lt;&lt; &quot;服务器连接失败！&quot; &lt;&lt; endl; WSACleanup(); &#125; else &#123; cout &lt;&lt; &quot;服务器连接成功！&quot; &lt;&lt; endl; &#125; //发送数据 while (1) &#123; cout &lt;&lt; &quot;请输入发送信息：&quot; &lt;&lt; endl; cin &gt;&gt; send_buf; send_len = send(s_server, send_buf, 100, 0); if (send_len &lt; 0) &#123; cout &lt;&lt; &quot;发送失败！&quot; &lt;&lt; endl; break; &#125; recv_len = recv(s_server,recv_buf,100,0); if (recv_len &lt; 0) &#123; cout &lt;&lt; &quot;接受失败！&quot; &lt;&lt; endl; break; &#125; else &#123; cout &lt;&lt; &quot;服务端信息：&quot; &lt;&lt; recv_buf &lt;&lt; endl; &#125; &#125; //关闭套接字 closesocket(s_server); //释放DLL资源 WSACleanup(); return 0;&#125;1.显示调用和隐式调用：显示调用是指在程序中能找到相应的调用代码，或者说是手动调用的；隐式调用是指程序中找不到相应的调用代码，或者说是编译器自动调用的 ↩2.半双工(Half Duplex)数据传输指数据可以在一个信号载体的两个方向上传输，但是不能同时传输。 ↩3.同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才会继续执行下去； 异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。 当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。 ↩4.进程出现饥饿现象是指进程的优先级较低而长时间得不到调度。 ↩5.在计算机程序设计中，回调函数，或简称回调（Callback 即call then back 被主函数调用运算后会返回主函数），是指通过参数将函数传递到其它代码的，某一块可执行代码的引用。这一设计允许了底层代码调用在高层定义的子程序。 ↩6.MSL(Maximum Segment Lifetime)，指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。 ↩7.InnoDB，是MySQL和MariaDB的数据库引擎之一，最初由MySQL AB发行。InnoDB由Innobase Oy公司所开发，2006年五月时由甲骨文公司并购。与传统的ISAM与MyISAM相比，InnoDB的最大特色就是支持了ACID兼容的事务（Transaction）功能，类似于PostgreSQL。 ↩&lt;/div&gt;","categories":[{"name":"八股文","slug":"八股文","permalink":"https://wangtianyang.com/categories/%E5%85%AB%E8%82%A1%E6%96%87/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://wangtianyang.com/tags/C/"},{"name":"算法","slug":"算法","permalink":"https://wangtianyang.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"操作系统","slug":"操作系统","permalink":"https://wangtianyang.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"数据库","slug":"数据库","permalink":"https://wangtianyang.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://wangtianyang.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"【C++】右值引用","slug":"【C-】右值引用","date":"2022-09-02T09:01:27.000Z","updated":"2023-01-06T13:44:59.957Z","comments":true,"path":"2022/09/02/【C-】右值引用/","link":"","permalink":"https://wangtianyang.com/2022/09/02/%E3%80%90C-%E3%80%91%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/","excerpt":"C++左值和右值在 C++ 或者 C 语言中，一个表达式（可以是字面量、变量、对象、函数的返回值等）根据其使用场景不同，分为左值表达式和右值表达式。确切的说 C++ 中左值和右值的概念是从 C 语言继承过来的。 值得一提的是，左值的英文简写为“lvalue”，右值的英文简写为“rvalue”。很多人认为它们分别是”left value”、”right value” 的缩写，其实不然。lvalue 是“loactor value”的缩写，可意为存储在内存中、有明确存储地址（可寻址）的数据，而 rvalue 译为 “read value”，指的是那些可以提供数据值的数据（不一定可以寻址，例如存储于寄存器中的数据）。 能取到地址、有名字的就是左值，取不到地址的就是右值。","text":"C++左值和右值在 C++ 或者 C 语言中，一个表达式（可以是字面量、变量、对象、函数的返回值等）根据其使用场景不同，分为左值表达式和右值表达式。确切的说 C++ 中左值和右值的概念是从 C 语言继承过来的。 值得一提的是，左值的英文简写为“lvalue”，右值的英文简写为“rvalue”。很多人认为它们分别是”left value”、”right value” 的缩写，其实不然。lvalue 是“loactor value”的缩写，可意为存储在内存中、有明确存储地址（可寻址）的数据，而 rvalue 译为 “read value”，指的是那些可以提供数据值的数据（不一定可以寻址，例如存储于寄存器中的数据）。 能取到地址、有名字的就是左值，取不到地址的就是右值。 左值引用、右值引用C++11以前的引用只能操作左值，无法对右值添加引用，比如： 123int num = 10;int &amp;b = num; //正确int &amp;c = 10; //错误 因此被称为左值引用。但是可以使用常量左值引用来操作右值，比如： 123int num = 10;const int &amp;b = num;const int &amp;c = 10; 但是带来的新问题是无法对右值进行修改。为此C++11引入了一个新标准，称为右值引用，用“&amp;&amp;”表示。和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化，比如： 1234567891011int&amp;&amp; a = 1; //实质上就是将不具名(匿名)变量取了个别名int b = 1;int &amp;&amp; c = b; //编译错误！ 不能将一个左值复制给一个右值引用class A &#123;public: int a;&#125;;A getTemp() &#123; return A();&#125;A &amp;&amp; a = getTemp(); //getTemp()的返回值是右值（临时变量） getTemp()返回的右值本来在表达式语句结束后，其生命也就该终结了（因为是临时变量），而通过右值引用，该右值又重获新生，其生命期将与右值引用类型变量a的生命期一样，只要a还活着，该右值临时变量将会一直存活下去。实际上就是给那个临时变量取了个名字。 和常量左值引用不同的是，右值引用还可以对右值进行修改，比如： 123int &amp;&amp; a = 10;a = 100;cout &lt;&lt; a &lt;&lt; endl; 移动语义移动语义的引入是指在进行大数据复制的时候，将动态申请的内存空间的所有权直接转让出去，不用进行大量的数据移动，既节省空间又提高效率。 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;class A &#123;public: A() &#123; cout &lt;&lt; &quot;Default construction.&quot; &lt;&lt; endl; &#125; A(const A &amp;a) &#123; cout &lt;&lt; &quot;Copy construction.&quot; &lt;&lt; endl; &#125;&#125;;A ReturnRvalue() &#123; return A(); //返回一个临时对象&#125;void RefTransfer(const A&amp; a) &#123; //...&#125;void ValTransfer(const A a) &#123; //...&#125;int main() &#123; cout &lt;&lt; &quot;pass by value: &quot; &lt;&lt; endl; ValTransfer(ReturnRvalue()); // 应该调用两次拷贝构造函数 cout &lt;&lt; &quot;pass by reference: &quot; &lt;&lt; endl; RefTransfer(ReturnRvalue()); //应该只调用一次拷贝构造函数&#125; 在上面的例子中若采用值传递(调用ValTransfer()函数)应该需要调用2次拷贝构造函数, 一次是在 ReturnRvalue()函数中调用缺省构造函数构造一个临时对象 A, 而返回时则会调用拷贝构造函数生成一个临时对象, 在进行值传递时, 又会讲这个对象拷贝给函数的参数变量 a。而进行引用传递时(调用RefTransfer()函数) 则接收一个右值, 即将ReturnRvalue()生成的右值临时对象直接变成常量左值引用, 不需要拷贝。 注: C++中使用拷贝构造函数包括一下三种情况： 函数调用时, 将对象当做调用的参数， 函数返回时，返回的对象将从函数栈区复制一份到函数的返回区， 使用一个对象初始化另一个对象时也会调用拷贝构造函数。 但实际上如果编译器实现(开启)了返回值优化(RVO/NRVO, RVO, Return Value Optimization 返回值优化，或者NRVO， Named Return Value Optimization), 编译器将ReturnRvalue()内部生成的这个对象，与返回的临时对象, 以及函数的形参优化成了一个对象，避免了拷贝, 而不需要调用拷贝构造函数。 RVO的机制允许函数使用父堆栈以避免赋值, 但添加 if-else 语句后编译器无法确定函数将要返回哪一个对象, 此时还是会调用拷贝构造函数。 1234567891011A ReturnRvalue(int n)&#123; A local_a ，another_a; if （n &gt; 2 ）&#123; return local_a; &#125; else &#123; return another_a ; &#125;&#125;int main()&#123; ValTransfer(ReturnRvalue(1)); // 此时将会调用两次构造函数&#125; 要实现移动语义就必须增加两个函数：移动构造函数和移动赋值构造函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;string&gt;#include &lt;iostream&gt;class A &#123;public: std::string s; A() : s(&quot;test&quot;) &#123; std::cout &lt;&lt; &quot;Default Constructor!\\n&quot;; &#125; A(const A&amp; a) : s(a.s) &#123; std::cout &lt;&lt; &quot;Copy Constructor!\\n&quot;; &#125; A(A&amp;&amp; a) : s(std::move(a.s)) &#123; std::cout &lt;&lt; &quot;Move Constructor!\\n&quot;; &#125; A&amp; operator=(const A&amp; other) &#123; s = other.s; std::cout &lt;&lt; &quot;Copy Assigned!\\n&quot;; return *this; &#125; A&amp; operator=(A&amp;&amp; other) &#123; s = std::move(other.s); std::cout &lt;&lt; &quot;Move Assigned\\n&quot;; return *this; &#125;&#125;;A ReturnRValue() &#123; return A(); &#125;int main()&#123; A a1, a2; std::cout &lt;&lt; &quot;从右值临时量移动赋值:&quot; &lt;&lt; std::endl; a1 = ReturnRValue(); // 从右值临时量移动赋值 std::cout &lt;&lt; &quot;从左值移动赋值, 调用移动c操作符:&quot; &lt;&lt; std::endl; a2 = std::move(a1); // 从左值移动赋值, 调用移动c操作符 std::cout &lt;&lt; &quot;调用复制构造函数:&quot; &lt;&lt; std::endl; A a3(a2); // 调用复制构造函数 std::cout &lt;&lt; &quot;移动前a3的值为:&quot; &lt;&lt; std::endl; std::cout &lt;&lt; a3.s &lt;&lt; std::endl; std::cout &lt;&lt; &quot;调用移动构造函数:&quot; &lt;&lt; std::endl; A a4(std::move(a3)); // 调用移动构造函数 std::cout &lt;&lt; &quot;移动后a3的值为:&quot; &lt;&lt; std::endl; std::cout &lt;&lt; a3.s &lt;&lt; std::endl; std::cout &lt;&lt; &quot;a4的值为:&quot; &lt;&lt; std::endl; std::cout &lt;&lt; a4.s &lt;&lt; std::endl;&#125;/* 输出结果为Default Constructor!Default Constructor!从右值临时量移动赋值:Default Constructor!Move Assigned从左值移动赋值, 调用移动c操作符:Move Assigned调用复制构造函数:Copy Constructor!移动前a3的值为:test调用移动构造函数:Move Constructor!移动后a3的值为:a4的值为:test*/ 可以看到，移动构造函数与拷贝构造函数的区别是，拷贝构造的参数是c是常量左值引用，而移动构造的参数是是右值引用。而移动构造函数与拷贝构造不同，它并不是重新分配一块新的空间，将要拷贝的对象复制过来，而是”偷”了过来，将自己的指针指向别人的资源，然后将别人的指针修改为nullptr，这一步很重要，如果不将别人的指针修改为空，那么临时对象析构的时候就会释放掉这个资源，”偷”也白偷了。有些左值是局部变量，生命周期也很短，能不能也移动而不是拷贝呢？C++11为了解决这个问题，提供了std::move()方法来将左值转换为右值，从而方便应用移动语义。 通用引用（universal references）当右值引用和模板结合的时候，就复杂了。T&amp;&amp;并不一定表示右值引用，它可能是个左值引用又可能是个右值引用。例如： 1234567template&lt;typename T&gt;void f( T&amp;&amp; param)&#123; &#125;f(10); //10是右值int x = 10; //f(x); //x是左值 如果上面的函数模板表示的是右值引用的话，肯定是不能传递左值的，但是事实却是可以。这里的&amp;&amp;是一个未定义的引用类型，称为universal references，它必须被初始化，它是左值引用还是右值引用却决于它的初始化，如果它被一个左值初始化，它就是一个左值引用；如果被一个右值初始化，它就是一个右值引用。 注意：只有当发生自动类型推断时（如函数模板的类型自动推导，或auto关键字），&amp;&amp;才是一个universal references。 如果T被推导为string&amp;，就会发生类似string&amp; &amp;&amp;的情况，对于这种情况，c++11增加了引用折叠的规则，总结如下： 所有的右值引用叠加到右值引用上仍然使一个右值引用。 所有的其他引用类型之间的叠加都将变成左值引用。 所以T&amp; &amp;&amp;其实就被折叠成了个string &amp;，是一个左值引用。 完美转发所谓转发，就是通过一个函数将参数继续转交给另一个函数进行处理，原参数可能是右值，可能是左值，如果还能继续保持参数的原有特征，那么它就是完美的。 1234567891011121314151617181920212223void process(int&amp; i)&#123; cout &lt;&lt; &quot;process(int&amp;):&quot; &lt;&lt; i &lt;&lt; endl;&#125;void process(int&amp;&amp; i)&#123; cout &lt;&lt; &quot;process(int&amp;&amp;):&quot; &lt;&lt; i &lt;&lt; endl;&#125;void myforward(int&amp;&amp; i)&#123; cout &lt;&lt; &quot;myforward(int&amp;&amp;):&quot; &lt;&lt; i &lt;&lt; endl; process(i);&#125;int main()&#123; int a = 0; process(a); //a被视为左值 process(int&amp;):0 process(1); //1被视为右值 process(int&amp;&amp;):1 process(move(a)); //强制将a由左值改为右值 process(int&amp;&amp;):0 myforward(2); //右值经过forward函数转交给process函数，却称为了一个左值， //原因是该右值有了名字 所以是 process(int&amp;):2 myforward(move(a)); // 同上，在转发的时候右值变成了左值 process(int&amp;):0 // forward(a) // 错误用法，右值引用不接受左值&#125; 上面的例子就是不完美转发，而c++中提供了一个std::forward()模板函数解决这个问题。将上面的myforward()函数简单改写一下： 123456void myforward(int&amp;&amp; i)&#123; cout &lt;&lt; &quot;myforward(int&amp;&amp;):&quot; &lt;&lt; i &lt;&lt; endl; process(std::forward&lt;int&gt;(i));&#125;myforward(2); // process(int&amp;&amp;):2 上面修改过后还是不完美转发，myforward()函数能够将右值转发过去，但是并不能够转发左值，解决办法就是借助universal references通用引用类型和std::forward()模板函数共同实现完美转发： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;void RunCode(int &amp;&amp;m) &#123; cout &lt;&lt; &quot;rvalue ref&quot; &lt;&lt; endl;&#125;void RunCode(int &amp;m) &#123; cout &lt;&lt; &quot;lvalue ref&quot; &lt;&lt; endl;&#125;void RunCode(const int &amp;&amp;m) &#123; cout &lt;&lt; &quot;const rvalue ref&quot; &lt;&lt; endl;&#125;void RunCode(const int &amp;m) &#123; cout &lt;&lt; &quot;const lvalue ref&quot; &lt;&lt; endl;&#125;// 这里利用了universal references，如果写T&amp;,就不支持传入右值，而写T&amp;&amp;，既能支持左值，又能支持右值template&lt;typename T&gt;void perfectForward(T &amp;&amp; t) &#123; RunCode(forward&lt;T&gt; (t));&#125;template&lt;typename T&gt;void notPerfectForward(T &amp;&amp; t) &#123; RunCode(t);&#125;int main()&#123; int a = 0; int b = 0; const int c = 0; const int d = 0; notPerfectForward(a); // lvalue ref notPerfectForward(move(b)); // lvalue ref notPerfectForward(c); // const lvalue ref notPerfectForward(move(d)); // const lvalue ref cout &lt;&lt; endl; perfectForward(a); // lvalue ref perfectForward(move(b)); // rvalue ref perfectForward(c); // const lvalue ref perfectForward(move(d)); // const rvalue ref&#125; 上面的代码测试结果表明，在universal references和std::forward的合作下，能够完美的转发这4种类型。 emplace_back减少内存拷贝和移动我们之前使用vector一般都喜欢用push_back()，由上文可知容易发生无谓的拷贝，解决办法是为自己的类增加移动拷贝和赋值函数，但其实还有更简单的办法！就是使用emplace_back()替换push_back()，如下面的例子： 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;class A &#123;public: A(int i)&#123;// cout &lt;&lt; &quot;A()&quot; &lt;&lt; endl; str = to_string(i); &#125; ~A()&#123;&#125; A(const A&amp; other): str(other.str)&#123; cout &lt;&lt; &quot;A&amp;&quot; &lt;&lt; endl; &#125;public: string str;&#125;;int main()&#123; vector&lt;A&gt; vec; vec.reserve(10); for(int i=0;i&lt;10;i++)&#123; vec.push_back(A(i)); //调用了10次拷贝构造函数// vec.emplace_back(i); //一次拷贝构造函数都没有调用过 &#125; for(int i=0;i&lt;10;i++) cout &lt;&lt; vec[i].str &lt;&lt; endl;&#125; 可以看到效果是明显的，虽然没有测试时间，但是确实可以减少拷贝。emplace_back()可以直接通过构造函数的参数构造对象，但前提是要有对应的构造函数。 对于map和set，可以使用emplace()。基本上emplace_back()对应push_back(), emplce()对应insert()。 移动语义对swap()函数的影响也很大，之前实现swap可能需要三次内存拷贝，而有了移动语义后，就可以实现高性能的交换函数了。 1234567template &lt;typename T&gt;void swap(T&amp; a, T&amp; b)&#123; T tmp(std::move(a)); a = std::move(b); b = std::move(tmp);&#125; 如果T是可移动的，那么整个操作会很高效，如果不可移动，那么就和普通的交换函数是一样的，不会发生什么错误，很安全。 总结 由两种值类型，左值和右值。 有三种引用类型，左值引用、右值引用和通用引用。左值引用只能绑定左值，右值引用只能绑定右值，通用引用由初始化时绑定的值的类型确定。 左值和右值是独立于他们的类型的，右值引用可能是左值可能是右值，如果这个右值引用已经被命名了，他就是左值。 引用折叠规则：所有的右值引用叠加到右值引用上仍然是一个右值引用，其他引用折叠都为左值引用。当T&amp;&amp;为模板参数时，输入左值，它将变成左值引用，输入右值则变成具名的右值应用。 移动语义可以减少无谓的内存拷贝，要想实现移动语义，需要实现移动构造函数和移动赋值函数。 std::move()将一个左值转换成一个右值，强制使用移动拷贝和赋值函数，这个函数本身并没有对这个左值什么特殊操作。 std::forward()和 universal references 通用引用共同实现完美转发。 用empalce_back()替换push_back()增加性能。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://wangtianyang.com/tags/C/"}]},{"title":"【读书笔记】《设计数据密集型应用》","slug":"【读书笔记】设计数据密集型应用","date":"2022-09-02T06:05:07.000Z","updated":"2023-01-06T13:31:22.980Z","comments":true,"path":"2022/09/02/【读书笔记】设计数据密集型应用/","link":"","permalink":"https://wangtianyang.com/2022/09/02/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8/","excerpt":"设计数据密集型应用-中文翻译 数据系统的基石可靠性、可扩展性、可维护性数据密集型应用通常由标准组件构建而成，标准组件提供了很多通用的功能；例如，许多应用程序都需要： 存储数据，以便自己或其他应用程序之后能再次找到 ——数据库（database） 记住开销昂贵操作的结果，加快读取速度——缓存（cache） 允许用户按关键字搜索数据，或以各种方式对数据进行过滤——搜索索引（search indexes） 向其他进程发送消息，进行异步处理——流处理（stream processing） 定期处理累积的大批量数据——批处理（batch processing） 数据系统（data system）分为数据库、消息队列、缓存等，但是近年来边界越来越模糊，数据存储可以被当成消息队列用（Redis），消息队列则带有类似数据库的持久保证（Apache Kafka）。 数据系统设计三大指标： 可靠性（Reliability） 系统在困境（adversity）（硬件故障、软件故障、人为错误）中仍可正常工作（正确完成功能，并能达到期望的性能水准）。 可扩展性（Scalability） 有合理的办法应对系统的增长（数据量、流量、复杂性）。 可维护性（Maintainability） 许多不同的人（工程师、运维）在不同的生命周期，都能高效地在系统上工作（使系统保持现有行为，并适应新的应用场景）。","text":"设计数据密集型应用-中文翻译 数据系统的基石可靠性、可扩展性、可维护性数据密集型应用通常由标准组件构建而成，标准组件提供了很多通用的功能；例如，许多应用程序都需要： 存储数据，以便自己或其他应用程序之后能再次找到 ——数据库（database） 记住开销昂贵操作的结果，加快读取速度——缓存（cache） 允许用户按关键字搜索数据，或以各种方式对数据进行过滤——搜索索引（search indexes） 向其他进程发送消息，进行异步处理——流处理（stream processing） 定期处理累积的大批量数据——批处理（batch processing） 数据系统（data system）分为数据库、消息队列、缓存等，但是近年来边界越来越模糊，数据存储可以被当成消息队列用（Redis），消息队列则带有类似数据库的持久保证（Apache Kafka）。 数据系统设计三大指标： 可靠性（Reliability） 系统在困境（adversity）（硬件故障、软件故障、人为错误）中仍可正常工作（正确完成功能，并能达到期望的性能水准）。 可扩展性（Scalability） 有合理的办法应对系统的增长（数据量、流量、复杂性）。 可维护性（Maintainability） 许多不同的人（工程师、运维）在不同的生命周期，都能高效地在系统上工作（使系统保持现有行为，并适应新的应用场景）。 可靠性人们对可靠软件的典型期望包括： 应用程序表现出用户所期望的功能。 允许用户犯错，允许用户以出乎意料的方式使用软件。 在预期的负载和数据量下，性能满足要求。 系统能防止未经授权的访问和滥用。 硬件故障硬盘的平均无故障时间（MTTF mean time to failure） 约为10到50年。因此从数学期望上讲，在拥有10000个磁盘的存储集群上，平均每天会有1个磁盘出故障。 为了减少系统的故障率，第一反应通常都是增加单个硬件的冗余度，例如：磁盘可以组建RAID，服务器可能有双路电源和热插拔CPU，数据中心可能有电池和柴油发电机作为后备电源，某个组件挂掉时冗余组件可以立刻接管。 但是随着数据量和应用计算需求的增加，越来越多的应用开始大量使用机器，这会相应地增加硬件故障率。此外在一些云平台（如亚马逊网络服务（AWS, Amazon Web Services））中，虚拟机实例不可用却没有任何警告也是很常见的，因为云平台的设计就是优先考虑灵活性（flexibility）和弹性（elasticity），而不是单机可靠性。 软件错误包括： 接受特定的错误输入，便导致所有应用服务器实例崩溃的BUG。例如2012年6月30日的闰秒，由于Linux内核中的一个错误，许多应用同时挂掉了。 失控进程会占用一些共享资源，包括CPU时间、内存、磁盘空间或网络带宽。 系统依赖的服务变慢，没有响应，或者开始返回错误的响应。 级联故障，一个组件中的小故障触发另一个组件中的故障，进而触发更多的故障。 解决方案： 仔细考虑系统中的假设和交互； 彻底的测试； 进程隔离； 允许进程崩溃并重启； 测量、监控并分析生产环境中的系统行为。如果系统能够提供一些保证（例如在一个消息队列中，进入与发出的消息数量相等），那么系统就可以在运行时不断自检，并在出现差异（discrepancy）时报警。 人为错误一项关于大型互联网服务的研究发现，运维配置错误是导致服务中断的首要原因，而硬件故障（服务器或网络）仅导致了10-25％的服务中断。 办法： 以最小化犯错机会的方式设计系统。例如，精心设计的抽象、API和管理后台使做对事情更容易，搞砸事情更困难。但如果接口限制太多，人们就会忽略它们的好处而想办法绕开，很难正确把握这种微妙的平衡。 将人们最容易犯错的地方与可能导致失效的地方解耦（decouple）。特别是提供一个功能齐全的非生产环境沙箱（sandbox），使人们可以在不影响真实用户的情况下，使用真实数据安全地探索和实验。 在各个层次进行彻底的测试，从单元测试、全系统集成测试到手动测试。自动化测试易于理解，已经被广泛使用，特别适合用来覆盖正常情况中少见的边缘场景（corner case）。 允许从人为错误中简单快速地恢复，以最大限度地减少失效情况带来的影响。 例如，快速回滚配置变更，分批发布新代码（以便任何意外错误只影响一小部分用户），并提供数据重算工具（以备旧的计算出错）。配置详细和明确的监控，比如性能指标和错误率。 在其他工程学科中这指的是遥测（telemetry）。 （一旦火箭离开了地面，遥测技术对于跟踪发生的事情和理解失败是至关重要的。）监控可以向我们发出预警信号，并允许我们检查是否有任何地方违反了假设和约束。当出现问题时，指标数据对于问题诊断是非常宝贵的。 良好的管理实践与充分的培训——一个复杂而重要的方面，但超出了本书的范围。 可扩展性描述负载负载可以用一些称为 负载参数（load parameters） 的数字来描述。参数的最佳选择取决于系统架构，它可能是每秒向Web服务器发出的请求、数据库中的读写比率、聊天室中同时活跃的用户数量、缓存命中率或其他东西。 以推特为例。推特的两个主要业务是： 发布推文 用户可以向其粉丝发布新消息（平均 4.6k请求/秒，峰值超过 12k请求/秒）。 主页时间线 用户可以查阅他们关注的人发布的推文（300k请求/秒）。 处理每秒12,000次写入（发推文的速率峰值）还是很简单的。然而推特的扩展性挑战并不是主要来自推特量，而是来自扇出[1]（fan-out）——每个用户关注了很多人，也被很多人关注。 大体上讲，这一对操作有两种实现方式。 发布推文时，只需将新推文插入全局推文集合即可。当一个用户请求自己的主页时间线时，首先查找他关注的所有人，查询这些被关注用户发布的推文并按时间顺序合并。 为每个用户的主页时间线维护一个缓存，就像每个用户的推文收件箱。 当一个用户发布推文时，查找所有关注该用户的人，并将新的推文插入到每个主页时间线缓存中。 因此读取主页时间线的请求开销很小，因为结果已经提前计算好了。 推特现行方案是2+1：名流发推走1，普通用户发推走2。 描述性能一旦系统的负载被描述好，就可以研究当负载增加会发生什么。我们可以从两种角度来看： 增加负载参数并保持系统资源（CPU、内存、网络带宽等）不变时，系统性能将受到什么影响？ 增加负载参数并希望保持性能不变时，需要增加多少系统资源？ 如何描述系统性能： 对于Hadoop这样的批处理系统，通常关心的是吞吐量（throughput），即每秒可以处理的记录数量，或者在特定规模数据集上运行作业的总时间iii。对于在线系统，通常更重要的是服务的响应时间（response time），即客户端发送请求到接收响应之间的时间。 对于响应时间，通常来说，比起平均值，我们用**百分位点（percentiles）会更好。​ 为了弄清异常值有多糟糕，可以看看更高的百分位点，例如第95、99和99.9百分位点（缩写为p95，p99和p999）。它们意味着95％，99％或99.9％的请求响应时间要比该阈值快，例如：如果第95百分位点响应时间是1.5秒，则意味着100个请求中的95个响应时间快于1.5秒，而100个请求中的5个响应时间超过1.5秒。 响应时间的高百分位点（也称为尾部延迟（tail latencies））非常重要，因为它们直接影响用户的服务体验。例如亚马逊在描述内部服务的响应时间要求时以99.9百分位点为准，即使它只影响一千个请求中的一个。这是因为请求响应最慢的客户往往也是数据最多的客户，也可以说是最有价值的客户 —— 因为他们掏钱了。 应对负载的方法 纵向扩展（scaling up），也称垂直扩展（vertical scaling）：转向更强大的机器 横向扩展（scaling out），也称水平扩展（horizontal scaling）：将负载分布到多台小机器上 可维护性我们将特别关注软件系统的三个设计原则： 可操作性（Operability） 便于运维团队保持系统平稳运行。 简单性（Simplicity） 从系统中消除尽可能多的复杂度（complexity），使新工程师也能轻松理解系统。（注意这和用户接口的简单性不一样。） 可演化性（evolability） 使工程师在未来能轻松地对系统进行更改，当需求变化时为新应用场景做适配。也称为可扩展性（extensibility），可修改性（modifiability）或可塑性（plasticity）。 本章小结可靠性（Reliability）意味着即使发生故障，系统也能正常工作。故障可能发生在硬件（通常是随机的和不相关的），软件（通常是系统性的Bug，很难处理），和人类（不可避免地时不时出错）。 容错技术 可以对终端用户隐藏某些类型的故障。 ​可扩展性（Scalability）意味着即使在负载增加的情况下也有保持性能的策略。为了讨论可扩展性，我们首先需要定量描述负载和性能的方法。我们简要了解了推特主页时间线的例子，介绍描述负载的方法，并将响应时间百分位点作为衡量性能的一种方式。在可扩展的系统中可以添加 处理容量（processing capacity） 以在高负载下保持可靠。 ​可维护性（Maintainability）有许多方面，但实质上是关于工程师和运维团队的生活质量的。良好的抽象可以帮助降低复杂度，并使系统易于修改和适应新的应用场景。良好的可操作性意味着对系统的健康状态具有良好的可见性，并拥有有效的管理手段。 数据模型与查询语言关系模型与文档模型SQL基于Edgar Codd在1970年提出的关系模型：数据被组织成关系（SQL中称作表），其中每个关系是元组（SQL中称作行)的无序集合。 NoSQL的诞生 最初“NoSQL”只是一个醒目的Twitter标签，不涉及任何特定的技术，后来才被追述性地重新解释为Not Only SQL。 采用NoSQL数据库的背后有几个驱动因素，其中包括： 需要比关系数据库更好的可扩展性，包括非常大的数据集或非常高的写入吞吐量。 相比商业数据库产品，免费和开源软件更受偏爱。 关系模型不能很好地支持一些特殊的查询操作。 受挫于关系模型的限制性，渴望一种更具多动态性与表现力的数据模型 在可预见的未来，关系数据库似乎可能会继续与各种非关系数据库一起使用 - 这种想法有时也被称为混合持久化（polyglot persistence）。 对象关系不匹配目前大多数应用程序开发都使用面向对象的编程语言来开发，这导致了对SQL数据模型的普遍批评：如果数据存储在关系表中，那么需要一个笨拙的转换层，处于应用程序代码中的对象和表，行，列的数据库模型之间。模型之间的不连贯有时被称为阻抗不匹配（impedance mismatch）[2]。 像ActiveRecord和Hibernate这样的对象关系映射（ORM object-relational mapping）框架可以减少这个转换层所需的样板代码的数量，但是它们不能完全隐藏这两个模型之间的差异。 对于一个像简历这样自包含文档的数据结构而言，JSON表示是非常合适的。JSON比XML更简单。面向文档的数据库（如MongoDB，RethinkDB，CouchDB和Espresso）支持这种数据模型。 多对一和多对多的关系使用ID的好处是，ID对人类没有任何意义，因而永远不需要改变：ID可以保持不变，即使它标识的信息发生变化。任何对人类有意义的东西都可能需要在将来某个时候改变——如果这些信息被复制，所有的冗余副本都需要更新。这会导致写入开销，也存在不一致的风险（一些副本被更新了，还有些副本没有被更新）。去除此类重复是数据库规范化（normalization）[3]的关键思想。 不幸的是，对这些数据进行规范化需要多对一的关系（许多人生活在一个特定的地区，许多人在一个特定的行业工作），这与文档模型不太吻合。在关系数据库中，通过ID来引用其他表中的行是正常的，因为连接很容易。在文档数据库中，一对多树结构没有必要用连接，对连接的支持通常很弱。 文档数据库是否在重蹈覆辙？如何最好地在数据库中表示多对多关系。有一个类似文档数据库而又古老的数据模型，称为层次模型（hierarchical model），他也同文档数据库一样能良好处理一对多的关系，但是很难应对多对多的关系，并且不支持连接。当时人们提出了两种解决方案，分别是关系模型（relational model）（它变成了SQL，统治了世界）和网络模型（network model）（最初很受关注，但最终变得冷门）。 网络模型网络模型由一个称为数据系统语言会议（CODASYL）的委员会进行了标准化，并被数个不同的数据库商实现；它也被称为CODASYL模型。 CODASYL模型是层次模型的推广。在层次模型的树结构中，每条记录只有一个父节点；在网络模式中，每条记录可能有多个父节点。 网络模型中记录之间的链接不是外键，而更像编程语言中的指针（同时仍然存储在磁盘上）。访问记录的唯一方法是跟随从根记录起沿这些链路所形成的路径。这被称为访问路径（access path）。 最简单的情况下，访问路径类似遍历链表：从列表头开始，每次查看一条记录，直到找到所需的记录。但在多对多关系的情况中，数条不同的路径可以到达相同的记录，网络模型的程序员必须跟踪这些不同的访问路径。 关系模型相比之下，关系模型做的就是将所有的数据放在光天化日之下：一个关系（表）只是一个元组（行）的集合，仅此而已。如果你想读取数据，它没有迷宫似的嵌套结构，也没有复杂的访问路径。你可以选中符合任意条件的行，读取表中的任何或所有行。你可以通过指定某些列作为匹配关键字来读取特定行。你可以在任何表中插入一个新的行，而不必担心与其他表的外键关系。 与文档数据库相比在一个方面，文档数据库还原为层次模型：在其父记录中存储嵌套记录，即一对多关系，而不是在单独的表中。 但是，在表示多对一和多对多的关系时，关系数据库和文档数据库并没有根本的不同：在这两种情况下，相关项目都被一个唯一的标识符引用，这个标识符在关系模型中被称为外键，在文档模型中称为文档引用。该标识符在读取时通过连接或后续查询来解析。迄今为止，文档数据库没有走CODASYL的老路。 关系型数据库与文档数据库在今日的对比支持文档数据模型的主要论据是架构灵活性，因局部性而拥有更好的性能，以及对于某些应用程序而言更接近于应用程序使用的数据结构。关系模型通过为连接提供更好的支持以及支持多对一和多对多的关系来反击。 哪个数据模型更方便写代码？取决于业务需求是一对多还是多对多 文档模型中的架构灵活性文档数据库有时称为无模式（schemaless），但这具有误导性，因为读取数据的代码通常假定某种结构——即存在隐式模式，但不由数据库强制执行。一个更精确的术语是读时模式（schema-on-read）（数据的结构是隐含的，只有在数据被读取时才被解释），相应的是写时模式（schema-on-write）（传统的关系数据库方法中，模式明确，且数据库确保所有的数据都符合其模式）。 读时模式类似于编程语言中的动态（运行时）类型检查，而写时模式类似于静态（编译时）类型检查。就像静态和动态类型检查的相对优点具有很大的争议性一样【22】，数据库中模式的强制性是一个具有争议的话题，一般来说没有正确或错误的答案。 查询的数据局部性文档通常以单个连续字符串形式进行存储，编码为JSON，XML或其二进制变体（如MongoDB的BSON）。如果应用程序经常需要访问整个文档（例如，将其渲染至网页），那么存储局部性会带来性能优势。 文档和关系数据库的融合自2000年代中期以来，大多数关系数据库系统（MySQL除外）都已支持XML。这包括对XML文档进行本地修改的功能，以及在XML文档中进行索引和查询的功能。这允许应用程序使用那种与文档数据库应当使用的非常类似的数据模型。 从9.3版本开始的PostgreSQL，从5.7版本开始的MySQL以及从版本10.5开始的IBM DB2 [30]也对JSON文档提供了类似的支持级别。鉴于用在Web APIs的JSON流行趋势，其他关系数据库很可能会跟随他们的脚步并添加JSON支持。 在文档数据库中，RethinkDB在其查询语言中支持类似关系的连接，一些MongoDB驱动程序可以自动解析数据库引用（有效地执行客户端连接，尽管这可能比在数据库中执行的连接慢，需要额外的网络往返，并且优化更少）。 数据查询语言SQL是一种 声明式 查询语言，而IMS和CODASYL使用 命令式 代码来查询数据库。 很多编程语言都是命令式语言，命令式语言需要关心查询的实现方式，而声明式语言只需要给出想要查询的数据需要满足的条件，而不必在乎实现细节。 MapReduce查询MapReduce既不是一个声明式的查询语言，也不是一个完全命令式的查询API，而是处于两者之间：查询的逻辑用代码片断来表示，这些代码片段会被处理框架重复性调用。它基于map（也称为collect）和reduce（也称为fold或inject）函数，两个函数存在于许多函数式编程语言中。 1.扇出：从电子工程学中借用的术语，它描述了输入连接到另一个门输出的逻辑门数量。 输出需要提供足够的电流来驱动所有连接的输入。 在事务处理系统中，我们使用它来描述为了服务一个传入请求而需要执行其他服务的请求数量。 ↩2.一个从电子学借用的术语。每个电路的输入和输出都有一定的阻抗（交流电阻）。当你将一个电路的输出连接到另一个电路的输入时，如果两个电路的输出和输入阻抗匹配，则连接上的功率传输将被最大化。阻抗不匹配会导致信号反射及其他问题 ↩3.关于关系模型的文献区分了几种不同的规范形式，但这些区别几乎没有实际意义。一个经验法则是，如果重复存储了可以存储在一个地方的值，则模式就不是规范化（normalized）的。 ↩","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://wangtianyang.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://wangtianyang.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"【Golang】语言特性","slug":"【Golang】语言特性","date":"2022-05-23T09:46:51.000Z","updated":"2023-01-06T13:44:16.456Z","comments":true,"path":"2022/05/23/【Golang】语言特性/","link":"","permalink":"https://wangtianyang.com/2022/05/23/%E3%80%90Golang%E3%80%91%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/","excerpt":"","text":"","categories":[],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://wangtianyang.com/tags/Golang/"}]},{"title":"【读书笔记】《Linux-Unix系统编程手册》","slug":"【读书笔记】《Linux-Unix系统编程手册》","date":"2022-05-11T10:04:57.000Z","updated":"2023-01-06T13:30:51.090Z","comments":true,"path":"2022/05/11/【读书笔记】《Linux-Unix系统编程手册》/","link":"","permalink":"https://wangtianyang.com/2022/05/11/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8ALinux-Unix%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E6%89%8B%E5%86%8C%E3%80%8B/","excerpt":"","text":"","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://wangtianyang.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://wangtianyang.com/tags/Linux/"}]},{"title":"【LeetCode刷题笔记】955.删列造序II","slug":"【LeetCode刷题笔记】955-删列造序II","date":"2022-04-18T04:35:46.000Z","updated":"2023-01-06T13:42:34.958Z","comments":true,"path":"2022/04/18/【LeetCode刷题笔记】955-删列造序II/","link":"","permalink":"https://wangtianyang.com/2022/04/18/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91955-%E5%88%A0%E5%88%97%E9%80%A0%E5%BA%8FII/","excerpt":"题目955. 删列造序 II 给定由 n 个字符串组成的数组 strs，其中每个字符串长度相等。 选取一个删除索引序列，对于 strs 中的每个字符串，删除对应每个索引处的字符。 比如，有 strs = [“abcdef”, “uvwxyz”]，删除索引序列 {0, 2, 3}，删除后 strs 为[“bef”, “vyz”]。 假设，我们选择了一组删除索引 answer，那么在执行删除操作之后，最终得到的数组的元素是按 字典序（strs[0] &lt;= strs[1] &lt;= strs[2] … &lt;= strs[n - 1]）排列的，然后请你返回 answer.length 的最小可能值。 示例 1： 123456输入：strs = [&quot;ca&quot;,&quot;bb&quot;,&quot;ac&quot;]输出：1解释： 删除第一列后，strs = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]。现在 strs 中元素是按字典排列的 (即，strs[0] &lt;= strs[1] &lt;= strs[2])。我们至少需要进行 1 次删除，因为最初 strs 不是按字典序排列的，所以答案是 1。 示例 2： 123456输入：strs = [&quot;xc&quot;,&quot;yb&quot;,&quot;za&quot;]输出：0解释：strs 的列已经是按字典序排列了，所以我们不需要删除任何东西。注意 strs 的行不需要按字典序排列。也就是说，strs[0][0] &lt;= strs[0][1] &lt;= ... 不一定成立。 示例 3： 1234输入：strs = [&quot;zyx&quot;,&quot;wvu&quot;,&quot;tsr&quot;]输出：3解释：我们必须删掉每一列。 提示： n == strs.length 1 &lt;= n &lt;= 100 1 &lt;= strs[i].length &lt;= 100 strs[i] 由小写英文字母组成","text":"题目955. 删列造序 II 给定由 n 个字符串组成的数组 strs，其中每个字符串长度相等。 选取一个删除索引序列，对于 strs 中的每个字符串，删除对应每个索引处的字符。 比如，有 strs = [“abcdef”, “uvwxyz”]，删除索引序列 {0, 2, 3}，删除后 strs 为[“bef”, “vyz”]。 假设，我们选择了一组删除索引 answer，那么在执行删除操作之后，最终得到的数组的元素是按 字典序（strs[0] &lt;= strs[1] &lt;= strs[2] … &lt;= strs[n - 1]）排列的，然后请你返回 answer.length 的最小可能值。 示例 1： 123456输入：strs = [&quot;ca&quot;,&quot;bb&quot;,&quot;ac&quot;]输出：1解释： 删除第一列后，strs = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]。现在 strs 中元素是按字典排列的 (即，strs[0] &lt;= strs[1] &lt;= strs[2])。我们至少需要进行 1 次删除，因为最初 strs 不是按字典序排列的，所以答案是 1。 示例 2： 123456输入：strs = [&quot;xc&quot;,&quot;yb&quot;,&quot;za&quot;]输出：0解释：strs 的列已经是按字典序排列了，所以我们不需要删除任何东西。注意 strs 的行不需要按字典序排列。也就是说，strs[0][0] &lt;= strs[0][1] &lt;= ... 不一定成立。 示例 3： 1234输入：strs = [&quot;zyx&quot;,&quot;wvu&quot;,&quot;tsr&quot;]输出：3解释：我们必须删掉每一列。 提示： n == strs.length 1 &lt;= n &lt;= 100 1 &lt;= strs[i].length &lt;= 100 strs[i] 由小写英文字母组成 题解贪心贪心贪心。注意审题，[“a”, “a”, “a”] 也是符合题意的。 我们把每个字符串当作一行，所有字符串的同一索引当作一列。则原题可以转换为删除最少的列，再从贪心算法的角度出发，转换成保留最多的列。 如果当前列需要判断，则分为下面三种情况： 如果strs[i][j] &lt; strs[i-1][j]，此列删除； 如果strs[i][j] &gt;= strs[i-1][j]，此列保留。 那么如何知道当前列需不需要判断呢？当然要从前面几列出发： 如果strs[i][j] &lt; strs[i-1][j]或者strs[i][j] &gt; strs[i-1][j]，后面的列肯定不用判断； 如果strs[i][j] == strs[i-1][j]，那么还需要在后面的列判断。 所以我们还需要建立一个数组来判断当前列是否需要判断。 代码12345678910111213141516171819202122232425class Solution &#123;public: int minDeletionSize(vector&lt;string&gt;&amp; strs) &#123; int m = strs.size(), n = strs[0].size(); vector&lt;bool&gt; pre(m, true); vector&lt;bool&gt; cur; int res = 0; for (int i = 0; i &lt; n; ++i) &#123; cur = pre; int j = 1; for (; j &lt; m; ++j) &#123; if (cur[j]) &#123; if (strs[j][i] &lt; strs[j-1][i]) &#123; ++res; break; &#125; else if (strs[j][i] &gt; strs[j-1][i]) &#123; cur[j] = false; &#125; &#125; &#125; if (j==m) pre = cur; &#125; return res; &#125;&#125;;","categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://wangtianyang.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://wangtianyang.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【科研笔记】Copula函数","slug":"【科研笔记】Copula函数","date":"2022-04-17T13:30:44.000Z","updated":"2023-01-06T13:51:14.025Z","comments":true,"path":"2022/04/17/【科研笔记】Copula函数/","link":"","permalink":"https://wangtianyang.com/2022/04/17/%E3%80%90%E7%A7%91%E7%A0%94%E7%AC%94%E8%AE%B0%E3%80%91Copula%E5%87%BD%E6%95%B0/","excerpt":"","text":"前置知识定理6.7及其证明 copula定理及几种类型copula英文维基百科)","categories":[{"name":"科研笔记","slug":"科研笔记","permalink":"https://wangtianyang.com/categories/%E7%A7%91%E7%A0%94%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://wangtianyang.com/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"【面经】阿里暑期二面（2022/04/07）","slug":"【面经】阿里暑期二面（2022-04-07）","date":"2022-04-07T08:54:00.000Z","updated":"2023-01-06T13:50:18.003Z","comments":true,"path":"2022/04/07/【面经】阿里暑期二面（2022-04-07）/","link":"","permalink":"https://wangtianyang.com/2022/04/07/%E3%80%90%E9%9D%A2%E7%BB%8F%E3%80%91%E9%98%BF%E9%87%8C%E6%9A%91%E6%9C%9F%E4%BA%8C%E9%9D%A2%EF%BC%882022-04-07%EF%BC%89/","excerpt":"","text":"一、在linux上用python移动文件时，用的什么方法？（我回答了有时候用shell命令有时候用自带的库）什么时候用shell的命令，什么时候用python的库？ python自带的库也就是shutil，shell命令也就是os.system()； 以shutil.move和os.rename举例： 如果源路径和目标路径位于不同的文件系统或驱动器上，操作系统模块可能无法移动文件，但是shutil.move 会检查源路径和目标路径是否在同一个文件系统上。 检查源路径和目标路径后，如果发现它们不在同一个文件系统中，shutil.move 会先将文件复制到目标。然后它将从源文件中删除该文件。因此，当源路径和目标路径不在同一驱动器或文件系统上时，我们可以说shutil.move 是一种在Python 中移动文件的更智能的方法。 shutil.move 适用于高级函数，而 os.rename 适用于低级函数。 二、进程、线程和协程的区别？什么情况下用协程什么情况下用线程？为什么python更喜欢用多协程？ 略 线程和协程的区别： 一个线程可以多个协程，一个进程也可以单独拥有多个协程。 线程进程都是同步机制，而协程则是异步。 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态。 线程是抢占式，而协程是非抢占式的，所以需要用户自己释放使用权来切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。 协程并不是取代线程, 而且抽象于线程之上, 线程是被分割的CPU资源, 协程是组织好的代码流程, 协程需要线程来承载运行, 线程是协程的资源, 但协程不会直接使用线程, 协程直接利用的是执行器(Interceptor), 执行器可以关联任意线程或线程池, 可以使当前线程, UI线程, 或新建线程.。 线程是协程的资源。协程通过Interceptor来间接使用线程这个资源。 什么时候用协程： 在传统的J2EE系统中都是基于每个请求占用一个线程去完成完整的业务逻辑（包括事务）。所以系统的吞吐能力取决于每个线程的操作耗时。如果遇到很耗时的I/O行为，则整个系统的吞吐立刻下降，因为这个时候线程一直处于阻塞状态，如果线程很多的时候，会存在很多线程处于空闲状态（等待该线程执行完才能执行），造成了资源应用不彻底。 协程的目的就是当出现长时间的I/O操作时，通过让出目前的协程调度，执行下一个任务的方式，来消除上下文上的开销。 为什么在Python里推荐使用多进程而不是多线程？ python中多进程+协程的使用以及为什么要用它 三、自己对数据库三大范式的理解？什么情况下用哪种范式？ 数据库设计三大范式 四、知道哪些数据结构？什么情况下用数组什么情况下用链表？ 如果你的应用场景是插入/删除很少，查询非常多，用数组； 如果你的应用场景是插入/删除频繁，查询少，用链表。 五、知道哪些排序算法？快排的时间复杂度是多少？最坏情况下时间复杂度和最好情况下时间复杂度分别是多少？快排空间复杂度是多少？快排是稳定的吗？ 十大经典排序算法 排序算法 平均时间复杂度 最好情况 最坏情况 空间复杂度 排序方式 稳定性 冒泡排序 O(n^2) O(n) O(n^2) O(1) 内存 稳定 选择排序 O(n^2) O(n^2) O(n^2) O(1) 内存 不稳定 插入排序 O(n^2) O(n) O(n^2) O(1) 内存 稳定 希尔排序 O(nlogn) O(nlogn) O(n^2) O(1) 内存 不稳定 归并排序 O(nlogn) O(nlogn) O(nlogn) O(n) 外存 稳定 快速排序 O(nlogn) O(nlogn) O(n^2) O(logn) 内存 不稳定 堆排序 O(nlogn) O(nlogn) O(nlogn) O(1) 内存 不稳定 计数排序 O(n+k) O(n+k) O(n+k) O(k) 外存 稳定 桶排序 O(n+k) O(n+k) O(n^2) O(n+k) 外存 稳定 基数排序 O(nk) O(nk) O(nk) O(n+k) 外存 稳定 六、两端锁协议？解决什么问题？ 数据库原理 两段锁协议","categories":[{"name":"面经","slug":"面经","permalink":"https://wangtianyang.com/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[]},{"title":"【面经】阿里暑期一面（2022/04/06）","slug":"【面经】阿里暑期一面（2022-04-06）","date":"2022-04-06T13:25:32.000Z","updated":"2023-01-06T13:50:12.833Z","comments":true,"path":"2022/04/06/【面经】阿里暑期一面（2022-04-06）/","link":"","permalink":"https://wangtianyang.com/2022/04/06/%E3%80%90%E9%9D%A2%E7%BB%8F%E3%80%91%E9%98%BF%E9%87%8C%E6%9A%91%E6%9C%9F%E4%B8%80%E9%9D%A2%EF%BC%882022-04-06%EF%BC%89/","excerpt":"","text":"一、堆和栈哪个更快？ 栈是由编译器自动分配内存，所以更快；堆是程序员动态分配内存，相对更慢 栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放；堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。 二、什么是一级缓存、什么是二级缓存？ 一级缓存一般内置在内核旁边，是与CPU结合最为紧密的高速缓存，可以有效的提高CPU的运行效率。一级缓存越大，CPU的运行效率越高，但受到成本限制，一级缓存的容量都很小。 L2（就是二级）缓存是在独立芯片（有可能是在一个扩展卡上），它的访问速度能比大的主存要快得多。通常一个二级缓存的大小为1024Kb（1Mb）。 三、 栈的具体调用过程、怎么压入弹出的？ C语言下程序的堆栈调用（详细，图示） EBP 和 ESP 详解 四、free的时候怎么确定要释放多少内存？ 先是pop（弹出堆栈）edi,esi,ebx这三个寄存器，然后将ebp给esp，也就是说把刚刚上面开辟的空间收回，然后经过ret跳回至刚刚在main函数处调用函数那儿（现场保护）。（见上面第一个链接） 五、C++14 string实现？如果是不够就申请空间的话 第14篇:C++的string-两手抓的内存分配 六、http用的是tcp还是udp？ tcp。追求可靠。 七、tcp接收方收到乱序的包时，对这个包怎么处理？ 在缓存区里，不会丢弃，直到有序了以后直接排序。 主机每次发送数据时，TCP就给每个数据包分配一个序列号并且在一个特定的时间内等待接收主机 对分配的这个序列号进行确认，如果发送主机在一个特定时间内没有收到接收主机的确认，则发送 主机会重传此数据包。接收主机利用序列号对接收的数据进行确认，以便检测对方发送的数据是否 有丢失或者乱序等，接收主机一旦收到已经顺序化的数据，它就将这些数据按正确的顺序重组成数 据流并传递到高层进行处理。 具体步骤如下: 为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区; 并为每个已发送的数据包启动一个超时定时器; 如在定时器超时之前收到了对方发来的应答信息(可能是对本包的应答，也可以是对本包后 续包的应答)，则释放该数据包占用的缓冲区; 否则，重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。 接收方收到数据包后，先进行CRC校验，如果正确则把数据交给上层协议，然后给发送方发 送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可方在 数据包中捎带过去。 八、怎么从tcp中解出http？ 如何从TCP中提取HTTP报文 从一个HTTP请求来读懂HTTP、TCP协议 九、http1.0和http1.1区别？1.1的header里多了什么？ http/1.0 : 默认不支持长连接，需要设置keep-alive参数指定 强缓存expired、协商缓存last-modified\\if-modified-since 有一定的缺陷 http 1.1 : 默认长连接(keep-alive)，http请求可以复用Tcp连接，但是同一时间只能对应一个http请求(http请 求在一个Tcp中是串行的) 增加了强缓存cache-control、协商缓存etag\\if-none-match 是对http/1 缓存的优化 十、有多个服务器时，怎么确保是正确的服务器接收到了消息？ 十一、muduo用的是什么单例模式？ 十二、epoll水平触发和边缘触发？ 十三、怎么根据有几个核来确定设置几个线程？怎么确定cpu有多少核？ 线程数量和哪些因素有关:CPU，IO、并行、并发 如果是CPU密集型应用，则线程池大小设置为:CPU数目+1 如果是IO密集型应用，则线程池大小设置为:2*CPU数目+1 最佳线程数目 = (线程等待时间与线程CPU时间之比 + 1)* CPU数目 1234567891011# 总核数 = 物理CPU个数 X 每颗物理CPU的核数 # 总逻辑CPU数 = 物理CPU个数 X 每颗物理CPU的核数 X 超线程数# 查看物理CPU个数cat /proc/cpuinfo| grep &quot;physical id&quot;| sort| uniq| wc -l# 查看每个物理CPU中core的个数(即核数)cat /proc/cpuinfo| grep &quot;cpu cores&quot;| uniq# 查看逻辑CPU的个数cat /proc/cpuinfo| grep &quot;processor&quot;| wc -l 十四、linux在哪里查看日志？有几种方法进入插入模式？怎么查找？怎么跳到第一行？怎么跳到最后一行？怎么复制一行？ /var/log 插入模式 按「i」切换进入插入模式「insert mode」，按”i”进入插入模式后是从光标当前位置开始输入文件； 按「a」进入插入模式后，是从目前光标所在位置的下一个位置开始输入文字； 按「o」进入插入模式后，是插入新的一行，从行首开始输入文字。 1234567891011--递归查找目录下含有该字符串的所有文件grep -rn &quot;data_chushou_pay_info&quot; /home/hadoop/nisj/automationDemand/ --查找当前目录下后缀名过滤的文件grep -Rn &quot;data_chushou_pay_info&quot; *.py --当前目录及设定子目录下的符合条件的文件grep -Rn &quot;data_chushou_pay_info&quot; /home/hadoop/nisj/automationDemand/ *.py --结合find命令过滤目录及文件名后缀find /home/hadoop/nisj/automationDemand/ -type f -name &#x27;*.py&#x27;|xargs grep -n &#x27;data_chushou_pay_info&#x27; 跳到文本的最后一行：按“G”,即“shift+g” 跳到第一行的第一个字符：先按两次“g” 复制一行数据数据： 把光标放到要复制的行行首，然后按两下yy字母键； 然后把光标放到要复制到的地方去，按键盘的p字母键 十五、开放题：怎么在http服务端设计一个用户注册系统？ 十六、算法题：LRU","categories":[{"name":"面经","slug":"面经","permalink":"https://wangtianyang.com/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[]},{"title":"【LeetCode刷题笔记】1792.最大平均通过率","slug":"【LeetCode刷题笔记】1792-最大平均通过率","date":"2022-04-05T15:29:01.000Z","updated":"2023-01-06T13:42:24.213Z","comments":true,"path":"2022/04/05/【LeetCode刷题笔记】1792-最大平均通过率/","link":"","permalink":"https://wangtianyang.com/2022/04/05/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%911792-%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E9%80%9A%E8%BF%87%E7%8E%87/","excerpt":"题目1792. 最大平均通过率 一所学校里有一些班级，每个班级里有一些学生，现在每个班都会进行一场期末考试。给你一个二维数组 classes ，其中 classes[i] = [passi, totali] ，表示你提前知道了第 i 个班级总共有 totali 个学生，其中只有 passi 个学生可以通过考试。 给你一个整数 extraStudents ，表示额外有 extraStudents 个聪明的学生，他们 一定 能通过任何班级的期末考。你需要给这 extraStudents 个学生每人都安排一个班级，使得 所有 班级的 平均 通过率 最大 。 一个班级的 通过率 等于这个班级通过考试的学生人数除以这个班级的总人数。平均通过率 是所有班级的通过率之和除以班级数目。 请你返回在安排这 extraStudents 个学生去对应班级后的 最大 平均通过率。与标准答案误差范围在 10-5 以内的结果都会视为正确结果。","text":"题目1792. 最大平均通过率 一所学校里有一些班级，每个班级里有一些学生，现在每个班都会进行一场期末考试。给你一个二维数组 classes ，其中 classes[i] = [passi, totali] ，表示你提前知道了第 i 个班级总共有 totali 个学生，其中只有 passi 个学生可以通过考试。 给你一个整数 extraStudents ，表示额外有 extraStudents 个聪明的学生，他们 一定 能通过任何班级的期末考。你需要给这 extraStudents 个学生每人都安排一个班级，使得 所有 班级的 平均 通过率 最大 。 一个班级的 通过率 等于这个班级通过考试的学生人数除以这个班级的总人数。平均通过率 是所有班级的通过率之和除以班级数目。 请你返回在安排这 extraStudents 个学生去对应班级后的 最大 平均通过率。与标准答案误差范围在 10-5 以内的结果都会视为正确结果。 示例 1： 123输入：classes = [[1,2],[3,5],[2,2]], extraStudents = 2输出：0.78333解释：你可以将额外的两个学生都安排到第一个班级，平均通过率为 (3/4 + 3/5 + 2/2) / 3 = 0.78333 。 示例 2： 12输入：classes = [[2,4],[3,9],[4,5],[2,10]], extraStudents = 4输出：0.53485 提示： 1 &lt;= classes.length &lt;= 105 classes[i].length == 2 1 &lt;= passi &lt;= totali &lt;= 105 1 &lt;= extraStudents &lt;= 105 题解优先队列！！！ 显然，将优秀学生安排到哪一个班级是根据通过率增加量的多少来排序的，也就是 \\frac{x+1}{y+1} - \\frac{x}{y}其中，x、y 分别是班级能通过考试的人数和班级总人数。 那么，我们可以用 priority_queue 来维护一个最大堆。小细节是，可以用匿名函数来优化代码效率。 代码123456789101112131415161718192021222324252627282930class Solution &#123;public: double maxAverageRatio(vector&lt;vector&lt;int&gt;&gt;&amp; classes, int extraStudents) &#123; priority_queue&lt;tuple&lt;double, int, int&gt;&gt; q; auto diff = [](int x, int y) &#123; double res = (double)(x+1)/(y+1) - (double)x/y; return res; &#125;; double res = 0; for (vector&lt;int&gt;&amp; c : classes) &#123; int x = c[0], y = c[1]; double d = diff(x, y); res += (double) x/y; q.emplace(d, x, y); &#125; while (extraStudents &gt; 0) &#123; --extraStudents; auto [d, x, y] = q.top(); res += d; d = diff(x+1, y+1); q.pop(); q.emplace(d, x+1, y+1); &#125; return res/classes.size(); &#125;&#125;;","categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://wangtianyang.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://wangtianyang.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【笔经】美团暑期（2022/04/02）","slug":"【笔经】美团暑期（2022-04-02）","date":"2022-04-02T06:45:12.000Z","updated":"2023-01-06T13:53:18.681Z","comments":true,"path":"2022/04/02/【笔经】美团暑期（2022-04-02）/","link":"","permalink":"https://wangtianyang.com/2022/04/02/%E3%80%90%E7%AC%94%E7%BB%8F%E3%80%91%E7%BE%8E%E5%9B%A2%E6%9A%91%E6%9C%9F%EF%BC%882022-04-02%EF%BC%89/","excerpt":"","text":"双色球桌上有一排球，分为红蓝（用一串字符串表示），你口袋里也有m个蓝球和n个红球，要求桌上的球相邻不同色，请问最少要加多少篮球多少红球？你口袋里的球够不够？不够的话还需要多少红球多少蓝球？ 例： 12输入：rbrrbb, m=2, n=2输出：2 单峰数组给定正整数数组，要求可以分成两部分，前一部分递增，后一部分递减，请问最少需要加多少数？ 例： 123输入：[1, 2, 1, 2, 1]输出：2，变成 [1, 2, 3, 2, 1] 子序列包含问题给定一个字符串a，和另一个字符串b，请问a有多少连续子串的子序列包含b？ 三核CPU最少耗时现在有一个数组，每个元素表示该任务需要多少时间，要求你把所有元素分成三份，使这三份元素中的和的最大值最小。","categories":[{"name":"笔经","slug":"笔经","permalink":"https://wangtianyang.com/categories/%E7%AC%94%E7%BB%8F/"}],"tags":[]},{"title":"中间人伪基站攻击调研","slug":"中间人伪基站攻击调研","date":"2022-03-31T08:55:39.000Z","updated":"2023-01-06T13:38:06.707Z","comments":true,"path":"2022/03/31/中间人伪基站攻击调研/","link":"","permalink":"https://wangtianyang.com/2022/03/31/%E4%B8%AD%E9%97%B4%E4%BA%BA%E4%BC%AA%E5%9F%BA%E7%AB%99%E6%94%BB%E5%87%BB%E8%B0%83%E7%A0%94/","excerpt":"","text":"问题7：防止中间人的伪基站攻击传统伪基站会因为终端服务被拒绝而被识破。但是中间人伪基站在用户终端和网络之间传递消息，对于消息中受保护的部分，它原封不动地传输，但是对于消息中不受保护的部分，他可以随意修改、删除和新增，比如： 预认证流量 MAC/RLC 层消息头 下层控制信息，如缓冲器状态报告 解决方案6：避免用户终端在基站切换期间连接到伪基站（针对问题3）背景通常情况下，5G无线电接入网的基站切换决策是基于终端的测量报告[1]。终端根据同步信号块（SS Block，下称SS块）执行邻区的信号功率测量，SS块携带广播的同步信号和MIB信号，这些信号没有安全保护。假设有一个伪基站C伪造合法基站B的系统信息，服务基站A收到终端的测量报告，其中包括来自C的测量值。基站A会认为终端的测量报告中包括的信息属于基站B，然后可能决定将终端移交给B，结果UE反而连接到伪基站C。 攻击步骤 A：切换前的服务基站，下称源基站； B：想要切换的正确基站，下称目标基站； C：伪基站。 步骤0：终端向源基站（A）报告测量报告。 步骤1：源基站（A）认为来自伪基站（C）的测量符合切换触发阈值，然后源基站（A）用报告的物理小区身份查询邻区小区关系表，并找到目标基站（B）的小区。 步骤2：源基站（A）向目标基站（B）发送切换请求。 步骤3：目标基站（B）做出切换接纳决定，并为终端准备无线电资源。 步骤4：目标基站（B）以切换请求ACK消息进行响应，其中包含所有准备好的无线电资源控制的配置信息。 步骤5：源基站（A）发送切换命令，指示终端切换到目标小区。 步骤6：终端从源小区分离出来。 步骤7：终端试图根据广播的 SS 块信号和 SIB1 在目标小区进行同步和扎营。由于 SS 块信号和 SIB1 没有安全保护，终端无法验证这些信息的真实性。伪基站可以复制目标小区的 SS 块信号和 SIB1，然后以更强的功率发送。最后，终端在假的小区上扎营。 步骤8：终端明文发送 MSG1 到扎营的小区，也就是伪基站C的小区。 步骤9：伪基站以明文形式回应 MSG2，指示终端使用专门的上行链路分配资源来发送下一条上行链路信息。 步骤10：终端使用专门的上行链路分配资源发送切换确认消息。尽管切换确认消息是使用真实的目标基站（B）的AS安全密钥来保护的，但伪基站不需要向终端回复任何确认，以便终端验证接收基站是持有相同AS安全上下文的真实基站。 攻击结果 真正的目标小区没有收到终端的切换确认消息，就认为切换失败。 源小区没有收到来自目标小区的切换上下文释放消息，则判定切换失败。 因为伪小区没有终端的安全上下文，所以终端在未来会发现无线链路失败。但是在此之前，终端已经在伪小区上扎营，伪小区可以向终端发起一些攻击，例如，向终端发送带有假小区重选黑名单的欺骗性 SIBs。 解决思路为了避免这种在切换期间终端连接到伪基站的可能性，该解决方案引入了基于目标基站分配给终端的特定 CSI-RS（信道状态信息参考信号）的二次测量。 具体来说，目标基站（B）在准备阶段为终端分配一个特定的 CSI-RS，并在切换请求ACK消息中携带 CSI-RS 信息。源基站（A）指示终端根据专用 CSI-RS 信息进行第二次测量。只有当第二次测量报告满足触发条件时，源基站（A）才会指示终端进行基站切换。 由于伪基站（C）事先不知道专用的 CSI-RS 信息，因此终端上传的第二次测量报告是用目标基站（B）的真实参考信号测量的。 注：该方案可以选择一直开启或者需要时开启（比如向某个目标基站的切换失败次数超过特定阈值时）。 解决步骤 从第二步开始 步骤2：当源基站（A）的本地配置表明启用了二次测量的功能时，源基站（A）发送带有新指标的切换请求，要求目标基站（B）为终端准备一个定制的CSI-RS。 步骤3：目标基站（B）执行接纳控制并为终端准备基本的无线资源控制配置信息，包括定制的CSI-RS信息。 步骤4：目标基站（B）用切换请求ACK消息响应，其中包含所有准备好的无线资源控制配置信息，包括定制的CSI-RS信息。 步骤5：源基站（A）收到切换请求ACK中的CSI-RS信息，并根据CSI-RS信息请求终端进行第二次测量。 步骤6：源基站（A）向终端发送包括CSI-RS信息的测量任务，同时受到无线资源控制安全上下文的保护。 步骤7：终端对测量任务中指出的专用CSI-RS信号执行第二次测量。 步骤8：终端向源基站（A）上传第二个测量报告。 步骤9：根据第二个测量报告，源基站（A）决定是否继续进行切换。如果第二个测量报告满足切换触发阈值，即目标小区的真实参考信号功率足够强，源基站（A）发送切换命令，指示终端执行切换到目标小区。否则，源基站（A）向目标基站（B）发送切换取消，停止切换程序。 结论CSI-RS用于基站进行测量，它是每个基站特定的参数，由目标无线电接入网分配，并且对每个终端都是不同的。在该解决方案中，CSI-RS是通过加密和完整性保护的RRC测量任务消息提供给UE的，因此，伪基站不能知道这个参数，也不能伪造正确的CSI-RS。因此，终端将测量目标无线电接入网的真实信令，并且不会因伪基站的伪造小区而启动错误的切换。 解决方案18：避免终端在有条件交接期间连接到虚假基站（针对问题3）背景在解决方案6的基础上，提升稳健性，避免乒乓效应[2]。 解决思路该方案提出了与方案6类似的机制来支持有条件的移交，即目标基站（B0给终端分配一个特定的 CSI-RS 来指示终端测量目标基站（B）的真实参考信号，这可以避免终端测量到虚假基站。不同的是，源基站（A）向终端发送门限值以做出切换决定。因此，可以在终端上进行交接决策，也就不需要额外的信令来报告测量的信令，这样可以保证移交的稳健性，同时，这可以避免终端在有条件的移交过程中连接到假基站。 注：该方案可以选择一直开启或者需要时开启（比如向某个目标基站的切换失败次数超过特定阈值时）。 解决步骤 从第一步开始 步骤1：终端进行测量，并向源基站（A）发送包括该特定小区的测量信号1的测量报告。测量的信号可能是伪基站（C）的，他伪造了和目标基站（B）一样的小区。 步骤2：当源基站收到测量报告时，被测信号将触发有条件移交，源gNB（A）用CSI-RS发送CHO请求，要求目标基站（B）为终端准备一个特定的CSI-RS。 步骤3：目标基站（B）执行接纳控制，并为终端准备基本的无线电资源控制配置信息，包括专门的CSI-RS信息。 步骤4：目标基站(B)用CHO请求ACK消息进行响应，其中包含所有准备好的无线电资源控制配置信息（包括专用的CSI-RS信息）。 步骤5：一旦源基站（A）收到条件移交请求ACK中的CSI-RS信息，源基站就会附加切换的阈值。 步骤6：源基站（A）向终端发送包括专用CSI-RS信息和切换阈值的CHO命令，同时受到无线电资源控制安全上下文的保护。 步骤7：终端对CHO命令中指出的专用CSI-RS信号进行第二次测量，并得到测量信号2。 步骤8：根据信号2和切换阈值，终端决定是否继续进行切换。如果信号2满足阈值，意味着目标小区的真实参考信号功率足够强，终端就向目标小区发送切换确认，不增加延迟。否则，信号1可能是伪基站（C）的信号，终端将不会触发交接。因此，终端将不会连接到伪基站。 结论功能同解决方案6，只是第二次测量前，源基站（A）返回给终端的信息中包含了一条切换阈值，这样就可以在终端上决定是否切换（解决方案6要在源基站上决定是否切换）。 解决方案23：加密CRC[3]以避免中间人中继节点（针对问题3、5、7）背景问题7指出：中间人攻击和伪基站是相关但不同的攻击。 攻击者可以在真终端（RUE）和真基站（RBS）之间放置一个中间人中继节点，该节点通常包括一个假基站（FBS）和一个假终端（FUE）。 解决思路加密CRC。 解决步骤步骤0：先在RUE和RBS之间AS安全连接，生成 k_gNB。 步骤1：从 k_gNB 中导出 K_PHYint，RUE 和 RBS 共享这个对称密钥。 步骤2：RUE计算 CRC 值。 步骤3：RUE获得分配的物理资源块的信息来发送传输块，并得出一个唯一标识符，称为 blockID。blockID 在 K_PHYint 的范围内被认为是唯一的。它可以通过与给定的基站通信时，结合所使用的资源的标识符来构建。这些标识符包括： 基站的标识符，如PCI； 在时域，可以包括超帧号、系统帧号、时隙号、OFDM符号标识符、资源块的时间长度； 在频域，可以包括最低频率和所用频段。 步骤4：RUE 结合 blockID、K_PHYint 和 CRC，计算出 CRC’，并用 CRC’ 代替 CRC。 CRC’ = MessageAuthenticationCodeComputation(K_PHYint, CRC|blockID) 步骤5：RBS 在物理资源块中接受信息并得到 blockID。 步骤6：RBS根据收到的传输块计算24位CRC_r值。 步骤7：RBS 结合 blockID、K_PHYint 和 CRC_r，计算出 CRC’_r。 步骤8：RBS检查计算出的 CRC’_r 值是否与收到的 CRC’ 值相同。如果数值不匹配，则拒绝该传输块；如果数值匹配，则接受该传输块，证明其不包含传输错误，且在同一物理资源中传输过，即没有被重放。 步骤9：在这个时间段结束时，RBS 通过检查 CRC’ 检查失败的次数是否超过阈值来确定是否有中间人攻击者存在。假设在10.24秒内可以交换2^10个TB，CRC的长度为24位，这个阈值可以从二项式测试和一个给定的置信度中得出。如果检测到一个中间人攻击者，RBS 会通知终端和网络关于中间人中继节点的存在。 结论本解决方案所提供的重放保护可以通过将blockID视为与通信链路中使用的物理资源相关的新鲜度参数来理解，而中间人由于没有 K_PHYint，就不能加密 CRC’，也就无法验证 CRC。因此可以防止中间人攻击。 但是本方案无法阻止终端在伪基站上扎营。 解决方案25: 检测中间人的伪基站（针对问题3）背景中间人伪基站攻击 解决思路基于终端和基站之间的链路分配资源参数，即终端的SFN（系统帧号）。基站可以比较它分配给终端的SFN和终端报告的SFN，来判断伪基站是否存在。如果存在中间人，那么前者是真基站和伪终端之间的SFN，后者是伪基站和真终端之间的SFN。 解决步骤步骤1：假设终端已经通过伪基站与真基站建立了连接。无线电资源控制（RRC）的安全性已经建立，即所有无线电资源控制消息都受到FBS的保护。 步骤2：为了让终端发送RRC消息（以触发伪基站检测），终端根据当前的RAN程序向伪基站请求资源。假设伪基站分配的SFN参数集由SFN1表示（在本方案中SFN指系统帧号、子帧号、时隙、起始符号以及资源分配消息中的参数，特别是 “k2 “值）。 步骤3.：终端发送一个RRC消息来触发FBS检测。为了避免定义一个新的RRC消息，现有的RRC消息”UEAssistanceInformtion “可以使用一个新的可选元素 “SFN Check “来触发伪基站检测。 步骤4：像往常一样，伪基站打算将RRC消息转发给基站。首先，伪终端需要向基站请求资源。假设基站将分配一组SFN参数，即SFN2给为端口。 步骤5：伪终端根据预定的SFN2将RRC消息转发给基站。 步骤6：一旦收到 “SFN检查 “指示，基站就会存储它分配的SFN2。 步骤7：终端在RRC消息中发送SFN1值（在步骤2中分配）（安全保护不受FBS影响）。为了避免定义一个新的RRC消息，现有的RRC消息 “UEAssistanceInformtion “可以使用一个新的可选元素 “SFN result”（其值设置为SFN1）。 步骤8：伪终端不知不觉地转发到基站。 步骤9：基站将收到的SFN1值与存储的SFN2值进行比较，确定是否存在伪基站。 结论让基站向终端发送一个受保护的RRC消息来启动伪基站检测。由于这个消息是受安全保护的，攻击者无法知道其内容，也无法从正常的RRC报文中看出。 但是 SFN 是不受加密保护的，所以如果中间人攻击者足够聪明，他可以获得 SFN，然后丢弃它。 1.在移动通信网络(2G, 3G, 4G或5G)中终端通过测量服务小区和邻近小区信号质量，来决定是否切换基站。 ↩2.移动通信系统中，如果在一定区域里两基站信号强度剧烈变化，手机就会在两个基站间来回切换，产生所谓的“乒乓效应”。 ↩3.循环冗余校验（英语：Cyclic redundancy check，通称“CRC”）是一种根据网络数据包或电脑文件等数据产生简短固定位数校验码的一种散列函数，主要用来检测或校验数据传输或者保存后可能出现的错误。生成的数字在传输或者存储之前计算出来并且附加到数据后面，然后接收方进行检验确定数据是否发生变化。 ↩","categories":[{"name":"科研笔记","slug":"科研笔记","permalink":"https://wangtianyang.com/categories/%E7%A7%91%E7%A0%94%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"https://wangtianyang.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}]},{"title":"【面经】美团暑期二面（2022/03/29）","slug":"【面经】美团暑期二面（2022-03-29）","date":"2022-03-29T15:18:42.000Z","updated":"2023-01-06T13:50:02.541Z","comments":true,"path":"2022/03/29/【面经】美团暑期二面（2022-03-29）/","link":"","permalink":"https://wangtianyang.com/2022/03/29/%E3%80%90%E9%9D%A2%E7%BB%8F%E3%80%91%E7%BE%8E%E5%9B%A2%E6%9A%91%E6%9C%9F%E4%BA%8C%E9%9D%A2%EF%BC%882022-03-29%EF%BC%89/","excerpt":"","text":"讲一下WebServer项目使用的技术？ epoll边沿触发是什么？ 水平触发和边缘触发的区别？ 文件描述符怎么表现有没有就绪（就绪的文件描述符是什么样的）？ poll和select的区别？什么时候用poll，什么时候用select？ 1) 底层实现不同，select是数组，poll是链表；2) select有最大连接数限制，poll没有 get和head的区别？ HEAD和GET本质是一样的，区别在于HEAD不含有呈现数据，而仅仅是HTTP头信息。 请求头包含了哪些字段？响应头包含了哪些字段？ 协议头的字段是以明文的字符串格式传输，是以冒号分隔的键名与键值对，以回车(CR)加换行(LF)符号序列结尾。请求头包括：Accept（能够接受的回应内容类型）、connection（该浏览器想要优先使用的连接类型）、host（服务器的域名，以及服务器所监听的传输控制协议端口号）、date（发送该消息的日期和时间）回应头包括：Age（这个对象在代理缓存中存在的时间，以秒为单位）、Allow（对于特定资源有效的动作。针对HTTP/405这一错误代码而使用）、Server（服务器的名字）、Connection（针对该连接所预期的选项） 多线程怎么充分利用多核CPU？ 进程是资源分配的最小单位，线程是CPU调度的最小单位。（一个是相当于一个容器，一个是具体被CPU操作的）计算机的cpu物理核数是同时可以并行的线程数量(cpu只能看到线程，线程是cpu调度分配的最小单位) 为什么要用双缓冲区？双缓冲区怎么实现？ 例 1. 在网络传输过程中数据的接收，有时可能数据来的太快来不及接收导致数据丢失。这是由于“发送者”和“接收者”速度不一致所致，在他们之间安排一个或多个缓冲区来存放来不及接收的数据，让速度较慢的“接收者”可以慢慢地取完数据不至于丢失。例2. 再如，计算机中的三级缓存结构：外存（硬盘）、内存、高速缓存（介于CPU和内存之间，可能由多级）。从左到右他们的存储容量不断减小，但速度不断提升，当然价格也是越来越贵。作为“生产者”的 CPU 处理速度很快，而内存存取速度相对CPU较慢，如果直接在内存中存取数据，他们的速度不一致会导致 CPU 能力下降。因此在他们之间又增加的高速缓存来作为缓冲区平衡二者速度上的差异。例3. 在图形图像显示过程中，计算机从显示缓冲区取数据然后显示，很多图形的操作都很复杂需要大量的计算，很难访问一次显示缓冲区就能写入待显示的完整图形数据，通常需要多次访问显示缓冲区，每次访问时写入最新计算的图形数据。而这样造成的后果是一个需要复杂计算的图形，你看到的效果可能是一部分一部分地显示出来的，造成很大的闪烁不连贯。而使用双缓冲，可以使你先将计算的中间结果存放在另一个缓冲区中，但全部的计算结束，该缓冲区已经存储了完整的图形之后，再将该缓冲区的图形数据一次性复制到显示缓冲区。","categories":[{"name":"面经","slug":"面经","permalink":"https://wangtianyang.com/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[]},{"title":"【面经】华为暑期一面（2022/03/28）","slug":"【面经】华为暑期一面（2022-03-28）","date":"2022-03-28T09:40:25.000Z","updated":"2023-01-06T13:50:08.054Z","comments":true,"path":"2022/03/28/【面经】华为暑期一面（2022-03-28）/","link":"","permalink":"https://wangtianyang.com/2022/03/28/%E3%80%90%E9%9D%A2%E7%BB%8F%E3%80%91%E5%8D%8E%E4%B8%BA%E6%9A%91%E6%9C%9F%E4%B8%80%E9%9D%A2%EF%BC%882022-03-28%EF%BC%89/","excerpt":"","text":"怎么理解dp？ 怎么理解贪心算法？和dp有什么不同？ 贪心是自顶向下，dp是自下向上。 怎么理解哈希表？怎么解决哈希冲突？ 开放定址法（一直往后找空闲单元）、拉链法（把冲突的放在单链表里存起来）、再哈希法（冲突了就换个哈希算法、直到不冲突） 说一下tcp/ip各个层的功能？ 链表和数组的区别？ 怎么判断链表有没有环？怎么判断环长？（回答了快慢指针）证明一下快慢指针是怎么做到判断环和环长的。","categories":[{"name":"面经","slug":"面经","permalink":"https://wangtianyang.com/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[]},{"title":"【面经】美团暑期一面（2022/03/25）","slug":"【面经】美团暑期一面（2022-03-25）","date":"2022-03-25T09:01:32.000Z","updated":"2023-01-06T13:49:57.444Z","comments":true,"path":"2022/03/25/【面经】美团暑期一面（2022-03-25）/","link":"","permalink":"https://wangtianyang.com/2022/03/25/%E3%80%90%E9%9D%A2%E7%BB%8F%E3%80%91%E7%BE%8E%E5%9B%A2%E6%9A%91%E6%9C%9F%E4%B8%80%E9%9D%A2%EF%BC%882022-03-25%EF%BC%89/","excerpt":"","text":"说一下WebServer如何实现的？实现了什么？ get/head请求区别？还有什么请求方式？ 讲讲epoll 长连接 管线化是什么 三握四挥 有没有用过数据库","categories":[{"name":"面经","slug":"面经","permalink":"https://wangtianyang.com/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[]},{"title":"【读书笔记】《现代操作系统》","slug":"【读书笔记】《现代操作系统》","date":"2022-03-24T06:59:54.000Z","updated":"2023-01-06T13:52:16.667Z","comments":true,"path":"2022/03/24/【读书笔记】《现代操作系统》/","link":"","permalink":"https://wangtianyang.com/2022/03/24/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8A%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%8B/","excerpt":"引论操作系统是用来管理计算机各个部件的一层软件。用户与之交互的程序，基于文本的通常称为shell，而基于图标的则称为图形用户界面（也就是GUI）。它们不是操作系统的一部分，只是适用操作系统来完成工作。 多数计算机有两种运行模式：内核态和用户态。 计算机软件中最基础的部分是操作系统，它运行在内核态（也称为管态、核心态）。在这个模式中，操作系统具有对所有硬件的完全访问权，可以执行机器能够运行的任何指令。 软件的其余部分运行在用户态下。在用户态下，只使用了机器指令中的一个子集。用户接口程序（shell或GUI）处于用户态的最底层，允许用户运行其他程序；用户态的上层时Web浏览器、电子邮件阅读器、音乐播放器等程序。这些程序也大量使用操作系统。 资源管理包括两种形式的多路复用： 时间复用。轮流使用CPU。 空间复用。每个客户都得到资源的一部分。 CPU：首先从内存中取出指令，解码以确定其类型和操作数，接着执行它，然后读取、解码并执行下一条指令。","text":"引论操作系统是用来管理计算机各个部件的一层软件。用户与之交互的程序，基于文本的通常称为shell，而基于图标的则称为图形用户界面（也就是GUI）。它们不是操作系统的一部分，只是适用操作系统来完成工作。 多数计算机有两种运行模式：内核态和用户态。 计算机软件中最基础的部分是操作系统，它运行在内核态（也称为管态、核心态）。在这个模式中，操作系统具有对所有硬件的完全访问权，可以执行机器能够运行的任何指令。 软件的其余部分运行在用户态下。在用户态下，只使用了机器指令中的一个子集。用户接口程序（shell或GUI）处于用户态的最底层，允许用户运行其他程序；用户态的上层时Web浏览器、电子邮件阅读器、音乐播放器等程序。这些程序也大量使用操作系统。 资源管理包括两种形式的多路复用： 时间复用。轮流使用CPU。 空间复用。每个客户都得到资源的一部分。 CPU：首先从内存中取出指令，解码以确定其类型和操作数，接着执行它，然后读取、解码并执行下一条指令。 进程与线程进程伪并行：在某一个瞬间，CPU只能允许一个进程，但在一秒内，它可能运行多个进程，与多处理器系统区别。 进程和程序的关系：（比喻）一个计算机科学家为他的女儿烘制生日蛋糕。他有做生日蛋糕的食谱，厨房里有所需的原料：面粉、鸡蛋、糖、香草汁等。在这个比喻中，做蛋糕的食谱就是程序（即用适当形式描述的算法），计算机科学家就是处理器（CPU），而做蛋糕的各种原料就是输入数据。进程就是厨师阅读食谱、取来各种原料以及烘制蛋糕等一系列动作的总和。 现在假设计算机科学家的儿子哭着跑进来了，说他的头被一只蜜蜂蛰了。计算机科学加就记录下它照着食谱坐到哪了（保存进程的当前状态），然后拿出一本急救手册，按照其中的指示处理蛰伤。这里，处理机从一个进程（做蛋糕）切换到另一个优先级更高的进程（实施医疗救治），每个进程拥有各自的程序（食谱和急救手册）。当蜜蜂蛰伤处理完以后，这位计算机科学家又回来做蛋糕，从他离开时的那一步继续做下去。 这里的关键思想是：一个进程是某种类型的一个活动，它有程序、输入、输出以及状态。单个处理器可以被若干进程共享，它使用某种调度算法决定何时停止一个进程的工作，并转而为另一个进程提供服务。 进程的创建4种主要事件会导致进程的创建： 系统初始化 正在运行的程序执行了创建进程的系统调用 用户请求创建一个新进程 一个批处理作业的初始化 进程分为前台进程和后台进程。前台进程也就是同用户（人类）交互并且替他们完成工作的那些进程；后台进程与特定的用户没有关系，但具有专门的功能，比如接受发来邮件的后台进程。停留在后台诸如电子邮件、Web页面、新闻、打印之类活动的进程称为守护进程。 在UNIX和Windows中，进程创建之后，父进程和子进程有各自不同的地址空间。如果其中某个进程在其地址空间中修改了一个字，这个修改对其他进程而言是不可见的。注意，可写的内存是不可以被共享的！ 进程的退出进程的终止通常由下列条件引起： 正常退出（自愿） 出错退出（自愿） 严重错误（非自愿） 被其他进程杀死（非自愿） 进程的状态进程有三种状态： 运行态（该时刻进程实际占用CPU） 就绪态（可运行，但因为其他进程正在运行而暂时停止） 阻塞态（除非某种外部事件发生，比如有效输入，否则进程不能运行） 进程表为了实现进程模型，操作系统维护着一张表格，即进程表。每个进程占用一个进程表项（进程控制块）。下图展示了典型进程表表项中的一些字段： 进程管理 存储管理 文件管理 寄存器 代码段指针 根目录 程序计数器 数据段指针 工作目录 程序状态字 堆栈段指针 文件描述符 堆栈指针 用户ID 进程状态 组ID 优先级 调度参数 进程ID 父进程 进程组 信号 进程开始时间 使用的CPU时间 子进程的CPU时间 下次定时器时间 多道程序设计模型假设一个进程等待 I/O 操作的时间与其停留在内存中的时间比为 $p$，当内存中同时有 $n$ 个进程时，则所有 $n$ 个进程都在等待 I/O 的概率是 $p^n$。CPU的利用率为： CPU利用率=1-p^n比如进程花费 80% 的时间等待 I/O，为使CPU的浪费低于 10%，至少要有10个进程同时在内存中。 线程需要线程的原因： 在许多应用中发生着多种活动，其中某些活动会随着时间的推移被阻塞。通过将这些应用程序分解为可以准并行运行的多个顺序线程，程序设计模型会变得简单。 由于线程比进程更轻量级，所以他们比进程更容易（即更快）创建，也更容易销毁。 若多个线程都是CPU密集型的，那么并不能获得性能上的增强，但是如果存在着大量的I/O处理，拥有多个线程允许这些活动彼此重叠进行，从而加快应用程序执行的速度。 在多CPU系统中，多线程是的真正的并行有了实现的可能。例子见《现代操作系统》P55字处理软件。 构造服务器的三种方法 模型 特性 多线程 并行性、阻塞系统调用 单线程进程 无并行性、阻塞系统调用 有限状态机 并行性、非阻塞系统调用、中断 经典的线程模型进程用于把资源集中到一起，而线程则是在CPU上被调度执行的实体。 进程中的不同线程不像不同进程之间那样存在很大的独立性。所有的线程都有完全一样的地址空间，这意味着它们也可以共享同样的全局变量。 一个进程中所有线程共享的内容 每个线程自己的内容 地址空间 程序计数器 全局变量 寄存器 打开文件 堆栈 子进程 状态 即将发生的定时器 信号与信号处理程序 账户信息","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://wangtianyang.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://wangtianyang.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"【读书笔记】《EffectiveC++》","slug":"【读书笔记】《EffectiveC-》","date":"2022-03-24T06:58:27.000Z","updated":"2023-01-06T13:51:38.828Z","comments":true,"path":"2022/03/24/【读书笔记】《EffectiveC-》/","link":"","permalink":"https://wangtianyang.com/2022/03/24/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8AEffectiveC-%E3%80%8B/","excerpt":"导读声明式和定义式 变量的定义：变量的定义用于为变量分配存储空间，还可以为变量指定初始值。在一个程序中，变量有且仅有一个定义。 变量的声明：用于向程序表明变量的类型和名字。程序中变量可以声明多次，但只能定义一次。 两者联系与区别： 定义也是声明，因为当定义变量时我们也向程序表明了它的类型和名字； 但声明不是定义，可以通过使用extern关键字声明变量而不定义它。不定义变量的声明包括对象名、对象类型和对象类型前的关键字extern；","text":"导读声明式和定义式 变量的定义：变量的定义用于为变量分配存储空间，还可以为变量指定初始值。在一个程序中，变量有且仅有一个定义。 变量的声明：用于向程序表明变量的类型和名字。程序中变量可以声明多次，但只能定义一次。 两者联系与区别： 定义也是声明，因为当定义变量时我们也向程序表明了它的类型和名字； 但声明不是定义，可以通过使用extern关键字声明变量而不定义它。不定义变量的声明包括对象名、对象类型和对象类型前的关键字extern； 条款01：视C++为一个语言联邦C++是一个多重范型编程语言，一个同时支持过程形式、面向对象形式、函数形式、泛型形式、元编程形式的语言。多重特性之间的适用范围会让人糊涂，因此我们可以将其看成一个由多个次语言组成的联邦而非单一语言。 C++主要的次语言有四个： C。区块、语句、预处理器、内置数据类型、数组、指针等统统来自于C，但是C也有其局限：没有模板、没有异常、没有重载…… Object-Oriented C++。这部分也就是C with Classes（C++原名）所诉求的：classes（包括构造函数和析构函数），封装、继承、多态、virtual函数（动态绑定）…… Template C++。这是C++的泛型编程部分。它带来了崭新的编程范型（programming paradigm），也就是所谓的template metaprogramming（TMP，模板元编程）。 STL。包含容器、迭代器、算法。 条款02：尽量以const，enum，inline 替换 #defineconst当我们以常量替换#define时，有两种特殊情况需要注意。 第一是定义常量指针。由于常量定义通常被放在头文件内（一边被不同的源码含入），因此有必要讲指针（而不是指针所指之物）声明为const。例如要在头文件内定义一个常量的char*字符串时，必须要写const两次： 1const char* const authorName = &quot;Scott Meyers&quot;; 第二个需要注意的是class专属常量。为了将常量的作用域（scope）限制于class内，你必须要让它成为class的一个成员（member）；而为确保此常量至多只有一份实体，你必须让它成为一个static成员： 123456class GamePlayer &#123;private: static const in NumTurns = 5; //常量声明式 int scores[NumTurns]; //使用该常量 ...&#125;; enum枚举类型(enumeration)是 C++ 中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。 定义格式： 1enum &lt;类型名&gt; &#123;&lt;美剧常量表&gt;&#125; 枚举常量代表该枚举类型的变量可能取的值，编译系统为每个枚举常量指定一个整数值，默认状态下，这个整数就是所列举元素的序号，序号从0开始。 也可以在定义枚举类型时为部分或全部枚举常量指定整数值，在指定值之前的枚举常量仍按默认方式取值，而指定值之后的枚举常量按依次加1的原则取值。 各枚举常量的值可以重复。例如： 12345enum fruit_set &#123;apple, orange, banana=1, peach, grape&#125;//枚举常量apple=0,orange=1, banana=1,peach=2,grape=3。enum week &#123;Sun=7, Mon=1, Tue, Wed, Thu, Fri, Sat&#125;;//枚举常量Sun,Mon,Tue,Wed,Thu,Fri,Sat的值分别为7、1、2、3、4、5、6。 选择enum而非const的理由：有时候你不想别人取到你常量的地址时，或者不想有一个指针或者引用指向enum时，因为取const的地址是合法的，而取#define和enum的地址就不合法。 inline宏。没什么好说的。 条款03：尽可能使用const指针常量和常量指针常量指针：const int * a; 或 int const * a; 指针常量：int * const a; 迭代器声明迭代器为 const 就像声明指针为const一样（即声明一个 T const 指针），如果希望迭代器所指的东西不可被改动（即声明一个 const T 指针），你需要的是 const_iterator： 12const std::vector&lt;int&gt;::iterator iter = vec.begin(); //等于 T* conststd::vector&lt;int&gt;::const_Iterator cIter = vec.begin(); //等于 const T* 函数返回值作用：比如避免a*b=c这样的错误。 12class Rational &#123; ... &#125;;const Rational operator* (const Rational&amp; lhs, const Rational&amp; rhs); //第一个const确保返回值不被修改 成员函数将const实施于成员函数的目的，是为了确认该成员函数可作用于const对象身上。 123456789101112class TextBlock &#123;public: ... // operator[] 作用于const对象上 const char&amp; operator[] (std::size_t position) const &#123; return text[position]; &#125; // operator[] 作用于非const对象上 char&amp; operator[] (std::size_t position) &#123; return text[position]; &#125;&#125; 如果想要修改指定成员变量，可以用mutable修饰。 条款04：确定对象被使用前已先被初始化对于内置类型，初始化很简单，比如int a = 0; 对于内置类型以外的类，初始化责任落在构造函数上：确保每一个构造函数都将对象的每一个成员初始化。 对于成员变量需要注意的是：构造函数内初始化并不是真正的初始化！！！而只是赋值！比如： 12345678910111213141516class Cperson&#123;private: int m_age; float m_height; char* m_name;public: Cperson(int age,float height,const char* name) &#123; m_age=age; m_height=height; int len=strlen(name); m_name=new char[len+1];//创建内存 strcpy(m_name,name); &#125;&#125; 真正的初始化应该发生在这些成员的 default 构造函数被自动调用之时，比进入当前对象的构造函数更早，也就是成员初值列： 1234567//m_name为指针类型，需要自己申请空间Cperson::Cperson(int age,float height,const char* name):m_age(age),m_height(height)&#123; int len=strlen(name); m_name=new char[len+1];//创建内存 strcpy(m_name,name);&#125; 注意点！！！ 如果成员变量是const或references，它们就一定需要初值，而不能被赋值，所以一定要使用成员初值列。 class的成员变量总是以其声明次序被初始化，即使它们在成员初值列中以不同的次序出现，也不会改变。 不同编译单元内定义之 non-local static 对象的初始化顺序概念： static对象：所谓static对象，其寿命从被构造出来知道程序结束为止，因此，堆（stack）栈（heap）里的对象都被排除。static对象包括全局对象、定义于namespace作用域内的对象、在classes内、在函数内、以及在文件作用域内被声明为static的对象。函数内的static对象称为local static对象（因为它们对函数而言是loacl），其他static对象被称为non-local static对象。程序结束时static对象会自动销毁，也就是它们的析构函数会在main()结束时被自动调用。 编译单元：所谓编译单元（translation unit）是指产出单一目标文件的那些源码。基本上它是单一源码文件加上其所含入的头文件（# include files）。 C++对于定义于不同编译单元内的 non-local static 对象的初始化顺序没有明确定义，这就导致了当一个 non-local static 对象用到了另一个 non-local static 对象时，如果第二个 non-local static 对象还没有初始化，就会造成错误。 解决办法：把 non-local static 对象放进函数里，使其变成 local static 对象，只要返回一个 reference 指向该 local static 对象就好了。因为C++保证，函数内的 local static 对象会在该函数被调用期间首次遇到该对象定义式时被初始化。 详见P30-32。 条款05：了解C++默默编写并调用哪些函数C++会为一个空类自动声明一个 copy 构造函数，一个 copy assignment 操作符和一个析构函数，此外，如果你没有声明任何构造函数，编译器也会为你声明一个 default 构造函数。 注意，编译器产出的析构函数是 non-virtual。 对于内含 reference 成员或者 const 成员的类来说，必须自己定义 copy assignment 操作符。 条款06：若不想使用编译器自动生成的函数，就该明确拒绝为了不使用编译器自动提供的函数，（比如 copy 构造函数和 copy assignment 操作符，）一般有两种方法： 我们可以将对应的成员函数声明为 private 并不提供实现。 我们如上设计一个基类，再继承他。 条款07：为多态基类声明 virtual 析构函数如果基类的析构函数为 non-virtual，那么会造成“局部销毁”现象，即派生类内的成员变量很可能没被销毁，而基类的成员变量则被全部销毁。 对如上问题的解决办法：给 base class 的析构函数设为 virtual。 注：任何 class，只要带有 virtual 函数，都应该配有一个 virtual 析构函数。而如果 class 内不含 virtual 函数，那么就意味着它不打算做一个基类，这时候将它的析构函数声明为 virtual 就是一个坏主意。（因为占的内存大小会增加。） 小tips：当你需要基类为抽象类时，你可以将析构函数声明为纯虚函数。但是必须为该析构函数提供定义。 条款08：别让异常逃离析构函数不应该让析构函数吐出异常，否则当容器或array里存了此类，C++会同时收到两个及以上的异常，这时程序必须立即结束执行，否则会导致不明确行为。 一般的，有两个解决办法： 如果析构函数抛出异常就立刻结束程序，通常通过调用std::abort()完成； 忽略异常。 但是，有一个更好的办法：在类内提供一个普通函数来执行 close 操作。 条款09：绝不在构造和析构过程中调用 virtual 函数确保你的构造函数和析构函数（即在对象创建和销毁期间）都没有调用 virtual 函数，而且它们调用的所有函数也都服从统一约束。 因为基类对虚函数的调用从不下降至派生类。 解决方法：我们可以换种思路，既然不能让虚函数从基类向下调用，那么我们可以让派生类将必要的构造信息向上传递至基类的构造函数。（详细见 P51） 条款10：令 operator= 返回一个 reference to *this12345678class Wiget &#123;public: ... Wiget&amp; operate=(const Wiget&amp; rhs) &#123; ... return *this; &#125;&#125; 此条款适用于所有赋值相关运算，例如+=等，但不具有强制性。 条款11：在 operator= 中处理“自我赋值”","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://wangtianyang.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://wangtianyang.com/tags/C/"}]},{"title":"【读书笔记】《算法导论》","slug":"【读书笔记】《算法导论》","date":"2022-03-24T06:56:34.000Z","updated":"2023-01-06T13:52:30.441Z","comments":true,"path":"2022/03/24/【读书笔记】《算法导论》/","link":"","permalink":"https://wangtianyang.com/2022/03/24/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8A%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA%E3%80%8B/","excerpt":"","text":"基础知识算法在计算中的作用略 算法基础插入排序插入排序是原址排序。 伪代码：1","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://wangtianyang.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://wangtianyang.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【读书笔记】《C++PrimerPlus》","slug":"【读书笔记】《C-PrimerPlus》","date":"2022-03-24T05:07:11.000Z","updated":"2023-01-06T13:51:55.478Z","comments":true,"path":"2022/03/24/【读书笔记】《C-PrimerPlus》/","link":"","permalink":"https://wangtianyang.com/2022/03/24/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8AC-PrimerPlus%E3%80%8B/","excerpt":"预备知识面向过程和面向对象一般来说，计算机语言要处理两个概念——数据和算法。数据时程序使用和处理的信息，而算法是程序使用的方法。 过程性语言强调的是编程的算法方面，从概念上来说，过程化编程首先要确定计算机应采取的操作，然后使用编程语言来实现这些操作，程序命令计算机按一系列流程生成特定的结果，就像菜谱制定了厨师做蛋糕时应遵循的一系列步骤一样。 随着程序规模的扩大，早起的编程语言（如FORTRAN和BASIC）都会遇到组织方面的问题，简单来说，就是根据测试结果选择执行一组或另一组指令。但是旧时程序的执行路径很混乱，几乎不可能通过阅读程序来理解他。于是发展出了一种更有序的编程方法——结构化编程。 结构化编程依然属于过程化编程，只是它的拓展。结构比如for循环，while循环，if else语句等。 但在编写大型程序是，结构化编程仍然面临着挑战。于是就产生了面向对象编程——OOP。与强调算法的过程性编程不同，OOP强调的是数据。其理念是设计与问题的本质特性相对应的数据结构。 过程性编程与OOP的另一个区别是： 过程性编程是自顶向下（top-down）的。比如C语言中，就是将大型程序分解成小型、便于管理的任务。比如整理书房时，可以分为整理桌子、整理书架，整理桌子又可以分为整理抽屉、打扫桌面……C语言鼓励程序员开发程序单元（函数）来表示各个任务模块。 OOP是自下向上（bottom-up）的。也就是从低级组织（如类）到高级组织（如程序）的处理过程。","text":"预备知识面向过程和面向对象一般来说，计算机语言要处理两个概念——数据和算法。数据时程序使用和处理的信息，而算法是程序使用的方法。 过程性语言强调的是编程的算法方面，从概念上来说，过程化编程首先要确定计算机应采取的操作，然后使用编程语言来实现这些操作，程序命令计算机按一系列流程生成特定的结果，就像菜谱制定了厨师做蛋糕时应遵循的一系列步骤一样。 随着程序规模的扩大，早起的编程语言（如FORTRAN和BASIC）都会遇到组织方面的问题，简单来说，就是根据测试结果选择执行一组或另一组指令。但是旧时程序的执行路径很混乱，几乎不可能通过阅读程序来理解他。于是发展出了一种更有序的编程方法——结构化编程。 结构化编程依然属于过程化编程，只是它的拓展。结构比如for循环，while循环，if else语句等。 但在编写大型程序是，结构化编程仍然面临着挑战。于是就产生了面向对象编程——OOP。与强调算法的过程性编程不同，OOP强调的是数据。其理念是设计与问题的本质特性相对应的数据结构。 过程性编程与OOP的另一个区别是： 过程性编程是自顶向下（top-down）的。比如C语言中，就是将大型程序分解成小型、便于管理的任务。比如整理书房时，可以分为整理桌子、整理书架，整理桌子又可以分为整理抽屉、打扫桌面……C语言鼓励程序员开发程序单元（函数）来表示各个任务模块。 OOP是自下向上（bottom-up）的。也就是从低级组织（如类）到高级组织（如程序）的处理过程。 开始学习C++C++特性 运算符重载 语句不用换行 变量必须声明 函数原型C++程序必须为程序中使用的每个函数提供原型。原型语句如下： 1double function(double); 结尾的封号表明他是一条语句，这使得它是一个原型，而不是函数头。 提供原型有两种实现方法： 在源代码文件中输入函数原型； 在引用的头文件中定义原型。 一般使用第二种。 处理数据C++进制表示法 如果第一位为 1～9，则为十进制，比如 93； 如果第一位是 0，则为八进制，比如 042； 如果前两位是 0x 或 0X，则为十六进制，比如 0x42。 复合类型字符串C++处理字符串的方式有两种，第一种来自C语言，常被称为C-风格字符串，第二种是基于string类库的方法。 C-style string存储在连续字节中的一系列字符意味着可以将字符串存储在char数组中。C-风格字符串具有一种特殊的性质：以空字符结尾，空字符被写为’\\0’，例： 12char dog[3] = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;; // 不是字符串char cat[3] = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;\\0&#x27;&#125;; // 是字符串 C++中有很多处理字符串的函数都依赖空字符结尾，比如cout。他们逐个处理字符串中的字符，指导到达空字符为止。如果使用cout现实上面dog这样的字符串，cout会在打印完dog中三个元素后继续打印内存中随后的各个字节，直到遇到空字符为止。 C++也可以用双引号来初始化字符串，我们将这种方式称为字符串常量（string constant）或字符串字面值（string literal）。 12char bird[11] = &quot;Mr. Cheeps&quot;;char fish[] = &quot;Bubbles&quot;;","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://wangtianyang.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://wangtianyang.com/tags/C/"}]},{"title":"【笔经】华为暑期笔试（2022/03/23）","slug":"【笔经】华为暑期笔试（2022-03-23）","date":"2022-03-23T13:19:59.000Z","updated":"2023-01-06T13:53:28.419Z","comments":true,"path":"2022/03/23/【笔经】华为暑期笔试（2022-03-23）/","link":"","permalink":"https://wangtianyang.com/2022/03/23/%E3%80%90%E7%AC%94%E7%BB%8F%E3%80%91%E5%8D%8E%E4%B8%BA%E6%9A%91%E6%9C%9F%E7%AC%94%E8%AF%95%EF%BC%882022-03-23%EF%BC%89/","excerpt":"魔力台阶你当前处于第一级台阶上，每级台阶都有一个值，该值表示你能再往前走多少节台阶（为 0 则表示不能走），给定台阶长度 n 表示每级台阶的数组 nums 和整数 K，问能不能在小于等于 K 步之内走到最高台阶，如果能，则返回最少步数，不能则返回 -1。 样例1123输入：n = 5, nums = [2 0 1 0 3], K = 2输出：-1 样例2123输入：n = 6, nums = [2 1 5 6 2 3], K = 3输出：2","text":"魔力台阶你当前处于第一级台阶上，每级台阶都有一个值，该值表示你能再往前走多少节台阶（为 0 则表示不能走），给定台阶长度 n 表示每级台阶的数组 nums 和整数 K，问能不能在小于等于 K 步之内走到最高台阶，如果能，则返回最少步数，不能则返回 -1。 样例1123输入：n = 5, nums = [2 0 1 0 3], K = 2输出：-1 样例2123输入：n = 6, nums = [2 1 5 6 2 3], K = 3输出：2 TLV匹配TLV 是一种可变的格式，其中： T 可以理解为 Tag 或 Type ，用于标识标签或者编码格式信息； L 定义数值的长度； V 表示实际的数值。 T 和 L 的长度固定，为 1 个字节，V 的长度由 L 指定。 现在收到一个消息包，由多组 TLV 紧密排列。给定一个字符串（16进制）表示消息包，再给定一组tag值，问能不能匹配。能的话返回每组TLV消息的 L 以及偏移量。否则返回0 0。 样例1123输入：0F04ABABABAB, [15]输出：4 2解释：0F等于15，与15匹配，04表明对应数据的长度为4个字节，与”ABABABAB”匹配。 样例21234输入：0F04ABABABAB1001FF, [15, 17]输出：4 2 0 0解释：10与17不匹配，所以返回0 0 安排面试官有 M 个面试官，每个面试官都会几种语言（用列表表示），有 N 个面试者，每个面试者都选择了一种语言，每个面试者需要被两个不同的面试官面试，而每个面试官最多只能面 K 个面试者，问能不能面完，如果能的话还需要返回一个二位数组match，其中match[i][j]表示第i个面试官匹配第j个面试者，如果答案有多种，只需返回一种。 样例11234567891011121314151617输入：4 6 4 // 分别是面试官个数、面试者个数和面试官最多能面 K 个人 Java C++ Python // 第一个面试官会的语言，往下依次类推 Python C++ Java Python Java // 第一个面试者选的语言 Python C++ Python C++ Java输出：true 1 0 1 0 1 1 0 1 0 1 0 0 1 0 1 0 1 1 0 1 0 1 0 0","categories":[{"name":"笔经","slug":"笔经","permalink":"https://wangtianyang.com/categories/%E7%AC%94%E7%BB%8F/"}],"tags":[]},{"title":"【C++】友元函数和友元类","slug":"【C-】友元函数和友元类","date":"2022-03-23T06:14:16.000Z","updated":"2023-01-06T13:45:11.715Z","comments":true,"path":"2022/03/23/【C-】友元函数和友元类/","link":"","permalink":"https://wangtianyang.com/2022/03/23/%E3%80%90C-%E3%80%91%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%8B%E5%85%83%E7%B1%BB/","excerpt":"私有成员只能在类的成员函数内部访问，如果想在别处访问对象的私有成员，只能通过类提供的接口（成员函数）间接地进行。这固然能够带来数据隐藏的好处，利于将来程序的扩充，但也会增加程序书写的麻烦。 C++ 是从结构化的C语言发展而来的，需要照顾结构化设计程序员的习惯，所以在对私有成员可访问范围的问题上不可限制太死。 C++ 设计者认为， 如果有的程序员真的非常怕麻烦，就是想在类的成员函数外部直接访问对象的私有成员，那还是做一点妥协以满足他们的愿望为好，这也算是眼前利益和长远利益的折中。因此，C++ 就有了友元（friend）的概念。打个比方，这相当于是说：朋友是值得信任的，所以可以对他们公开一些自己的隐私。","text":"私有成员只能在类的成员函数内部访问，如果想在别处访问对象的私有成员，只能通过类提供的接口（成员函数）间接地进行。这固然能够带来数据隐藏的好处，利于将来程序的扩充，但也会增加程序书写的麻烦。 C++ 是从结构化的C语言发展而来的，需要照顾结构化设计程序员的习惯，所以在对私有成员可访问范围的问题上不可限制太死。 C++ 设计者认为， 如果有的程序员真的非常怕麻烦，就是想在类的成员函数外部直接访问对象的私有成员，那还是做一点妥协以满足他们的愿望为好，这也算是眼前利益和长远利益的折中。因此，C++ 就有了友元（friend）的概念。打个比方，这相当于是说：朋友是值得信任的，所以可以对他们公开一些自己的隐私。 友元分为两种：友元函数和友元类。 友元函数在定义一个类的时候，可以把一些函数（包括全局函数和其他类的成员函数）声明为“友元”，这样那些函数就成为该类的友元函数，在友元函数内部就可以访问该类对象的私有成员了。 将全局函数声明为友元的写法如下：1friend 返回值类型 函数名(参数表);将其他类的成员函数声明为友元的写法如下：1friend 返回值类型 其他类的类名::成员函数名(参数表);但是，不能把其他类的私有成员函数声明为友元。 关于友元，看下面的程序示例。12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;using namespace std;class CCar; //提前声明CCar类，以便后面的CDriver类使用class CDriver&#123;public: void ModifyCar(CCar* pCar); //改装汽车&#125;;class CCar&#123;private: int price; friend int MostExpensiveCar(CCar cars[], int total); //声明友元 friend void CDriver::ModifyCar(CCar* pCar); //声明友元&#125;;void CDriver::ModifyCar(CCar* pCar)&#123; pCar-&gt;price += 1000; //汽车改装后价值增加&#125;int MostExpensiveCar(CCar cars[], int total) //求最贵气车的价格&#123; int tmpMax = -1; for (int i = 0; i&lt;total; ++i) if (cars[i].price &gt; tmpMax) tmpMax = cars[i].price; return tmpMax;&#125;int main()&#123; return 0;&#125;这个程序只是为了展示友元的用法，所以 main 函数什么也不做。 第 3 行声明了 CCar 类，CCar 类的定义在后面。之所以要提前声明，是因为 CDriver 类的定义中用到了 CCar 类型（第7行），而此时 CCar 类还没有定义，编译会报错。 不要第 3 行，而把 CCar 类的定义写在 CDriver 类的前面，是解决不了这个问题的，因为 CCar 类中也用到了 CDriver 类型（第14行），把 CCar 类的定义写在前面会导致第 14 行的 CDriver 因没有定义而报错。C++ 为此提供的解决办法是：可以简单地将一个类的名字提前声明，写法如下：1class 类名;尽管可以提前声明，但是在一个类的定义出现之前，仍然不能有任何会导致该类对象被生成的语句。但使用该类的指针或引用是没有问题的。 第 13 行将全局函数 MostExpensiveCar 声明为 CCar 类的友元，因此在第 24 行可以访问 cars[i] 的私有成员 price。同理，第 14 行将 CDriver 类的 ModifyCar 成员函数声明为友元，因此在第 18 行可以访问 pCar 指针所指向的对象的私有成员变量 price。 友元类一个类 A 可以将另一个类 B 声明为自己的友元，类 B 的所有成员函数就都可以访问类 A 对象的私有成员。在类定义中声明友元类的写法如下：1friend class 类名;来看如下例程：12345678910111213141516171819class CCar&#123;private: int price; friend class CDriver; //声明 CDriver 为友元类&#125;;class CDriver&#123;public: CCar myCar; void ModifyCar() //改装汽车 &#123; myCar.price += 1000; //因CDriver是CCar的友元类，故此处可以访问其私有成员 &#125;&#125;;int main()&#123; return 0;&#125;第 5 行将 CDriver 声明为 CCar 的友元类。这条语句本来就是在声明 CDriver 是一个类，所以 CCar 类定义前面就不用声明 CDriver 类了。第 5 行使得 CDriver 类的所有成员函数都能访问 CCar 对象的私有成员。如果没有第 5 行，第 13 行对 myCar 私有成员 price 的访问就会导致编译错误。 一般来说，类 A 将类 B 声明为友元类，则类 B 最好从逻辑上和类 A 有比较接近的关系。例如上面的例子，CDriver 代表司机，CCar 代表车，司机拥有车，所以 CDriver 类和 CCar 类从逻辑上来讲关系比较密切，把 CDriver 类声明为 CCar 类的友元比较合理。 友元关系在类之间不能传递，即类 A 是类 B 的友元，类 B 是类 C 的友元，并不能导出类 A 是类 C 的友元。“咱俩是朋友，所以你的朋友就是我的朋友”这句话在 C++ 的友元关系上 不成立。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://wangtianyang.com/tags/C/"}]},{"title":"【C++】多线程中的锁","slug":"【C-】多线程中的锁","date":"2022-03-23T05:57:51.000Z","updated":"2023-01-06T13:46:53.831Z","comments":true,"path":"2022/03/23/【C-】多线程中的锁/","link":"","permalink":"https://wangtianyang.com/2022/03/23/%E3%80%90C-%E3%80%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%94%81/","excerpt":"锁：mutex锁，是生活中应用十分广泛的一种工具。锁的本质属性是为事物提供“访问保护”，例如：大门上的锁，是为了保护房子免于不速之客的到访；自行车的锁，是为了保护自行车只有owner才可以使用；保险柜上的锁，是为了保护里面的合同和金钱等重要东西…… 在c++等高级编程语言中，锁也是用来提供“访问保护”的，不过被保护的东西不再是房子、自行车、金钱，而是内存中的各种变量。此外，计算机领域对于“锁”有个响亮的名字——mutex（互斥量），学过操作系统的同学对这个名字肯定很熟悉。 Mutex，互斥量，就是互斥访问的量。这种东东只在多线程编程中起作用，在单线程程序中是没有什么用处的。从c++11开始，c++提供了std::mutex类型，对于多线程的加锁操作提供了很好的支持。下面看一个简单的例子，对于mutex形成一个直观的认识。","text":"锁：mutex锁，是生活中应用十分广泛的一种工具。锁的本质属性是为事物提供“访问保护”，例如：大门上的锁，是为了保护房子免于不速之客的到访；自行车的锁，是为了保护自行车只有owner才可以使用；保险柜上的锁，是为了保护里面的合同和金钱等重要东西…… 在c++等高级编程语言中，锁也是用来提供“访问保护”的，不过被保护的东西不再是房子、自行车、金钱，而是内存中的各种变量。此外，计算机领域对于“锁”有个响亮的名字——mutex（互斥量），学过操作系统的同学对这个名字肯定很熟悉。 Mutex，互斥量，就是互斥访问的量。这种东东只在多线程编程中起作用，在单线程程序中是没有什么用处的。从c++11开始，c++提供了std::mutex类型，对于多线程的加锁操作提供了很好的支持。下面看一个简单的例子，对于mutex形成一个直观的认识。 Demo1——无锁的情况假定有一个全局变量counter，启动两个线程，每个都对该变量自增10000次，最后输出该变量的值。在第一个demo中，我们不加锁，代码文件保存为：mutex_demo1_no_mutex.cpp123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;mutex&gt;#include &lt;chrono&gt;#include &lt;stdexcept&gt;int counter = 0;void increase(int time) &#123; for (int i = 0; i &lt; time; i++) &#123; // 当前线程休眠1毫秒 std::this_thread::sleep_for(std::chrono::milliseconds(1)); counter++; &#125;&#125;int main(int argc, char** argv) &#123; std::thread t1(increase, 10000); std::thread t2(increase, 10000); t1.join(); t2.join(); std::cout &lt;&lt; &quot;counter:&quot; &lt;&lt; counter &lt;&lt; std::endl; return 0;&#125; 为了显示多线程竞争导致结果不正确的现象，在每次自增操作的时候都让当前线程休眠1毫秒 如果没有多线程编程的相关经验，我们可能想当然的认为最后的counter为20000，如果这样想的话，那就大错特错了。下面是两次实际运行的结果：1234[root@2d129aac5cc5 demo]# ./mutex_demo1_no_mutexcounter:19997[root@2d129aac5cc5 demo]# ./mutex_demo1_no_mutexcounter:19996出现上述情况的原因是：自增操作”counter++”不是原子操作，而是由多条汇编指令完成的。多个线程对同一个变量进行读写操作就会出现不可预期的操作。以上面的demo1作为例子：假定counter当前值为10，线程1读取到了10，线程2也读取到了10，分别执行自增操作，线程1和线程2分别将自增的结果写回counter，不管写入的顺序如何，counter都会是11，但是线程1和线程2分别执行了一次自增操作，我们期望的结果是12！！！！！ 轮到mutex上场。 Demo2——加锁的情况定义一个std::mutex对象用于保护counter变量。对于任意一个线程，如果想访问counter，首先要进行”加锁”操作，如果加锁成功，则进行counter的读写，读写操作完成后释放锁（重要!!!）； 如果“加锁”不成功，则线程阻塞，直到加锁成功。12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;mutex&gt;#include &lt;chrono&gt;#include &lt;stdexcept&gt;int counter = 0;std::mutex mtx; // 保护countervoid increase(int time) &#123; for (int i = 0; i &lt; time; i++) &#123; mtx.lock(); // 当前线程休眠1毫秒 std::this_thread::sleep_for(std::chrono::milliseconds(1)); counter++; mtx.unlock(); &#125;&#125;int main(int argc, char** argv) &#123; std::thread t1(increase, 10000); std::thread t2(increase, 10000); t1.join(); t2.join(); std::cout &lt;&lt; &quot;counter:&quot; &lt;&lt; counter &lt;&lt; std::endl; return 0;&#125;上述代码保存文件为：mutex_demo2_with_mutex.cpp。先来看几次运行结果：123456[root@2d129aac5cc5 demo]# ./mutex_demo2_with_mutexcounter:20000[root@2d129aac5cc5 demo]# ./mutex_demo2_with_mutexcounter:20000[root@2d129aac5cc5 demo]# ./mutex_demo2_with_mutexcounter:20000这次运行结果和我们预想的一致，原因就是“利用锁来保护共享变量”，在这里共享变量就是counter（多个线程都能对其进行访问，所以就是共享变量啦）。 简单总结一些std::mutex： 对于std::mutex对象，任意时刻最多允许一个线程对其进行上锁 mtx.lock()：调用该函数的线程尝试加锁。如果上锁不成功，即：其它线程已经上锁且未释放，则当前线程block。如果上锁成功，则执行后面的操作，操作完成后要调用mtx.unlock()释放锁，否则会导致死锁的产生 mtx.unlock()：释放锁 std::mutex还有一个操作：mtx.try_lock()，字面意思就是：“尝试上锁”，与mtx.lock()的不同点在于：如果上锁不成功，当前线程不阻塞。 lock_guard虽然std::mutex可以对多线程编程中的共享变量提供保护，但是直接使用std::mutex的情况并不多。因为仅使用std::mutex有时候会发生死锁。回到上边的例子，考虑这样一个情况：假设线程1上锁成功，线程2上锁等待。但是线程1上锁成功后，抛出异常并退出，没有来得及释放锁，导致线程2“永久的等待下去”（线程2：我的心在等待永远在等待……），此时就发生了死锁。给一个发生死锁的 ： Demo3——死锁的情况（仅仅为了演示，不要这么写代码哦）为了捕捉抛出的异常，我们重新组织一下代码，代码保存为:mutex_demo3_dead_lock.cpp。1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;mutex&gt;#include &lt;chrono&gt;#include &lt;stdexcept&gt;int counter = 0;std::mutex mtx; // 保护countervoid increase_proxy(int time, int id) &#123; for (int i = 0; i &lt; time; i++) &#123; mtx.lock(); // 线程1上锁成功后，抛出异常：未释放锁 if (id == 1) &#123; throw std::runtime_error(&quot;throw excption....&quot;); &#125; // 当前线程休眠1毫秒 std::this_thread::sleep_for(std::chrono::milliseconds(1)); counter++; mtx.unlock(); &#125;&#125;void increase(int time, int id) &#123; try &#123; increase_proxy(time, id); &#125; catch (const std::exception&amp; e)&#123; std::cout &lt;&lt; &quot;id:&quot; &lt;&lt; id &lt;&lt; &quot;, &quot; &lt;&lt; e.what() &lt;&lt; std::endl; &#125;&#125;int main(int argc, char** argv) &#123; std::thread t1(increase, 10000, 1); std::thread t2(increase, 10000, 2); t1.join(); t2.join(); std::cout &lt;&lt; &quot;counter:&quot; &lt;&lt; counter &lt;&lt; std::endl; return 0;&#125;执行后，结果如下图所示：12[root@2d129aac5cc5 demo]# ./mutex_demo3_dead_lockid:1, throw excption....程序并没有退出，而是永远的“卡”在那里了，也就是发生了死锁。 那么这种情况该怎么避免呢？ 这个时候就需要std::lock_guard登场了。std::lock_guard只有构造函数和析构函数。简单的来说：当调用构造函数时，会自动调用传入的对象的lock()函数，而当调用析构函数时，自动调用unlock()函数（这就是所谓的RAII，读者可自行搜索）。我们修改一下demo3。 Demo4——避免死锁，lock_guarddemo4保存为：mutex_demo4_lock_guard.cpp123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;mutex&gt;#include &lt;chrono&gt;#include &lt;stdexcept&gt;int counter = 0;std::mutex mtx; // 保护countervoid increase_proxy(int time, int id) &#123; for (int i = 0; i &lt; time; i++) &#123; // std::lock_guard对象构造时，自动调用mtx.lock()进行上锁 // std::lock_guard对象析构时，自动调用mtx.unlock()释放锁 std::lock_guard&lt;std::mutex&gt; lk(mtx); // 线程1上锁成功后，抛出异常：未释放锁 if (id == 1) &#123; throw std::runtime_error(&quot;throw excption....&quot;); &#125; // 当前线程休眠1毫秒 std::this_thread::sleep_for(std::chrono::milliseconds(1)); counter++; &#125;&#125;void increase(int time, int id) &#123; try &#123; increase_proxy(time, id); &#125; catch (const std::exception&amp; e)&#123; std::cout &lt;&lt; &quot;id:&quot; &lt;&lt; id &lt;&lt; &quot;, &quot; &lt;&lt; e.what() &lt;&lt; std::endl; &#125;&#125;int main(int argc, char** argv) &#123; std::thread t1(increase, 10000, 1); std::thread t2(increase, 10000, 2); t1.join(); t2.join(); std::cout &lt;&lt; &quot;counter:&quot; &lt;&lt; counter &lt;&lt; std::endl; return 0;&#125;执行上述代码，结果为：123[root@2d129aac5cc5 demo]# ./mutex_demo4_lock_guardid:1, throw excption....counter:10000结果符合预期。所以，推荐使用std::mutex和std::lock_guard搭配使用，避免死锁的发生。 std::lock_guard的第二个构造函数实际上，std::lock_guard有两个构造函数，具体的（参考：cppreference）：123explicit lock_guard( mutex_type&amp; m ); (1) (since C++11)lock_guard( mutex_type&amp; m, std::adopt_lock_t t ); (2) (since C++11)lock_guard( const lock_guard&amp; ) = delete; (3) (since C++11)在demo4中我们使用了第1个构造函数，第3个为拷贝构造函数，定义为删除函数。这里我们来重点说一下第2个构造函数。 第2个构造函数有两个参数，其中第二个参数类型为：std::adopt_lock_t。这个构造函数假定：当前线程已经上锁成功，所以不再调用lock()函数。这里不再给出具体的例子，如果想了解这种构造函数是如何工作的，可以看这里，链接中给的例子很简洁。 总结：本篇主要讲述c++多线程编程中锁的基本用法，主要展示了std::mutex和std::lock_guard的用法。其实c++还提供了std::lock_guard的加强版：std::unique_lock，以后找机会我们再补充它的使用方法，简单来说：相比于std::lock_guard, std::unique_lock提供了更多的接口，也就使其更加灵活，但性能方面也会有些受损。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://wangtianyang.com/tags/C/"}]},{"title":"【数据库】分布式事务理论","slug":"【数据库】分布式事务理论","date":"2022-03-18T03:35:26.000Z","updated":"2023-01-06T13:48:49.297Z","comments":true,"path":"2022/03/18/【数据库】分布式事务理论/","link":"","permalink":"https://wangtianyang.com/2022/03/18/%E3%80%90%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%91%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%90%86%E8%AE%BA/","excerpt":"基础概念什么是事务什么是事务？举个生活中的例子：你去小卖铺买东西，“一手交钱，一手交货”就是一个事务的例子，交钱和交货必须全部成功，事务才算成功，任一个活动失败，事务将撤销所有已成功的活动。 明白上述例子，再来看事务的定义：事务可以看做是一次大的活动，它由不同的小活动组成，这些活动要么全部成功，要么全部失败。","text":"基础概念什么是事务什么是事务？举个生活中的例子：你去小卖铺买东西，“一手交钱，一手交货”就是一个事务的例子，交钱和交货必须全部成功，事务才算成功，任一个活动失败，事务将撤销所有已成功的活动。 明白上述例子，再来看事务的定义：事务可以看做是一次大的活动，它由不同的小活动组成，这些活动要么全部成功，要么全部失败。 本地事务在计算机系统中，更多的是通过关系型数据库来控制事务，这是利用数据库本身的事务特性来实现的，因此叫数据库事务，由于应用主要靠关系数据库来控制事务，而数据库通常和应用在同一个服务器，所以基于关系型数据库的事务又被称为本地事务。回顾一下数据库事务的四大特性 ACID：A（Atomic）：原子性，构成事务的所有操作，要么都执行完成，要么全部不执行，不可能出现部分成功部分失败的情况。C（Consistency）：一致性，在事务执行前后，数据库的一致性约束没有被破坏。比如：张三向李四转100元，转账前和转账后的数据是正确状态这叫一致性，如果出现张三转出100元，李四账户没有增加100元这就出现了数据错误，就没有达到一致性。I（Isolation）：隔离性，数据库中的事务一般都是并发的，隔离性是指并发的两个事务的执行互不干扰，一个事务不能看到其他事务运行过程的中间状态。通过配置事务隔离级别可以避免脏读、重复读等问题。D（Durability）：持久性，事务完成之后，该事务对数据的更改会被持久化到数据库，且不会被回滚。 数据库事务在实现时会将一次事务涉及的所有操作全部纳入到一个不可分割的执行单元，该执行单元中的所有操作要么都成功，要么都失败，只要其中任一操作执行失败，都将导致整个事务的回滚。 分布式事务随着互联网的快速发展，软件系统由原来的单体应用转变为分布式应用，下图描述了单体应用向微服务的演变：分布式系统会把一个应用系统拆分为可独立部署的多个服务，因此需要服务与服务之间远程协作才能完成事务操作，这种分布式系统环境下由不同的服务之间通过网络远程协作完成事务称之为分布式事务，例如用户注册送积分事务、创建订单减库存事务，银行转账事务等都是分布式事务。 我们知道本地事务依赖数据库本身提供的事务特性来实现，因此以下逻辑可以控制本地事务：1234begin transaction；//1.本地数据库操作：张三减少金额 //2.本地数据库操作：李四增加金额 commit transation;但是在分布式环境下，会变成下边这样：1234begin transaction；//1.本地数据库操作：张三减少金额 //2.远程调用：让李四增加金额 commit transation;可以设想，当远程调用让李四增加金额成功了，由于网络问题远程调用并没有返回，此时本地事务提交失败就回滚了张三减少金额的操作，此时张三和李四的数据就不一致了。 因此在分布式架构的基础上，传统数据库事务就无法使用了，张三和李四的账户不在一个数据库中甚至不在一个应用系统里，实现转账事务需要通过远程调用，由于网络问题就会导致分布式事务问题。 分布式事务产生的场景 典型的场景就是微服务架构微服务之间通过远程调用完成事务操作。比如：订单微服务和库存微服务，下单的同时订单微服务请求库存微服务减库存。简言之：跨JVM进程产生分布式事务。 单体系统访问多个数据库实例。当单体系统需要访问多个数据库（实例）时就会产生分布式事务。 比如：用户信息和订单信息分别在两个MySQL实例存储，用户管理系统删除用户信息，需要分别删除用户信息及用户的订单信息，由于数据分布在不同的数据实例，需要通过不同的数据库链接去操作数据，此时产生分布式事务。 简言之：跨数据库实例产生分布式事务。3、多服务访问同一个数据库实例。比如：订单微服务和库存微服务即使访问同一个数据库也会产生分布式事务，原因就是跨JVM进程，两个微服务持有了不同的数据库链接进行数据库操作，此时产生分布式事务。 分布式事务基础理论CAP理论理解CAPCAP是 Consistency、Availability、Partition tolerance 三个词语的缩写，分别表示一致性、可用性、分区容忍性。如下图，是商品信息管理的执行流程：整体执行流程如下： 商品服务请求主数据库写入商品信息（添加商品、修改商品、删除商品） 主数据库向商品服务响应写入成功。 商品服务请求从数据库读取商品信息。 C - Consistency：一致性是指写操作后的读操作可以读取到最新的数据状态，当数据分布在多个节点上，从任意结点读取到的数据都是最新的状态。 上图中，商品信息的读写要满足一致性就是要实现如下目标： 商品服务写入主数据库成功，则向从数据库查询新数据也成功。 商品服务写入主数据库失败，则向从数据库查询新数据也失败。 如何实现一致性？ 写入主数据库后要将数据同步到从数据库。 写入主数据库后，在向从数据库同步期间要将从数据库锁定，待同步完成后再释放锁，以免在新数据写入成功后，向从数据库查询到旧的数据。 分布式系统一致性的特点： 由于存在数据同步的过程，写操作的响应会有一定的延迟。 为了保证数据一致性会对资源暂时锁定，待数据同步完成释放锁定资源。 如果请求数据同步失败的结点则会返回错误信息，一定不会返回旧数据。 A - Availability：可用性是指任何事务操作都可以得到响应结果，且不会出现响应超时或响应错误。 上图中，商品信息读取满足可用性就是要实现如下目标： 从数据库接收到数据查询的请求则立即能够响应数据查询结果。 从数据库不允许出现响应超时或响应错误。 如何实现可用性？ 写入主数据库后要将数据同步到从数据库。 由于要保证从数据库的可用性，不可将从数据库中的资源进行锁定。 即时数据还没有同步过来，从数据库也要返回要查询的数据，哪怕是旧数据，如果连旧数据也没有则可以按照约定返回一个默认信息，但不能返回错误或响应超时。 分布式系统可用性的特点： 所有请求都有响应，且不会出现响应超时或响应错误。 P - Partition tolerance：通常分布式系统的各各结点部署在不同的子网，这就是网络分区，不可避免的会出现由于网络问题而导致结点之间通信失败，此时仍可对外提供服务，这叫分区容忍性。 上图中，商品信息读写满足分区容忍性就是要实现如下目标： 主数据库向从数据库同步数据失败不影响读写操作。 其一个结点挂掉不影响另一个结点对外提供服务。 如何实现分区容忍性？ 尽量使用异步取代同步操作，例如使用异步方式将数据从主数据库同步到从数据，这样结点之间能有效的实现松耦合。 添加从数据库结点，其中一个从结点挂掉其它从结点提供服务。 分布式分区容忍性的特点： 分区容忍性分是布式系统具备的基本能力。 CAP组合方式1、上边商品管理的例子是否同时具备CAP呢？在所有分布式事务场景中不会同时具备CAP三个特性，因为在具备了P的前提下C和A是不能共存的。比如：下图满足了P即表示实现分区容忍：本图分区容忍的含义是：1) 主数据库通过网络向从数据同步数据，可以认为主从数据库部署在不同的分区，通过网络进行交互。2) 当主数据库和从数据库之间的网络出现问题不影响主数据库和从数据库对外提供服务。3) 其一个结点挂掉不影响另一个结点对外提供服务。如果要实现C则必须保证数据一致性，在数据同步的时候为防止向从数据库查询不一致的数据则需要将从数据库数据锁定，待同步完成后解锁，如果同步失败从数据库要返回错误信息或超时信息。如果要实现A则必须保证数据可用性，不管任何时候都可以向从数据查询数据，则不会响应超时或返回错误信息。通过分析发现在满足P的前提下C和A存在矛盾性。 2、CAP有哪些组合方式呢？所以在生产中对分布式事务处理时要根据需求来确定满足CAP的哪两个方面。1）AP：放弃一致性，追求分区容忍性和可用性。这是很多分布式系统设计时的选择。例如：上边的商品管理，完全可以实现AP，前提是只要用户可以接受所查询的到数据在一定时间内不是最新的即可。通常实现AP都会保证最终一致性，后面讲的BASE理论就是根据AP来扩展的，一些业务场景 比如：订单退款，今日退款成功，明日账户到账，只要用户可以接受在一定时间内到账即可。2）CP：放弃可用性，追求一致性和分区容错性，我们的zookeeper其实就是追求的强一致，又比如跨行转账，一次转账请求要等待双方银行系统都完成整个事务才算完成。3）CA：放弃分区容忍性，即不进行分区，不考虑由于网络不通或结点挂掉的问题，则可以实现一致性和可用性。那么系统将不是一个标准的分布式系统，我们最常用的关系型数据就满足了CA。上边的商品管理，如果要实现CA则架构如下：主数据库和从数据库中间不再进行数据同步，数据库可以响应每次的查询请求，通过事务隔离级别实现每个查询请求都可以返回最新的数据。 总结通过上面我们已经学习了CAP理论的相关知识，CAP是一个已经被证实的理论：一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容忍性（Partition tolerance）这三项中的两项。它可以作为我们进行架构设计、技术选型的考量标准。对于多数大型互联网应用的场景，结点众多、部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到N个9（99.99..%），并要达到良好的响应性能来提高用户体验，因此一般都会做出如下选择：保证P和A，舍弃C强一致，保证最终一致性。 BASE理论1、理解强一致性和最终一致性CAP理论告诉我们一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容忍性（Partition tolerance）这三项中的两项，其中AP在实际应用中较多，AP即舍弃一致性，保证可用性和分区容忍性，但是在实际生产中很多场景都要实现一致性，比如前边我们举的例子主数据库向从数据库同步数据，即使不要一致性，但是最终也要将数据同步成功来保证数据一致，这种一致性和CAP中的一致性不同，CAP中的一致性要求在任何时间查询每个结点数据都必须一致，它强调的是强一致性，但是最终一致性是允许可以在一段时间内每个结点的数据不一致，但是经过一段时间每个结点的数据必须一致，它强调的是最终数据的一致性。 2、Base理论介绍BASE 是 Basically Available(基本可用)、Soft state(软状态)和 Eventually consistent (最终一致性)三个短语的缩写。BASE理论是对CAP中AP的一个扩展，通过牺牲强一致性来获得可用性，当出现故障允许部分不可用但要保证核心功能可用，允许数据在一段时间内是不一致的，但最终达到一致状态。满足BASE理论的事务，我们称之为“柔性事务”。 基本可用:分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。如，电商网站交易付款出现问题了，商品依然可以正常浏览。软状态:由于不要求强一致性，所以BASE允许系统中存在中间状态（也叫软状态），这个状态不影响系统可用性，如订单的”支付中”、“数据同步中”等状态，待数据最终一致后状态改为“成功”状态。最终一致:最终一致是指经过一段时间后，所有节点数据都将会达到一致。如订单的”支付中”状态，最终会变为“支付成功”或者”支付失败”，使订单状态与实际交易结果达成一致，但需要一定时间的延迟、等待。","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://wangtianyang.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"【笔经】美团2020校招（选择题）","slug":"【笔经】美团2020校招（选择题）","date":"2022-03-17T06:46:42.000Z","updated":"2023-01-06T13:53:23.399Z","comments":true,"path":"2022/03/17/【笔经】美团2020校招（选择题）/","link":"","permalink":"https://wangtianyang.com/2022/03/17/%E3%80%90%E7%AC%94%E7%BB%8F%E3%80%91%E7%BE%8E%E5%9B%A22020%E6%A0%A1%E6%8B%9B%EF%BC%88%E9%80%89%E6%8B%A9%E9%A2%98%EF%BC%89/","excerpt":"","text":"下面哪项叙述是分布式事务2PC模式的特点（ ）A、适用于高并发场景B、以牺牲可用性为代价来保证数据的一致性C、将分布式事务拆分成本地事务后再进行处理D、将事务处理的同步阻塞操作变为异步操作 分析2PC即两阶段提交协议，是将整个事务流程分为两个阶段，准备阶段（Prepare phase）、提交阶段（commit phase）。 准备阶段（Prepare phase）：事务管理器给每个参与者发送Prepare消息，每个数据库参与者在本地执行事务，并写本地的Undo/Redo日志，此时事务没有提交。（Undo日志是记录修改前的数据，用于数据库回滚，Redo日志是记录修改后的数据，用于提交事务后写入数据文件） 提交阶段（commit phase）：如果事务管理器收到了参与者的执行失败或者超时消息时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据事务管理器的指令执行提交或者回滚操作，并释放事务处理过程中使用的锁资源。注意:必须在最后阶段释放锁资源。 某应用软件传输层协议指定为TCP时，则对应socket应指定为（ ）类型A、SOCK_DGRAMB、SOCK_PACKETC、SOCK_RAWD、SOCK_STREAM 分析SOCK_STREAM (TCP)、SOCK_DGRAM (UDP) 工作在传输层，SOCK_RAW 工作在网络层。 关于SELECT age FROM students LIMIT 5，下面说法正确的是（ ）A、返回年龄小于5的B、返回不超过5行C、返回年龄前5的D、返回年龄大于5的 分析以下为在MySQL数据库中查询数据通用的 SELECT 语法：1234SELECT column_name,column_nameFROM table_name[WHERE Clause][LIMIT N][ OFFSET M] 查询语句中你可以使用一个或者多个表，表之间使用逗号(,)分割，并使用WHERE语句来设定查询条件。 SELECT 命令可以读取一条或者多条记录。 你可以使用星号（*）来代替其他字段，SELECT语句会返回表的所有字段数据 你可以使用 WHERE 语句来包含任何条件。 你可以使用 LIMIT 属性来设定返回的记录数。 你可以通过OFFSET指定SELECT语句开始查询的数据偏移量。默认情况下偏移量为0。","categories":[{"name":"笔经","slug":"笔经","permalink":"https://wangtianyang.com/categories/%E7%AC%94%E7%BB%8F/"}],"tags":[]},{"title":"【面经】闪思面试（八股+算法）（2022/03/16）","slug":"【面经】闪思面试（八股-算法）（2022-03-16）","date":"2022-03-16T08:22:35.000Z","updated":"2023-01-06T13:49:53.259Z","comments":true,"path":"2022/03/16/【面经】闪思面试（八股-算法）（2022-03-16）/","link":"","permalink":"https://wangtianyang.com/2022/03/16/%E3%80%90%E9%9D%A2%E7%BB%8F%E3%80%91%E9%97%AA%E6%80%9D%E9%9D%A2%E8%AF%95%EF%BC%88%E5%85%AB%E8%82%A1-%E7%AE%97%E6%B3%95%EF%BC%89%EF%BC%882022-03-16%EF%BC%89/","excerpt":"请讲出以下代码的输出结果，并解释a,b,g三个变量分别存放在内存的哪片区域。1234567891011121314151617#include &lt;iostream&gt;using namespace std;int g;int main() &#123; int a; static float b; a += 1; b += 100; g += 200; cout&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;b&lt;&lt;endl; cout&lt;&lt;g&lt;&lt;endl; return 0;&#125;","text":"请讲出以下代码的输出结果，并解释a,b,g三个变量分别存放在内存的哪片区域。1234567891011121314151617#include &lt;iostream&gt;using namespace std;int g;int main() &#123; int a; static float b; a += 1; b += 100; g += 200; cout&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;b&lt;&lt;endl; cout&lt;&lt;g&lt;&lt;endl; return 0;&#125; 答：b=100，g=200，a输出不明。原因：变量a为局部变量，储存在栈内，值必须由程序员初始化，变量g和变量b分别为全局变量和静态变量，存放在全局/静态储存区，编译器会自动初始化为零。 请讲出以下代码的输出结果，并说明引用和指针的区别。123456789101112131415161718#include &lt;iostream&gt;using namespace std;void swap(int &amp;r1, int &amp;r2);int main() &#123; int num1 = 10; int num2 = 20; swap(num1, num2); cout&lt;&lt;num1&lt;&lt;&quot; &quot;&lt;&lt;num2&lt;&lt;endl;&#125;void swap(int &amp;r1, int &amp;r2) &#123; int temp = r1; r1 = r2; r2 = temp;&#125; 答：num1=20，num2=10。引用和指针的区别与联系： 引用只能在定义时初始化一次，之后不能改变指向其它变量（从一而终）；指针变量的值可变。 引用必须指向有效的变量，指针可以为空。 sizeof指针对象和引用对象的意义不一样。sizeof引用得到的是所指向的变量的大小，而sizeof指针是对象地址的大小。 指针和引用自增(++)自减(—)意义不一样。引用是指值自增，而指针的自增指的是指向下一段内存地址。 相对而言，引用比指针更安全。 说明面向过程编程和面向对象编程的区别面向过程是一种以过程为中心的编程思想，它首先分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，在使用时依次调用，是一种基础的顺序的思维方式。面向过程开发方式是对计算机底层结构的一层抽象，它将程序分为数据和操纵数据的操作两部分，其核心问题是数据结构和算法的开发和优化。常见的支持面向过程的编程语言有 C语言、COBOL 语言等。 面向对象是按人们认识客观世界的系统思维方式，采用基于对象（实体）的概念建立模型，模拟客观世界分析、设计、实现软件的编程思想，通过面向对象的理念使计算机软件系统能与现实世界中的系统一一对应。 面向对象方法直接把所有事物都当作独立的对象，处理问题过程中所思考的不再主要是怎样用数据结构来描述问题，而是直接考虑重现问题中各个对象之间的关系。面向对象方法的基础实现中也包含面向过程的思想。常见的支持面向对象的编程语言有 C++ 语言、C＃ 语言、Java 语言等。 面向对象编程的三大特性是什么？封装、继承、多态。多态的两个前提：继承和虚函数。 C++类的封装特性在编程中如何体现？这些设计有什么好处？public、private、protected。更安全，可以让继承或者调用类时不能访问到不想被访问的成员变量和成员函数。 使用类定义了两个对象，请问类中的成员变量在内存中有几份？成员函数有几份？两份成员变量，一份成员函数。 请讲一下this指针及其如何使用。在 C++ 中，每一个对象都能通过 this 指针来访问自己的地址。this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。 主要作用：结合上一题，因为this是所有成员函数的隐含参数，所以即使成员函数只拷贝了一份，也可以确定是哪一个对象在调用该成员函数。次要作用：当对象内部成员变量与形参同名时，可以加以区分。 构造函数是否可以重载？不同作用域中的函数名称和参数完全相同的两个函数，是不是重载？构造函数可以，析构函数不可以。不是，它们就只是没有任何关系的两个函数而已。 C++继承的方式分为哪几种？请说明，使用派生类定义一个对象时，基类和派生类的构造函数的调用顺序；该对象消亡时，基类和派生类的析构函数的调用顺序。析构函数的函数名如何写？ public、protected、private。作用就是继承时把基类public区域的内容转换成对应权限。 基类构造函数-&gt;派生类构造函数-&gt;派生类析构函数-&gt;基类析构函数。 构造函数的名字和类名相同，而析构函数的名字是在类名前面加一个~符号。 请讲出以下代码的输出结果。输出结果是否符合预期？如果不符合，请对以下函数进行改造。请讲出C++是通过什么机制实现多态的。123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;//基类Peopleclass People &#123;public: People(char *name, int age); void display();protected: char *m_name; int m_age;&#125;;People::People(char *name, int age):m_name(name),m_age(age)&#123;&#125;void People::display() &#123; cout&lt;&lt;m_name&lt;&lt;&quot;今年&quot;&lt;&lt;m_age&lt;&lt;&quot;岁了，是个小学生。&quot;&lt;&lt;endl;&#125;//派生类Teacherclass Teacher: public People &#123;public: Teacher(char *name, int age, int salary); void display();protected: int m_salary;&#125;;Teacher::Teacher(char *name, int age, int salary):People(name, age), m_salary(salary)&#123;&#125;void Teacher::display() &#123; cout&lt;&lt;m_name&lt;&lt;&quot;今年&quot;&lt;&lt;m_age&lt;&lt;&quot;岁了，是一名教师，每月有&quot;&lt;&lt;m_salary&lt;&lt;&quot;元的收入。&quot;&lt;&lt;endl;&#125;int main() &#123; People *p = new People(&quot;宋佳&quot;, 10); p-&gt;display(); p = new Teacher(&quot;李亮&quot;, 45, 10000); p-&gt;display(); return 0;&#125; 答：运行结果：12宋佳今年10岁了，是个小学生。李亮今年45岁了，是个小学生。原因：多态需要虚函数！所以应该在People类的display()函数前加上virtual关键字。 请解释C++中浅拷贝和深拷贝的区别。 在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的；但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象，所以，此时，必须采用深拷贝。 深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。简而言之，当数据成员中有指针时，必须要用深拷贝。 请说明C++中的模板类别，使用模板的好处，使用模板是要用到哪个关键字。模板是C++支持参数化多态的工具，使用模板可以使用户为类或者函数声明一种一般模式，使得类中的某些数据成员或者成员函数的参数、返回值取得任意类型。 模板有两种类别：函数模板和类模板。 使用模板的好处就是能够让程序员编写与类型无关的代码。 格式：1234template &lt;class 形参名，class 形参名，......&gt; 返回类型 函数名(参数列表)&#123; 函数体&#125; 其中template和class是关键字，class可以用typename关键字代替。 例：12345template &lt;typename T&gt;inline T const&amp; Max (T const&amp; a, T const&amp; b) &#123; return a &lt; b ? b:a; &#125; 请说明以下代码中3个const各自的作用。1template &lt;class T&gt; const std::string&amp; function(const T*) const; 第一个const修饰函数返回值。Const 修饰返回值分三种情况： const 修饰内置类型的返回值，修饰与不修饰返回值作用一样。 const 修饰自定义类型的作为返回值，此时返回的值不能作为左值使用，既不能被赋值，也不能被修改。 const 修饰返回的指针或者引用，是为了避免返回值被修改。 第二个const修饰参数传递。const 修饰函数参数可以分为三种情况： const 修饰指针指向的内容，比如const int *p = 8;，则内容为不可变量。 const 修饰指针，比如int* const p = &amp;a;，则指针为不可变量。 结合1和2。 第三个const修饰类成员函数，其目的是防止成员函数修改被调用对象的值。默认在成员函数的第一个位置是this指针，如果在成员函数（只能是成员函数，要是类的静态函数或者是非成员函数就不可以在函数后面加上const）后面加const，则说明this指针的值是不可以修改的，只能读取。而如果函数里面试图改变成员变量的值，这样编辑器肯定是不允许的，所以会出现错误的。 C++有哪些临时变量 当函数的返回值没有赋值给其他变量时，会产生临时变量 类型转换时的中间变量 要访问容器的元素，需要通过什么？有哪些类型？迭代器。STL定义了五种迭代器。 迭代器类别 说明 输入 从容器中读取元素。输入迭代器只能一次读入一个元素向前移动，输入迭代器只支持一遍算法，同一个输入迭代器不能两遍遍历一个序列 输出 向容器中写入元素。输出迭代器只能一次一个元素向前移动。输出迭代器只支持一遍算法，统一输出迭代器不能两次遍历一个序列 正向 组合输入迭代器和输出迭代器的功能，并保留在容器中的位置 反向 组合正向迭代器和逆向迭代器的功能，支持多遍算法 随机访问 组合双向迭代器的功能与直接访问容器中任何元素的功能，即可向前向后跳过任意个元素 请讲出STL中vector、map、unordered_map的用途。map底层是红黑树，优点是有序，时间复杂度为O(logn)；unordered_map底层是哈希表，优点是搜索更快，时间复杂度为O(1)。其他略。 用C++实现一个单向链表，要求实现增加元素、获得元素、弹出元素的功能。略。 用C++实现快排。略。","categories":[{"name":"面经","slug":"面经","permalink":"https://wangtianyang.com/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[]},{"title":"【数据库】Redis","slug":"【数据库】Redis","date":"2022-03-06T08:45:34.000Z","updated":"2023-01-06T13:47:42.888Z","comments":true,"path":"2022/03/06/【数据库】Redis/","link":"","permalink":"https://wangtianyang.com/2022/03/06/%E3%80%90%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%91Redis/","excerpt":"Redis 持久化机制Redis是一个支持持久化的内存数据库，通过持久化机制把内存中的数据同步到硬盘文件来保证数据持久化。当Redis重启后通过把硬盘文件重新加载到内存，就能达到恢复数据的目的。 实现：单独创建fork()一个子进程，将当前父进程的数据库数据复制到子进程的内存中，然后由子进程写入到临时文件中，持久化的过程结束了，再用这个临时文件替换上次的快照文件，然后子进程退出，内存释放。 RDB是Redis默认的持久化方式。按照一定的时间周期策略把内存的数据以快照的形式保存到硬盘的二进制文件。即Snapshot快照存储，对应产生的数据文件为dump.rdb，通过配置文件中的save参数来定义快照的周期。（ 快照可以是其所表示的数据的一个副本，也可以是数据的一个复制品。） AOF： Redis会将每一个收到的写命令都通过Write函数追加到文件最后，类似于MySQL的binlog。当Redis重启是会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。 当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。","text":"Redis 持久化机制Redis是一个支持持久化的内存数据库，通过持久化机制把内存中的数据同步到硬盘文件来保证数据持久化。当Redis重启后通过把硬盘文件重新加载到内存，就能达到恢复数据的目的。 实现：单独创建fork()一个子进程，将当前父进程的数据库数据复制到子进程的内存中，然后由子进程写入到临时文件中，持久化的过程结束了，再用这个临时文件替换上次的快照文件，然后子进程退出，内存释放。 RDB是Redis默认的持久化方式。按照一定的时间周期策略把内存的数据以快照的形式保存到硬盘的二进制文件。即Snapshot快照存储，对应产生的数据文件为dump.rdb，通过配置文件中的save参数来定义快照的周期。（ 快照可以是其所表示的数据的一个副本，也可以是数据的一个复制品。） AOF： Redis会将每一个收到的写命令都通过Write函数追加到文件最后，类似于MySQL的binlog。当Redis重启是会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。 当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。 缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题 缓存雪崩：我们可以简单的理解为：由于原有缓存失效，新缓存未到期间 (例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。 解决办法：大多数系统设计者考虑用加锁（ 最多的解决方案）或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。还有一个简单方案就时讲缓存失效时间分散开。 缓存穿透：缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。 解决办法：最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴。 5TB的硬盘上放满了数据，请写一个算法将这些数据进行排重。如果这些数据是一些32bit大小的数据该如何解决？如果是64bit的呢？对于空间的利用到达了一种极致，那就是Bitmap和布隆过滤器(Bloom Filter)。 Bitmap： 典型的就是哈希表 缺点是，Bitmap对于每个元素只能记录1bit信息，如果还想完成额外的功能，恐怕只能靠牺牲更多的空间、时间来完成了。 布隆过滤器（推荐）就是引入了k(k&gt;1)k(k&gt;1)个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。 它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。 Bloom-Filter算法的核心思想就是利用多个不同的Hash函数来解决“冲突”。 Hash存在一个冲突（碰撞）的问题，用同一个Hash得到的两个URL的值有可能相同。为了减少冲突，我们可以多引入几个Hash，如果通过其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的Hash函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是Bloom-Filter的基本思想。 Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。 缓存预热：缓存预热这个应该是一个比较常见的概念，相信很多小伙伴都应该可以很容易的理解，缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！ 解决办法：1、直接写个缓存刷新页面，上线时手工操作下； 2、数据量不大，可以在项目启动的时候自动进行加载； 3、定时刷新缓存； 缓存更新：除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种： 定时去清理过期的缓存； 当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。 缓存降级：当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。 降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。以参考日志级别设置预案： 一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级； 警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送警告； 错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级； 严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。 服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。 热点数据和冷数据是什么热点数据，缓存才有价值。对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。频繁修改的数据，看情况考虑使用缓存 对于上面两个例子，寿星列表、导航信息都存在一个特点，就是信息修改频率不高，读取通常非常高的场景。 对于热点数据，比如我们的某IM产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。再举个例子，某导航产品，我们将导航信息，缓存以后可能读取数百万次。 数据更新前至少读取两次，缓存才有意义。这个是最基本的策略，如果缓存还没有起作用就失效了，那就没有太大价值了。 那存不存在，修改频率很高，但是又不得不考虑缓存的场景呢？有！比如，这个读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某助手产品的，点赞数，收藏数，分享数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到Redis缓存，减少数据库压力。 Memcache与Redis的区别都有哪些？ 存储方式：Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。 Redis有部份存在硬盘上，redis可以持久化其数据； 数据支持类型：memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型 ，提供list，set，zset，hash等数据结构的存储； 使用底层模型不同：它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求； value 值大小不同：Redis 最大可以达到 1 gb；memcache 只有 1 mb； redis的速度比memcached快很多； Redis支持数据的备份，即master-slave模式的数据备份。 单线程的redis为什么这么快 纯内存操作 单线程操作，避免了频繁的上下文切换 采用了非阻塞I/O多路复用机制 redis的数据类型，以及每种数据类型的使用场景一共五种。 String：这个其实没啥好说的，最常规的set/get操作，value可以是String也可以是数字。一般做一些复杂的计数功能的缓存。 hash：这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做单点登录的时候，就是用这种数据结构存储用户信息，以cookie Id作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。 list： 使用List的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用lrange命令，做基于redis的分页功能，性能极佳，用户体验好。本人还用一个场景，很合适—取行情信息。就也是个生产者和消费者的场景。LIST可以很好的完成排队，先进先出的原则。 set：因为set堆放的是一堆不重复值的集合。所以可以做全局去重的功能。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。 另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。 sorted set：sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做排行榜应用，取TOP N操作。 Redis 内部结构 dict：本质上是为了解决算法中的查找问题（Searching）是一个用于维护key和value映射关系的数据结构，与很多语言中的Map或dictionary类似。 本质上是为了解决算法中的查找问题（Searching） sds（简单动态字符串）：sds就等同于char * 它可以存储任意二进制数据，不能像C语言字符串那样以字符’\\0’来标识字符串的结 束，因此它必然有个长度字段。 skiplist（跳跃表）：跳表是一种实现起来很简单，单层多指针的链表，它查找效率很高，堪比优化过的二叉平衡树，且比平衡树的实现， quicklist ziplist（压缩表）：ziplist是一个编码后的列表，是由一系列特殊编码的连续内存块组成的顺序型数据结构， redis的过期策略以及内存淘汰机制redis采用的是定期删除+惰性删除策略。 为什么不用定时删除策略? 定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略。 定期删除+惰性删除是如何工作的呢?定期删除，redis默认每个100 ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100 ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100 ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。 于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。 采用定期删除+惰性删除就没其他问题了么? 不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制。 在redis.conf中有一行配置1maxmemory-policy volatile-lru该配置就是配内存淘汰策略的(什么，你没配过？好好反省一下自己) volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰 volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰 volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰 allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰 allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰 no-eviction（驱逐）：禁止驱逐数据，新写入操作会报错 ps：如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。 Redis 为什么是单线程的官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）Redis利用队列技术将并发访问变为串行访问 1）绝大部分请求是纯粹的内存操作（非常快速）2）采用单线程,避免了不必要的上下文切换和竞争条件 3）非阻塞IO优点： 1.速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1) \\2. 支持丰富数据类型，支持string，list，set，sorted set，hash 3.支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行 \\4. 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除如何解决redis的并发竞争key问题 同时有多个子系统去set一个key。这个时候要注意什么呢？ 不推荐使用redis的事务机制。因为我们的生产环境，基本都是redis集群环境，做了数据分片操作。你一个事务中有涉及到多个key操作的时候，这多个key不一定都存储在同一个redis-server上。因此，redis的事务机制，十分鸡肋。 (1)如果对这个key操作，不要求顺序： 准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可 (2)如果对这个key操作，要求顺序： 分布式锁+时间戳。 假设这会系统B先抢到锁，将key1设置为{valueB 3 : 05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了。以此类推。 (3) 利用队列，将set方法变成串行访问也可以redis遇到高并发，如果保证读写key的一致性 对redis的操作都是具有原子性的,是线程安全的操作,你不用考虑并发问题,redis内部已经帮你处理好并发的问题了。 有没有尝试进行多机redis 的部署？如何保证数据一致的？主从复制，读写分离 一类是主数据库（master）一类是从数据库（slave），主数据库可以进行读写操作，当发生写操作的时候自动将数据同步到从数据库，而从数据库一般是只读的，并接收主数据库同步过来的数据，一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库。 对于大量的请求怎么样处理redis是一个单线程程序，也就说同一时刻它只能处理一个客户端请求； redis是通过IO多路复用（select，epoll）来处理多个客户端请求的 Redis 常见性能问题和解决方案？ Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件； 如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次； 为了主从复制的速度和连接的稳定性， Master 和 Slave 最好在同一个局域网内； 尽量避免在压力很大的主库上增加从库； 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3… 讲解下Redis线程模型文件事件处理器包括分别是套接字、I/O 多路复用程序、文件事件分派器（dispatcher）、以及事件处理器。使用 I/O 多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。I/O 多路复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。 工作原理：I/O 多路复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。尽管多个文件事件可能会并发地出现，但 I/O 多路复用程序总是会将所有产生事件的套接字都入队到一个队列里面，然后通过这个队列，以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字：当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕），I/O 多路复用程序才会继续向文件事件分派器传送下一个套接字。如果一个套接字又可读又可写的话，那么服务器将先读套接字，后写套接字。 为什么Redis的操作是原子性的，怎么保证原子性的？对于Redis而言，命令的原子性指的是：一个操作的不可以再分，操作要么执行，要么不执行。 Redis的操作之所以是原子性的，是因为Redis是单线程的。 Redis本身提供的所有API都是原子操作，Redis中的事务其实是要保证批量操作的原子性。 多个命令在并发中也是原子性的吗？ 不一定， 将get和set改成单命令操作，incr 。使用Redis的事务，或者使用Redis+Lua==的方式实现. Redis事务Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的 Redis会将一个事务中的所有命令序列化，然后按顺序执行。 redis 不支持回滚“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。 如果在一个事务中的命令出现错误，那么所有的命令都不会执行； 如果在一个事务中出现运行错误，那么正确的命令会被执行。 MULTI命令用于开启一个事务，它总是返回OK。MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。 EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。当操作被打断时，返回空值 nil 。 通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。 WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。 Redis实现分布式锁Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系Redis中可以使用SETNX命令实现分布式锁。 将 key 的值设为 value ，当且仅当 key 不存在。 若给定的 key 已经存在，则 SETNX 不做任何动作解锁：使用del key命令就能释放锁解决死锁： 通过Redis中expire()给锁设定最大持有时间，如果超过，则Redis来帮我们释放锁。 使用setnx key “当前系统时间+锁持有的时间”和getset key “当前系统时间+锁持有的时间”组合的命令就可以实现。","categories":[{"name":"八股文","slug":"八股文","permalink":"https://wangtianyang.com/categories/%E5%85%AB%E8%82%A1%E6%96%87/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://wangtianyang.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"【数据库】MySQL","slug":"【数据库】MySQL","date":"2022-03-06T08:19:16.000Z","updated":"2023-01-06T13:47:56.257Z","comments":true,"path":"2022/03/06/【数据库】MySQL/","link":"","permalink":"https://wangtianyang.com/2022/03/06/%E3%80%90%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%91MySQL/","excerpt":"","text":"数据库索引的实现原理（B+树）在介绍B+树之前， 先简单的介绍一下B树。 B树B树概念B树也称B-树,它是一颗多路平衡查找树。首先，B树和B+树都是从最简单的二叉树变换而来的，我们来看看B树的定义： 每个节点最多有m-1个关键字（可以存有的键值对）。 根节点最少可以只有1个关键字。 非根节点至少有m/2个关键字。 每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。 所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。 每个节点都存有索引和数据，也就是对应的key和value。 所以，根节点的关键字数量范围：1 &lt;= k &lt;= m-1，非根节点的关键字数量范围：m/2 &lt;= k &lt;= m-1。 描述一颗B树时需要指定它的阶数，阶数表示了一个节点最多有多少个孩子节点，一般用字母m表示阶数。 B树插入插入的时候，我们需要记住一个规则：判断当前结点key的个数是否小于等于m-1，如果满足，直接插入即可，如果不满足，将节点的中间的key将这个节点分为左右两部分，中间的节点放到父节点中即可。 例子：在5阶B树中，结点最多有4个key,最少有2个key（注意：下面的节点统一用一个节点表示key和value）。 插入18，70，50, 40 插入22 插入22时，发现这个节点的关键字已经大于4了，所以需要进行分裂，分裂的规则在上面已经讲了，分裂之后，如下 接着插入23，25，39 分裂，得到下面的 B树删除B树的删除操作相对于插入操作是相对复杂一些的，但是，你知道记住几种情况，一样可以很轻松的掌握的。 例子：现在有一个初始状态是下面这样的B树，然后进行删除操作。 删除15，这种情况是删除叶子节点的元素，如果删除之后，节点数还是大于m/2，这种情况只要直接删除即可。 接着，我们把22删除，这种情况的规则：22是非叶子节点，对于非叶子节点的删除，我们需要用后继key（元素）覆盖要删除的key，然后在后继key所在的子支中删除该后继key。对于删除22，需要将后继元素24移到被删除的22所在的节点。 此时发现26所在的节点只有一个元素，小于2个（m/2），这个节点不符合要求，这时候的规则（向兄弟节点借元素）：如果删除叶子节点，如果删除元素后元素个数少于（m/2），并且它的兄弟节点的元素大于（m/2），也就是说兄弟节点的元素比最少值m/2还多，将先将父节点的元素移到该节点，然后将兄弟节点的元素再移动到父节点。这样就满足要求了。 接着删除28，删除叶子节点，删除后不满足要求，所以，我们需要考虑向兄弟节点借元素，但是，兄弟节点也没有多的节点（2个），借不了，怎么办呢？如果遇到这种情况，首先，还是将先将父节点的元素移到该节点，然后，将当前节点及它的兄弟节点中的key合并，形成一个新的节点。 B+树相同点： 根节点至少一个元素 非根节点元素范围：m/2 &lt;= k &lt;= m-1 不同点： B+树有两种类型的节点：内部结点（也称索引结点）和叶子结点。内部节点就是非叶子节点，内部节点不存储数据，只存储索引，数据都存储在叶子节点。 内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。 每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。 父节点存有右孩子的第一个元素的索引。 插入对于插入操作很简单，只需要记住一个技巧即可：当节点元素数量大于m-1的时候，按中间元素分裂成左右两部分，中间元素分裂到父节点当做索引存储，但是，本身中间元素还是分裂右边这一部分的。 下面以一颗5阶B+树的插入过程为例，5阶B+树的节点最少2个元素，最多4个元素。 插入5，10，15，20 插入25，此时元素数量大于4个了，分裂 接着插入26，30，继续分裂 删除对于删除操作是比B树简单一些的，因为叶子节点有指针的存在，向兄弟节点借元素时，不需要通过父节点了，而是可以直接通过兄弟节移动即可（前提是兄弟节点的元素大于m/2），然后更新父节点的索引；如果兄弟节点的元素不大于m/2（兄弟节点也没有多余的元素），则将当前节点和兄弟节点合并，并且删除父节点中的key，下面我们看看具体的实例。 初始状态 删除10，删除后，不满足要求，发现左边兄弟节点有多余的元素，所以去借元素，最后，修改父节点索引 删除元素5，发现不满足要求，并且发现左右兄弟节点都没有多余的元素，所以，可以选择和兄弟节点合并，最后修改父节点索引 发现父节点索引也不满足条件，所以，需要做跟上面一步一样的操作 B和B+树的区别B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。 B+ 树的优点 B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子几点上关联的数据也具有更好的缓存命中率。 B树的优点在于：由于B树的每一个节点都包含key和value，因此如果经常访问的元素离根节点更近，这种情况下访问也更迅速： 使用B树和B+树的比较InnoDB的索引使用的是B+树实现，B+树对比B树的好处： IO次数少：B+树的中间结点只存放索引，数据都存在叶结点中，因此中间结点可以存更多的数据，让索引树更加矮胖； 范围查询效率更高：B树需要中序遍历整个树，只B+树需要遍历叶结点中的链表； 查询效率更加稳定：每次查询都需要从根结点到叶结点，路径长度相同，所以每次查询的效率都差不多 使用B树索引和哈希索引的比较哈希索引能以 O(1) 时间进行查找，但是只支持精确查找，无法用于部分查找和范围查找，无法用于排序与分组；B树索引支持大于小于等于查找，范围查找。哈希索引遇到大量哈希值相等的情况后查找效率会降低。哈希索引不支持数据的排序。 使用索引的优点 大大加快了数据的检索速度； 可以显著减少查询中分组和排序的时间； 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性； 将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起） 缺点：建立和维护索引耗费时间空间，更新索引很慢。 哪些情况下索引会失效？ 以%(表示任意0个或多个字符)开头的LIKE语句； OR语句前后没有同时使用索引； 数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）； 对于多列索引，必须满足最左匹配原则/最左前缀原则 (最左优先：多列索引col1、col2和col3，则 索引生效的情形包括 col1或col1，col2或col1，col2，col3)； 如果MySQL估计全表扫描比索引快，则不使用索引（比如非常小的表） 在哪些地方适合创建索引？ 某列经常作为最大最小值； 经常被查询的字段； 经常用作表连接的字段； 经常出现在ORDER BY/GROUP BY/DISTINCT后面的字段 创建索引时需要注意什么？ 只应建立在小字段上，而不要对大文本或图片建立索引（一页存储的数据越多一次IO操作获取的数据越大效率越高）； 建立索引的字段应该非空，在MySQL中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。应该用0、一个特殊的值或者一个空串代替NULL； 选择数据密度大（唯一值占总数的百分比很大）的字段作索引 索引的分类？ 普通索引 唯一索引 UNIQUE：索引列的值必须唯一，但允许有空值； 主键索引 PRIMARY KEY：必须唯一，不允许空值（是一种特殊的唯一索引；MySQL创建主键时默认为聚集索引，但主键也可以是非聚集索引）； 单列索引和多列索引/复合索引（Composite）：索引的列数； 覆盖（Covering）索引：索引包含了所有满足查询所需要的数据，查询的时候只需要读取索引而不需要回表读取数据； 聚集（Clustered）索引/非聚集索引：对磁盘上存放数据的物理地址重新组织以使这些数据按照指定规则排序的一种索引（数据的物理排列顺序和索引排列顺序一致）。因此每张表只能创建一个聚集索引（因为要改变物理存储顺序）。优点是查询速度快，因为可以直接按照顺序得到需要数据的物理地址。缺点是进行修改的速度较慢。对于需要经常搜索范围的值很有效。非聚集索引只记录逻辑顺序，并不改变物理顺序； 虚拟索引（Virtual）：模拟索引的存在而不用真正创建一个索引，用于快速测试创建索引对执行计划的影响。没有相关的索引段，不增加存储空间的使用 MySQL的两种存储引擎 InnoDB 和 MyISAM 的区别？ InnoDB支持事务，可以进行Commit和Rollback； MyISAM 只支持表级锁，而 InnoDB 还支持行级锁，提高了并发操作的性能； InnoDB 支持外键； MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢； MyISAM 支持压缩表和空间数据索引，InnoDB需要更多的内存和存储； InnoDB 支持在线热备份 应用场景 MyISAM管理非事务表。它提供高速存储和检索（MyISAM强调的是性能，每次查询具有原子性，其执行速度比InnoDB更快），以及全文搜索能力。如果表比较小，或者是只读数据（有大量的SELECT），还是可以使用MyISAM； InnoDB支持事务，并发情况下有很好的性能，基本可以替代MyISAM 热备份和冷备份 热备份：在数据库运行的情况下备份的方法。优点：可按表或用户备份，备份时数据库仍可使用，可恢复至任一时间点。但是不能出错 冷备份：数据库正常关闭后，将关键性文件复制到另一位置的备份方式。优点：操作简单快速，恢复简单 如何优化数据库？SQL 语句的优化 分析慢查询日志：记录了在MySQL中响应时间超过阀值long_query_time的SQL语句，通过日志去找出IO大的SQL以及发现未命中索引的SQL 使用 Explain 进行分析：通过explain命令可以得到表的读取顺序、数据读取操作的操作类型、哪些索引可以使用、哪些索引被实际使用、表之间的引用以及被扫描的行数等问题； 应尽量避免在 where 子句中使用!=、&lt;、&gt;操作符或对字段进行null值判断，否则将引擎放弃使用索引而进行全表扫描； 只返回必要的列：最好不要使用 SELECT * 语句； 只返回必要的行：使用 LIMIT 语句来限制返回的数据； 将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有： 让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用； 分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余的查询； 减少锁竞争 索引的优化注意会引起索引失效的情况，以及在适合的地方建立索引 数据库表结构的优化 设计表时遵循三大范式； 选择合适的数据类型：尽可能不要存储NULL字段；使用简单的数据类型（int, varchar/ text）； 表的水平切分（Sharding）：将同一个表中的记录拆分到多个结构相同的表中（策略：哈希取模；根据ID范围来分）。当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓解单个数据库的压力； 表的垂直切分：将一张表按列切分成多个表。可以将不常用的字段单独放在同一个表中；把大字段独立放入一个表中；或者把经常使用的字段（关系密切的）放在一张表中。垂直切分之后业务更加清晰，系统之间整合或扩展容易，数据维护简单 系统配置的优化 操作系统：增加TCP支持的队列数； MySQL配置文件优化：缓存池大小和个数设置 硬件的优化 磁盘性能：固态硬盘； CPU：多核且高频； 内存：增大内存 什么是主从复制？实现原理是什么？主从复制（Replication）是指数据可以从一个MySQL数据库主服务器复制到一个或多个从服务器，从服务器可以复制主服务器中的所有数据库或者特定的数据库，或者特定的表。默认采用异步模式。 实现原理： 主服务器 binary log dump 线程：将主服务器中的数据更改（增删改）日志写入 Binary log 中； 从服务器 I/O 线程：负责从主服务器读取binary log，并写入本地的 Relay log； 从服务器 SQL 线程：负责读取 Relay log，解析出主服务器已经执行的数据更改，并在从服务器中重新执行（Replay），保证主从数据的一致性 为什么要主从复制？ 读写分离：主服务器负责写，从服务器负责读 缓解了锁的争用，即使主服务器中加了锁，依然可以进行读操作； 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销； 增加冗余，提高可用性 数据实时备份，当系统中某个节点发生故障时，可以方便的故障切换 降低单个服务器磁盘I/O访问的频率，提高单个机器的I/O性能 关系型数据库和非关系型数据库的区别？非关系型数据库的优势： 性能 NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。 可扩展性 同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。 关系型数据库的优势： 复杂查询 可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。 事务支持 使得对于安全性能很高的数据访问要求得以实现。","categories":[{"name":"八股文","slug":"八股文","permalink":"https://wangtianyang.com/categories/%E5%85%AB%E8%82%A1%E6%96%87/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://wangtianyang.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"【数据库】数据库基础","slug":"【数据库】数据库基础","date":"2022-03-06T07:46:27.000Z","updated":"2023-01-06T13:48:04.990Z","comments":true,"path":"2022/03/06/【数据库】数据库基础/","link":"","permalink":"https://wangtianyang.com/2022/03/06/%E3%80%90%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%91%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/","excerpt":"为什么需要数据库？数据库之前常用存储数据方式： 数组、集合 等数据结构，即存在内存中 缺点：内存具有易失性，比如一断电数据就会丢失 文件 缺点：不好查询 数据库的优点： 数据持久化 统一管理，易于查询 数据库的两种类型关系型 &amp; 非关系型 关系型： 表 非关系型： 文档 事务的概念和特性？概念：数据库事务(transaction)是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行，要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。以BEGIN TRANSACTION开始，以ROLLBACK/COMMIT结束 特性（ACID）： 原子性（Atomicity）：逻辑上是不可分割的操作单元，事务的所有操作要么全部提交成功，要么全部失败回滚（用回滚日志实现，反向执行日志中的操作）； 一致性（Consistency）：事务的执行必须使数据库保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的； 隔离性（Isolation）：一个事务所做的修改在最终提交以前，对其它事务是不可见的（并发执行的事务之间不能相互影响）； 持久性（Durability）：一旦事务提交成功，对数据的修改是永久性的","text":"为什么需要数据库？数据库之前常用存储数据方式： 数组、集合 等数据结构，即存在内存中 缺点：内存具有易失性，比如一断电数据就会丢失 文件 缺点：不好查询 数据库的优点： 数据持久化 统一管理，易于查询 数据库的两种类型关系型 &amp; 非关系型 关系型： 表 非关系型： 文档 事务的概念和特性？概念：数据库事务(transaction)是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行，要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。以BEGIN TRANSACTION开始，以ROLLBACK/COMMIT结束 特性（ACID）： 原子性（Atomicity）：逻辑上是不可分割的操作单元，事务的所有操作要么全部提交成功，要么全部失败回滚（用回滚日志实现，反向执行日志中的操作）； 一致性（Consistency）：事务的执行必须使数据库保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的； 隔离性（Isolation）：一个事务所做的修改在最终提交以前，对其它事务是不可见的（并发执行的事务之间不能相互影响）； 持久性（Durability）：一旦事务提交成功，对数据的修改是永久性的 会出现哪些并发一致性问题？ 丢失修改：一个事务对数据进行了修改，在事务提交之前，另一个事务对同一个数据进行了修改，覆盖了之前的修改； 脏读（Dirty Read）：一个事务读取了被另一个事务修改、但未提交（进行了回滚）的数据，造成两个事务得到的数据不一致； 不可重复读（Nonrepeatable Read）：在同一个事务中，某查询操作在一个时间读取某一行数据和之后一个时间读取该行数据，发现数据已经发生修改（针对update操作）； 幻读（Phantom Read）：当同一查询多次执行时，由于其它事务在这个数据范围内执行了插入操作，会导致每次返回不同的结果集（和不可重复读的区别：针对的是一个数据整体/范围；并且针对insert/delete操作） 数据库的四种隔离级别？ 未提交读（Read Uncommited）：在一个事务提交之前，它的执行结果对其它事务也是可见的。会导致脏读、不可重复读、幻读； 提交读（Read Commited）：一个事务只能看见已经提交的事务所作的改变。可避免脏读问题； 可重复读（Repeatable Read）：可以确保同一个事务在多次读取同样的数据时得到相同的结果。（MySQL的默认隔离级别）。可避免不可重复读； 可串行化（Serializable）：强制事务串行执行，使之不可能相互冲突，从而解决幻读问题。可能导致大量的超时现象和锁竞争，实际很少使用。 什么是乐观锁和悲观锁？ 悲观锁：认为数据随时会被修改，因此每次读取数据之前都会上锁，防止其它事务读取或修改数据；应用于数据更新比较频繁的场景； 乐观锁：操作数据时不会上锁，但是更新时会判断在此期间有没有别的事务更新这个数据，若被更新过，则失败重试；适用于读多写少的场景。乐观锁的实现方式有： 加一个版本号或者时间戳字段，每次数据更新时同时更新这个字段； 先读取想要更新的字段或者所有字段，更新的时候比较一下，只有字段没有变化才进行更新 常见的封锁类型？意向锁是InnoDB[1]自动加的， 不需用户干预。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)； 对于普通SELECT语句，InnoDB不会加任何锁；事务可以通过以下语句显式给记录集加共享锁或排他锁：共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE。其他 session 仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。 排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE。其他 session 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁 排它锁（Exclusive Lock）/ X锁：事务对数据加上X锁时，只允许此事务读取和修改此数据，并且其它事务不能对该数据加任何锁； 共享锁（Shared Lock）/ S锁：加了S锁后，该事务只能对数据进行读取而不能修改，并且其它事务只能加S锁，不能加X锁 意向锁（Intention Locks）： 一个事务在获得某个数据行对象的 S 锁之前，必须先获得整个表的 IS 锁或更强的锁； 一个事务在获得某个数据行对象的 X 锁之前，必须先获得整个表的 IX 锁； IS/IX 锁之间都是兼容的； 好处：如果一个事务想要对整个表加X锁，就需要先检测是否有其它事务对该表或者该表中的某一行加了锁，这种检测非常耗时。有了意向锁之后，只需要检测整个表是否存在IX/IS/X/S锁就行了锁的作用：用于管理对共享资源的并发访问，保证数据库的完整性和一致性 意向锁相互兼容，因为IX、IS只是表明申请更低层次级别元素（比如 page、记录）的X、S操作。 表级S锁和X、IX锁不兼容：因为上了表级S锁后，不允许其他事务再加X锁。 表级X锁和 IS、IX、S、X不兼容：因为上了表级X锁后，会修改数据，所以即使是行级排他锁，因为表级锁定的行肯定包括行级锁定的行，所以表级X和IX、X都不兼容。：上了行级X锁后，行级X锁不会因为有别的事务上了IX而堵塞，一个mysql是允许多个行级X锁同时存在的，只要他们不是针对相同的数据行。 封锁粒度的概念MySQL 中提供了两种封锁粒度：行级锁以及表级锁。 封锁粒度小： 好处：锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高； 坏处：系统开销大（加锁、释放锁、检查锁的状态都需要消耗资源） MySQL加锁12SELECT ... LOCK In SHARE MODE; //SSELECT ... FOR UPDATE; //X 什么是三级封锁协议？ 一级封锁协议：事务在修改数据之前必须先对其加X锁，直到事务结束才释放。可以解决丢失修改问题（两个事务不能同时对一个数据加X锁，避免了修改被覆盖）； 二级封锁协议：在一级的基础上，事务在读取数据之前必须先加S锁，读完后释放。可以解决脏读问题（如果已经有事务在修改数据，就意味着已经加了X锁，此时想要读取数据的事务并不能加S锁，也就无法进行读取，避免了读取脏数据）； 三级封锁协议：在二级的基础上，事务在读取数据之前必须先加S锁，直到事务结束才能释放。可以解决不可重复读问题（避免了在事务结束前其它事务对数据加X锁进行修改，保证了事务期间数据不会被其它事务更新） 什么是两段锁协议？事务必须严格分为两个阶段对数据进行加锁和解锁的操作，第一阶段加锁，第二阶段解锁。也就是说一个事务中一旦释放了锁，就不能再申请新锁了。 可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。事务遵循两段锁协议是保证可串行化调度的充分条件。 计算机系统对并发事务中并发操作的调度是随机的，而不同的调度可能会产生不同的结果。在计算机中，多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行它们时的结果相同，我们称这种调度策略为可串行化（Serializable）调度。 并发事务都遵守两段锁协议，则对这些事务的任何并发调度策略都是可串行化的 。 并发事务的一个调度是可串行化的，不一定所有事务都符合两段锁协议 。 什么是 MVCC？多版本并发控制（Multi-Version Concurrency Control, MVCC），MVCC在每行记录后面都保存有两个隐藏的列，用来存储创建版本号和删除版本号。 创建版本号：创建一个数据行时的事务版本号（事务版本号：事务开始时的系统版本号；系统版本号：每开始一个新的事务，系统版本号就会自动递增）； 删除版本号：删除操作时的事务版本号； 各种操作： 插入操作时，记录创建版本号； 删除操作时，记录删除版本号； 更新操作时，先记录删除版本号，再新增一行记录创建版本号； 查询操作时，要符合以下条件才能被查询出来：删除版本号未定义或大于当前事务版本号（删除操作是在当前事务启动之后做的）；创建版本号小于或等于当前事务版本号（创建操作是事务完成或者在事务启动之前完成） 版本链我们先来理解一下版本链的概念。在InnoDB引擎表中，它的聚簇索引记录中有两个必要的隐藏列： trx_id这个id用来存储的每次对某条聚簇索引记录进行修改的时候的事务id。 roll_pointer每次对哪条聚簇索引记录有修改的时候，都会把老版本写入undo日志中。这个roll_pointer就是存了一个指针，它指向这条聚簇索引记录的上一个版本的位置，通过它来获得上一个版本的记录信息。(注意插入操作的undo日志没有这个属性，因为它没有老版本) ReadView说了版本链我们再来看看ReadView。已提交读和可重复读的区别就在于它们生成ReadView的策略不同。 通过版本号减少了锁的争用，提高了系统性能；可以实现提交读和可重复读两种隔离级别，未提交读无需使用MVCC。 ReadView中主要就是有个列表来存储我们系统中当前活跃着的读写事务，也就是begin了还未提交的事务。通过这个列表来判断记录的某个版本是否对当前事务可见。假设当前列表里的事务id为[80,100]。 如果你要访问的记录版本的事务id为50，比当前列表最小的id80小，那说明这个事务在之前就提交了，所以对当前活动的事务来说是可访问的。如果你要访问的记录版本的事务id为70,发现此事务在列表id最大值和最小值之间，那就再判断一下是否在列表内，如果在那就说明此事务还未提交，所以版本不能被访问。如果不在那说明事务已经提交，所以版本可以被访问。如果你要访问的记录版本的事务id为110，那比事务列表最大id100都大，那说明这个版本是在ReadView生成之后才发生的，所以不能被访问。 举个例子 ，在已提交读隔离级别下： 比如此时有一个事务id为100的事务，修改了name,使得的name等于小明2，但是事务还没提交。则此时的版本链是那此时另一个事务发起了select 语句要查询id为1的记录，那此时生成的ReadView 列表只有[100]。那就去版本链去找了，首先肯定找最近的一条，发现trx_id是100,也就是name为小明2的那条记录，发现在列表内，所以不能访问。 这时候就通过指针继续找下一条，name为小明1的记录，发现trx_id是60，小于列表中的最小id,所以可以访问，直接访问结果为小明1。 那这时候我们把事务id为100的事务提交了，并且新建了一个事务id为110也修改id为1的记录，并且不提交事务这时候版本链就是这时候之前那个select事务又执行了一次查询,又要查询id为1的记录。 这个时候关键的地方来了 如果你是已提交读隔离级别，这时候你会重新一个ReadView，那你的活动事务列表中的值就变了，变成了[110]。 按照上的说法，你去版本链通过trx_id对比查找到合适的结果就是小明2。 如果你是可重复读隔离级别，这时候你的ReadView还是第一次select时候生成的ReadView,也就是列表的值还是[100]。所以select的结果是小明1。所以第二次select结果和第一次一样，所以叫可重复读！ 也就是说已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的ReadView,而可重复读隔离级别则在第一次读的时候生成一个ReadView，之后的读都复用之前的ReadView。 快照读与当前读快照读(snapshot read)使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销： 简单的select操作(不包括 select … lock in share mode, select … for update)1select * from table ...; 当前读(current read)更新数据时，都是先读后写，而这个读，就是当前读。当前读读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁： select * from table where ? lock in share mode; select * from table where ? for update; insert; update; delete; 数据库的范式？ 第一范式（1NF，Normal Form）：属性不应该是可分的。举例：如果将“电话”作为一个属性（一列），是不符合1NF的，因为电话这个属性可以分解为家庭电话和移动电话…如果将“移动电话”作为一个属性，就符合1NF； 第二范式 2NF：每个非主属性完全依赖于主属性集（候选键集）； B完全依赖于A，就是说A中的所有属性唯一决定B，属性少了就不能唯一决定，属性多了则有冗余（叫依赖不叫完全依赖）。举例：（学号，课程名）这个主属性集可以唯一决定成绩，但是对于学生姓名这个属性，（学号，课程名）这个属性集就是冗余的，所以学生姓名不完全依赖于（学号，课程名）这一属性集； 主属性集/候选码集：某一组属性能够唯一确定其它的属性（主键就是从候选键集中选的一个键），而其子集不能，这样的属性组中的属性就是主属性；不在候选码集中的属性成为非主属性； 可以通过分解来满足 2NF：将（学号，课程名，成绩）做成一张表；（学号，学生姓名）做成另一张表，避免大量的数据冗余； 满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情； 第三范式 3NF：在 2NF 的基础上，非主属性不传递依赖于主属性 传递依赖：如果C依赖于B，B依赖于A，那么C传递依赖于A； 3NF在2NF的基础上，消除了非主属性之间的依赖；比如一个表中，主属性有（学号），非主属性有（姓名，院系，院长名），可以看到院长名这个非主属性依赖于院系，传递依赖于学号。消除的办法是分解。 必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）； 不符合范式会出现哪些异常？ 冗余数据：某些同样的数据多次出现（如学生姓名）； 修改异常：修改了一个记录中的信息，另一个记录中相同的信息却没有修改； 删除异常：删除一个信息，那么也会丢失其它信息（删除一个课程，丢失了一个学生的信息）； 插入异常：无法插入（插入一个还没有课程信息的学生） 列举几种表连接方式？ 内连接（Inner Join）：仅将两个表中满足连接条件的行组合起来作为结果集 自然连接：只考虑属性相同的元组对； 等值连接：给定条件进行查询 外连接（Outer Join） 左连接：左边表的所有数据都有显示出来，右边的表数据只显示共同有的那部分，没有对应的部分补NULL； 右连接：和左连接相反； 全外连接（Full Outer Join）：查询出左表和右表所有数据，但是去除两表的重复数据 交叉连接（Cross Join）：返回两表的笛卡尔积（对于所含数据分别为m、n的表，返回m*n的结果） 什么是存储过程？有哪些优缺点？存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合。想要实现相应的功能时，只需要调用这个存储过程就行了（类似于函数，输入具有输出参数）。 优点： 预先编译，而不需要每次运行时编译，提高了数据库执行效率； 封装了一系列操作，对于一些数据交互比较多的操作，相比于单独执行SQL语句，可以减少网络通信量； 具有可复用性，减少了数据库开发的工作量； 安全性高，可以让没有权限的用户通过存储过程间接操作数据库； 更易于维护 缺点： 可移植性差，存储过程将应用程序绑定到了数据库上； 开发调试复杂：没有好的IDE； 修改复杂，需要重新编译，有时还需要更新程序中的代码以更新调用 Drop/Delete/Truncate的区别？ Delete用来删除表的全部或者部分数据，执行delete之后，用户需要提交之后才会执行，会触发表上的DELETE触发器（包含一个OLD的虚拟表，可以只读访问被删除的数据），DELETE之后表结构还在，删除很慢，一行一行地删，因为会记录日志，可以利用日志还原数据； Truncate删除表中的所有数据，这个操作不能回滚，也不会触发这个表上的触发器。操作比DELETE快很多（直接把表drop掉，再创建一个新表，删除的数据不能找回）。如果表中有自增（AUTO_INCREMENT）列，则重置为1； Drop命令从数据库中删除表，所有的数据行，索引和约束都会被删除；不能回滚，不会触发触发器； 什么是触发器？触发器（TRIGGER）是由事件（比如INSERT/UPDATE/DELETE）来触发运行的操作（不能被直接调用，不能接收参数）。在数据库里以独立的对象存储，用于保证数据完整性（比如可以检验或转换数据）。 有哪些约束类型？约束（Constraint）类型：主键（Primary Key）约束，唯一约束（Unique），检查约束，非空约束，外键（Foreign Key）约束。 什么是视图？什么是游标？ 视图：从数据库的基本表中通过查询选取出来的数据组成的虚拟表（数据库中存放视图的定义）。可以对其进行增/删/改/查等操作。视图是对若干张基本表的引用，一张虚表，查询语句执行的结果，不存储具体的数据（基本表数据发生了改变，视图也会跟着改变）；可以跟基本表一样，进行增删改查操作(ps:增删改操作有条件限制)；如连表查询产生的视图无法进行，对视图的增删改会影响原表的数据。好处： 通过只给用户访问视图的权限，保证数据的安全性； 简化复杂的SQL操作，隐藏数据的复杂性（比如复杂的连接）； 游标（Cursor）：用于定位在查询返回的结果集的特定行，以对特定行进行操作。使用游标可以方便地对结果集进行移动遍历，根据需要滚动或对浏览/修改任意行中的数据。主要用于交互式应用。 三级模式/二级映像 1.InnoDB，是MySQL和MariaDB的数据库引擎之一，最初由MySQL AB发行。InnoDB由Innobase Oy公司所开发，2006年五月时由甲骨文公司并购。与传统的ISAM与MyISAM相比，InnoDB的最大特色就是支持了ACID兼容的事务（Transaction）功能，类似于PostgreSQL。 ↩","categories":[{"name":"八股文","slug":"八股文","permalink":"https://wangtianyang.com/categories/%E5%85%AB%E8%82%A1%E6%96%87/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://wangtianyang.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"设计模式","slug":"【C-】设计模式","date":"2022-03-06T07:14:07.000Z","updated":"2023-01-06T13:45:56.296Z","comments":true,"path":"2022/03/06/【C-】设计模式/","link":"","permalink":"https://wangtianyang.com/2022/03/06/%E3%80%90C-%E3%80%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"工厂模式(Factory)在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。工厂模式作为一种创建模式，一般在创建复杂对象时，考虑使用；在创建简单对象时，建议直接new完成一个实例对象的创建。 简单工厂模式主要特点是需要在工厂类中做判断，从而创造相应的产品，当增加新产品时，需要修改工厂类。使用简单工厂模式，我们只需要知道具体的产品型号就可以创建一个产品。","text":"工厂模式(Factory)在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。工厂模式作为一种创建模式，一般在创建复杂对象时，考虑使用；在创建简单对象时，建议直接new完成一个实例对象的创建。 简单工厂模式主要特点是需要在工厂类中做判断，从而创造相应的产品，当增加新产品时，需要修改工厂类。使用简单工厂模式，我们只需要知道具体的产品型号就可以创建一个产品。 缺点：工厂类集中了所有产品类的创建逻辑，如果产品量较大，会使得工厂类变的非常臃肿。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/*关键代码：创建过程在工厂类中完成。*/#include &lt;iostream&gt;using namespace std;//定义产品类型信息typedef enum&#123; Tank_Type_56, Tank_Type_96, Tank_Type_Num&#125;Tank_Type;//抽象产品类class Tank&#123;public: virtual const string&amp; type() = 0;&#125;;//具体的产品类class Tank56 : public Tank&#123;public: Tank56():Tank(),m_strType(&quot;Tank56&quot;) &#123; &#125; // 在派生类的成员函数中使用override时，如果基类中无此函数，或基类中的函数并不是虚函数，编译器会给出相关错误信息。 const string&amp; type() override &#123; cout &lt;&lt; m_strType.data() &lt;&lt; endl; return m_strType; &#125;private: string m_strType;&#125;;//具体的产品类class Tank96 : public Tank&#123;public: Tank96():Tank(),m_strType(&quot;Tank96&quot;) &#123; &#125; const string&amp; type() override &#123; cout &lt;&lt; m_strType.data() &lt;&lt; endl; return m_strType; &#125;private: string m_strType;&#125;; //工厂类class TankFactory&#123;public: //根据产品信息创建具体的产品类实例，返回一个抽象产品类 Tank* createTank(Tank_Type type) &#123; switch(type) &#123; case Tank_Type_56: return new Tank56(); case Tank_Type_96: return new Tank96(); default: return nullptr; &#125; &#125;&#125;;int main()&#123; TankFactory* factory = new TankFactory(); Tank* tank56 = factory-&gt;createTank(Tank_Type_56); tank56-&gt;type(); Tank* tank96 = factory-&gt;createTank(Tank_Type_96); tank96-&gt;type(); delete tank96; tank96 = nullptr; delete tank56; tank56 = nullptr; delete factory; factory = nullptr; return 0;&#125; 工厂方法模式定义一个创建对象的接口，其子类去具体现实这个接口以完成具体的创建工作。如果需要增加新的产品类，只需要扩展一个相应的工厂类即可。 缺点：产品类数据较多时，需要实现大量的工厂类，这无疑增加了代码量。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/*关键代码：创建过程在其子类执行。*/#include &lt;iostream&gt;using namespace std;//产品抽象类class Tank&#123;public: virtual const string&amp; type() = 0;&#125;;//具体的产品类class Tank56 : public Tank&#123;public: Tank56():Tank(),m_strType(&quot;Tank56&quot;) &#123; &#125; const string&amp; type() override &#123; cout &lt;&lt; m_strType.data() &lt;&lt; endl; return m_strType; &#125;private: string m_strType;&#125;;//具体的产品类class Tank96 : public Tank&#123;public: Tank96():Tank(),m_strType(&quot;Tank96&quot;) &#123; &#125; const string&amp; type() override &#123; cout &lt;&lt; m_strType.data() &lt;&lt; endl; return m_strType; &#125;private: string m_strType;&#125;; //抽象工厂类，提供一个创建接口class TankFactory&#123;public: //提供创建产品实例的接口，返回抽象产品类 virtual Tank* createTank() = 0;&#125;;//具体的创建工厂类，使用抽象工厂类提供的接口，去创建具体的产品实例class Tank56Factory : public TankFactory&#123;public: Tank* createTank() override &#123; return new Tank56(); &#125;&#125;;//具体的创建工厂类，使用抽象工厂类提供的接口，去创建具体的产品实例class Tank96Factory : public TankFactory&#123;public: Tank* createTank() override &#123; return new Tank96(); &#125;&#125;;int main()&#123; TankFactory* factory56 = new Tank56Factory(); Tank* tank56 = factory56-&gt;createTank(); tank56-&gt;type(); TankFactory* factory96 = new Tank96Factory(); Tank* tank96 = factory96-&gt;createTank(); tank96-&gt;type(); delete tank96; tank96 = nullptr; delete factory96; factory96 = nullptr; delete tank56; tank56 = nullptr; delete factory56; factory56 = nullptr; return 0;&#125; 抽象工厂模式抽象工厂模式提供创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。 当存在多个产品系列，而客户端只使用一个系列的产品时，可以考虑使用抽象工厂模式。 缺点：当增加一个新系列的产品时，不仅需要现实具体的产品类，还需要增加一个新的创建接口，扩展相对困难。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125/** 关键代码：在一个工厂里聚合多个同类产品。* 以下代码以白色衣服和黑色衣服为例，白色衣服为一个产品系列，黑色衣服为一个产品系列。白色上衣搭配白色裤子， 黑色上衣搭配黑色裤字。每个系列的衣服由一个对应的工厂创建，这样一个工厂创建的衣服能保证衣服为同一个系列。*///抽象上衣类class Coat&#123;public: virtual const string&amp; color() = 0;&#125;;//黑色上衣类class BlackCoat : public Coat&#123;public: BlackCoat():Coat(),m_strColor(&quot;Black Coat&quot;) &#123; &#125; const string&amp; color() override &#123; cout &lt;&lt; m_strColor.data() &lt;&lt; endl; return m_strColor; &#125;private: string m_strColor;&#125;;//白色上衣类class WhiteCoat : public Coat&#123;public: WhiteCoat():Coat(),m_strColor(&quot;White Coat&quot;) &#123; &#125; const string&amp; color() override &#123; cout &lt;&lt; m_strColor.data() &lt;&lt; endl; return m_strColor; &#125;private: string m_strColor;&#125;; //抽象裤子类class Pants&#123;public: virtual const string&amp; color() = 0;&#125;;//黑色裤子类class BlackPants : public Pants&#123;public: BlackPants():Pants(),m_strColor(&quot;Black Pants&quot;) &#123; &#125; const string&amp; color() override &#123; cout &lt;&lt; m_strColor.data() &lt;&lt; endl; return m_strColor; &#125;private: string m_strColor;&#125;;//白色裤子类class WhitePants : public Pants&#123;public: WhitePants():Pants(),m_strColor(&quot;White Pants&quot;) &#123; &#125; const string&amp; color() override &#123; cout &lt;&lt; m_strColor.data() &lt;&lt; endl; return m_strColor; &#125;private: string m_strColor;&#125;;//抽象工厂类，提供衣服创建接口class Factory&#123;public: //上衣创建接口，返回抽象上衣类 virtual Coat* createCoat() = 0; //裤子创建接口，返回抽象裤子类 virtual Pants* createPants() = 0;&#125;;//创建白色衣服的工厂类，具体实现创建白色上衣和白色裤子的接口class WhiteFactory : public Factory&#123;public: Coat* createCoat() override &#123; return new WhiteCoat(); &#125; Pants* createPants() override &#123; return new WhitePants(); &#125;&#125;;//创建黑色衣服的工厂类，具体实现创建黑色上衣和白色裤子的接口class BlackFactory : public Factory&#123; Coat* createCoat() override &#123; return new BlackCoat(); &#125; Pants* createPants() override &#123; return new BlackPants(); &#125;&#125;; 单例模式(Singleton)单例模式顾名思义，保证一个类仅可以有一个实例化对象，并且提供一个可以访问它的全局接口。实现单例模式必须注意以下几点： 单例类只能由一个实例化对象。 单例类必须自己提供一个实例化对象。 单例类必须提供一个可以访问唯一实例化对象的接口。 单例模式分为懒汉和饿汉两种实现方式。 懒汉单例模式懒汉：故名思义，不到万不得已就不会去实例化类，也就是说在第一次用到类实例的时候才会去实例化一个对象。在访问量较小，甚至可能不会去访问的情况下，采用懒汉实现，这是以时间换空间。 非线程安全的懒汉单例模式1234567891011121314151617181920212223242526272829/** 关键代码：构造函数是私有的，不能通过赋值运算，拷贝构造等方式实例化对象。*///懒汉式一般实现：非线程安全，getInstance返回的实例指针需要deleteclass Singleton&#123;public: static Singleton* getInstance(); ~Singleton()&#123;&#125;private: Singleton()&#123;&#125; //构造函数私有 Singleton(const Singleton&amp; obj) = delete; //明确拒绝 Singleton&amp; operator=(const Singleton&amp; obj) = delete; //明确拒绝 static Singleton* m_pSingleton; // 静态(static)成员: 不是任意对象的组成部分,但由给定类的全体对象所共享的数据成员或函数成员。&#125;;Singleton* Singleton::m_pSingleton = NULL;Singleton* Singleton::getInstance()&#123; if(m_pSingleton == NULL) &#123; m_pSingleton = new Singleton; &#125; return m_pSingleton;&#125; 线程安全的懒汉单例模式1234567891011121314151617181920212223242526272829std::mutex mt;class Singleton&#123;public: static Singleton* getInstance();private: Singleton()&#123;&#125; //构造函数私有 Singleton(const Singleton&amp;) = delete; //明确拒绝 Singleton&amp; operator=(const Singleton&amp;) = delete; //明确拒绝 static Singleton* m_pSingleton; &#125;;Singleton* Singleton::m_pSingleton = NULL;Singleton* Singleton::getInstance()&#123; if(m_pSingleton == NULL) &#123; mt.lock(); if(m_pSingleton == NULL) &#123; m_pSingleton = new Singleton(); &#125; mt.unlock(); &#125; return m_pSingleton;&#125; 返回一个reference指向local static对象这种单例模式实现方式多线程可能存在不确定性：任何一种non-const static对象，不论它是local或non-local,在多线程环境下“等待某事发生”都会有麻烦。解决的方法：在程序的单线程启动阶段手工调用所有reference-returning函数。这种实现方式的好处是不需要去delete它。12345678910111213141516class Singleton&#123;public: static Singleton&amp; getInstance();private: Singleton()&#123;&#125; Singleton(const Singleton&amp;) = delete; //明确拒绝 Singleton&amp; operator=(const Singleton&amp;) = delete; //明确拒绝&#125;;Singleton&amp; Singleton::getInstance()&#123; static Singleton singleton; return singleton;&#125; 饿汉单例模式饿汉：饿了肯定要饥不择食。所以在单例类定义的时候就进行实例化。在访问量比较大，或者可能访问的线程比较多时，采用饿汉实现，可以实现更好的性能。这是以空间换时间。12345678910111213141516171819//饿汉式：线程安全，注意一定要在合适的地方去delete它class Singleton&#123;public: static Singleton* getInstance();private: Singleton()&#123;&#125; //构造函数私有 Singleton(const Singleton&amp;) = delete; //明确拒绝 Singleton&amp; operator=(const Singleton&amp;) = delete; //明确拒绝 static Singleton* m_pSingleton;&#125;;Singleton* Singleton::m_pSingleton = new Singleton();Singleton* Singleton::getInstance()&#123; return m_pSingleton;&#125; 外观模式(Facade)外观模式：为子系统中的一组接口定义一个一致的界面；外观模式提供一个高层的接口，这个接口使得这一子系统更加容易被使用；对于复杂的系统，系统为客户端提供一个简单的接口，把负责的实现过程封装起来，客户端不需要连接系统内部的细节。 以下情形建议考虑外观模式： 设计初期阶段，应有意识的将不同层分离，层与层之间建立外观模式。 开发阶段，子系统越来越复杂，使用外观模式提供一个简单的调用接口。 一个系统可能已经非常难易维护和扩展，但又包含了非常重要的功能，可以为其开发一个外观类，使得新系统可以方便的与其交互。 优点： 实现了子系统与客户端之间的松耦合关系。 客户端屏蔽了子系统组件，减少了客户端所需要处理的对象数据，使得子系统使用起来更方便容易。 更好的划分了设计层次，对于后期维护更加的容易。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/** 关键代码：客户与系统之间加一个外观层，外观层处理系统的调用关系、依赖关系等。*以下实例以电脑的启动过程为例，客户端只关心电脑开机的、关机的过程，并不需要了解电脑内部子系统的启动过程。*/#include &lt;iostream&gt;using namespace std;//抽象控件类，提供接口class Control&#123;public: virtual void start() = 0; virtual void shutdown() = 0;&#125;;//子控件， 主机class Host : public Control&#123;public: void start() override &#123; cout &lt;&lt; &quot;Host start&quot; &lt;&lt; endl; &#125; void shutdown() override &#123; cout &lt;&lt; &quot;Host shutdown&quot; &lt;&lt; endl; &#125;&#125;;//子控件， 显示屏class LCDDisplay : public Control&#123;public: void start() override &#123; cout &lt;&lt; &quot;LCD Display start&quot; &lt;&lt; endl; &#125; void shutdown() override &#123; cout &lt;&lt; &quot;LCD Display shutdonw&quot; &lt;&lt; endl; &#125;&#125;;//子控件， 外部设备class Peripheral : public Control&#123;public: void start() override &#123; cout &lt;&lt; &quot;Peripheral start&quot; &lt;&lt; endl; &#125; void shutdown() override &#123; cout &lt;&lt; &quot;Peripheral shutdown&quot; &lt;&lt; endl; &#125;&#125;;class Computer&#123;public: void start() &#123; m_host.start(); m_display.start(); m_peripheral.start(); cout &lt;&lt; &quot;Computer start&quot; &lt;&lt; endl; &#125; void shutdown() &#123; m_host.shutdown(); m_display.shutdown(); m_peripheral.shutdown(); cout &lt;&lt; &quot;Computer shutdown&quot; &lt;&lt; endl; &#125;private: Host m_host; LCDDisplay m_display; Peripheral m_peripheral;&#125;;int main()&#123; Computer computer; computer.start(); //do something computer.shutdown(); return 0;&#125; 模板模式(Template)模板模式：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 当多个类有相同的方法，并且逻辑相同，只是细节上有差异时，可以考虑使用模板模式。具体的实现上可以将相同的核心算法设计为模板方法，具体的实现细节有子类实现。 缺点:每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。 以生产电脑为例，电脑生产的过程都是一样的，只是一些装配的器件可能不同而已。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** 关键代码：在抽象类实现通用接口，细节变化在子类实现。*/#include &lt;iostream&gt;using namespace std;class Computer&#123;public: void product() &#123; installCpu(); installRam(); installGraphicsCard(); &#125;protected: virtual void installCpu() = 0; virtual void installRam() = 0; virtual void installGraphicsCard() = 0;&#125;;class ComputerA : public Computer&#123;protected: void installCpu() override &#123; cout &lt;&lt; &quot;ComputerA install Inter Core i5&quot; &lt;&lt; endl; &#125; void installRam() override &#123; cout &lt;&lt; &quot;ComputerA install 2G Ram&quot; &lt;&lt; endl; &#125; void installGraphicsCard() override &#123; cout &lt;&lt; &quot;ComputerA install Gtx940 GraphicsCard&quot; &lt;&lt; endl; &#125;&#125;;class ComputerB : public Computer&#123;protected: void installCpu() override &#123; cout &lt;&lt; &quot;ComputerB install Inter Core i7&quot; &lt;&lt; endl; &#125; void installRam() override &#123; cout &lt;&lt; &quot;ComputerB install 4G Ram&quot; &lt;&lt; endl; &#125; void installGraphicsCard() override &#123; cout &lt;&lt; &quot;ComputerB install Gtx960 GraphicsCard&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; ComputerB* c1 = new ComputerB(); c1-&gt;product(); delete c1; c1 = nullptr; return 0;&#125; 组合模式(Composite)组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得客户端对单个对象和组合对象的使用具有一直性。 既然讲到以树形结构表示“部分-整体”，那可以将组合模式想象成一根大树，将大树分成树枝和树叶两部分，树枝上可以再长树枝，也可以长树叶，树叶上则不能再长出别的东西。 以下情况可以考虑使用组合模式： 希望表示对象的部分-整体层次结构。 希望客户端忽略组合对象与单个对象的不同，客户端将统一的使用组合结构中的所有对象。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193/** 关键代码：树枝内部组合该接口，并且含有内部属性list，里面放Component。*/#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;memory&gt;using namespace std;//抽象类，提供组合和单个对象的一致接口class Company&#123;public: Company(const string&amp; name): m_name(name)&#123;&#125; virtual ~Company()&#123; cout &lt;&lt; &quot;~Company()&quot; &lt;&lt; endl;&#125; virtual void add(Company* ) = 0; virtual void remove(const string&amp;) = 0; virtual void display(int depth) = 0; virtual const string&amp; name() &#123; return m_name; &#125;protected: string m_name;&#125;;//具体的单个对象实现类，“树枝”类class HeadCompany : public Company&#123;public: HeadCompany(const string&amp; name): Company(name)&#123;&#125; virtual ~HeadCompany()&#123; cout &lt;&lt; &quot;~HeadCompany()&quot; &lt;&lt; endl;&#125; void add(Company* company) override &#123; shared_ptr&lt;Company&gt; temp(company); m_companyList.push_back(temp); &#125; void remove(const string&amp; strName) override &#123; list&lt;shared_ptr&lt;Company&gt;&gt;::iterator iter = m_companyList.begin(); for(; iter != m_companyList.end(); iter++) &#123; if((*iter).get()-&gt;name() == strName) &#123; //不应该在此处使用list&lt;T&gt;.erase(list&lt;T&gt;::iterator iter),会导致iter++错误，这里删除目 标元素之后，必须return。 m_companyList.erase(iter); return; &#125; &#125; &#125; void display(int depth) override &#123; for(int i = 0; i &lt; depth; i++) &#123; cout &lt;&lt; &quot;-&quot;; &#125; cout &lt;&lt; this-&gt;name().data() &lt;&lt; endl; list&lt;shared_ptr&lt;Company&gt;&gt;::iterator iter = m_companyList.begin(); for(; iter!= m_companyList.end(); iter++) &#123; (*iter).get()-&gt;display(depth + 1); &#125; &#125;private: list&lt;shared_ptr&lt;Company&gt;&gt; m_companyList;&#125;;//具体的单个对象实现类，“树叶”类class ResearchCompany : public Company&#123;public: ResearchCompany(const string&amp; name): Company(name)&#123;&#125; virtual ~ResearchCompany()&#123; cout &lt;&lt; &quot;~ResearchCompany()&quot; &lt;&lt; endl;&#125; void add(Company* ) override &#123; &#125; void remove(const string&amp;) override &#123; &#125; void display(int depth) override &#123; for(int i = 0; i &lt; depth; i++) &#123; cout &lt;&lt; &quot;-&quot;; &#125; cout &lt;&lt; m_name.data() &lt;&lt; endl; &#125;&#125;;//具体的单个对象实现类，“树叶”类class SalesCompany : public Company&#123;public: SalesCompany(const string&amp; name): Company(name)&#123;&#125; virtual ~SalesCompany()&#123; cout &lt;&lt; &quot;~SalesCompany()&quot; &lt;&lt; endl;&#125; void add(Company* ) override &#123; &#125; void remove(const string&amp;) override &#123; &#125; void display(int depth) override &#123; for(int i = 0; i &lt; depth; i++) &#123; cout &lt;&lt; &quot;-&quot;; &#125; cout &lt;&lt; m_name.data() &lt;&lt; endl; &#125;&#125;;//具体的单个对象实现类，“树叶”类class FinanceCompany : public Company&#123;public: FinanceCompany(const string&amp; name): Company(name)&#123;&#125; virtual ~FinanceCompany()&#123; cout &lt;&lt; &quot;~FinanceCompany()&quot; &lt;&lt; endl;&#125; void add(Company* ) override &#123; &#125; void remove(const string&amp;) override &#123; &#125; void display(int depth) override &#123; for(int i = 0; i &lt; depth; i++) &#123; cout &lt;&lt; &quot;-&quot;; &#125; cout &lt;&lt; m_name.data() &lt;&lt; endl; &#125;&#125;;int main()&#123; HeadCompany* headRoot = new HeadCompany(&quot;Head Root Company&quot;); HeadCompany* childRoot1 = new HeadCompany(&quot;Child Company A&quot;); ResearchCompany* r1 = new ResearchCompany(&quot;Research Company A&quot;); SalesCompany* s1 = new SalesCompany(&quot;Sales Company A&quot;); SalesCompany* s2 = new SalesCompany(&quot;Sales Company B&quot;); FinanceCompany* f1 = new FinanceCompany(&quot;FinanceCompany A&quot;); childRoot1-&gt;add(r1); childRoot1-&gt;add(s1); childRoot1-&gt;add(s2); childRoot1-&gt;add(f1); HeadCompany* childRoot2 = new HeadCompany(&quot;Child Company B&quot;); ResearchCompany* r2 = new ResearchCompany(&quot;Research Company B&quot;); SalesCompany* s3 = new SalesCompany(&quot;Sales Company C&quot;); SalesCompany* s4 = new SalesCompany(&quot;Sales Company D&quot;); FinanceCompany* f2 = new FinanceCompany(&quot;FinanceCompany B&quot;); childRoot2-&gt;add(r2); childRoot2-&gt;add(s3); childRoot2-&gt;add(s4); childRoot2-&gt;add(f2); headRoot-&gt;add(childRoot1); headRoot-&gt;add(childRoot2); headRoot-&gt;display(1); cout &lt;&lt; &quot;\\n***************\\n&quot; &lt;&lt; endl; childRoot1-&gt;remove(&quot;Sales Company B&quot;); headRoot-&gt;display(1); cout &lt;&lt; &quot;\\n***************\\n&quot; &lt;&lt; endl; delete headRoot; headRoot = nullptr; return 0;&#125; 代理模式代理模式：为其它对象提供一种代理以控制这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介作用。 优点： 职责清晰。真实的角色只负责实现实际的业务逻辑，不用关心其它非本职责的事务，通过后期的代理完成具体的任务。这样代码会简洁清晰。 代理对象可以在客户端和目标对象之间起到中介的作用，这样就保护了目标对象。 扩展性好。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** 关键代码：一个是真正的你要访问的对象(目标类)，一个是代理对象,真正对象与代理对象实现同一个接口,先访问代理* 类再访问真正要访问的对象。*/#include &lt;iostream&gt;using namespace std;class Gril&#123;public: Gril(const string&amp; name = &quot;gril&quot;):m_string(name)&#123;&#125; string getName() &#123; return m_string; &#125;private: string m_string;&#125;;class Profession&#123;public: virtual ~Profession()&#123;&#125; virtual void profess() = 0;&#125;;class YoungMan : public Profession&#123;public: YoungMan(const Gril&amp; gril):m_gril(gril)&#123;&#125; void profess() &#123; cout &lt;&lt; &quot;Young man love &quot; &lt;&lt; m_gril.getName().data() &lt;&lt; endl; &#125;private: Gril m_gril;&#125;;class ManProxy : public Profession&#123;public: ManProxy(const Gril&amp; gril):m_pMan(new YoungMan(gril))&#123;&#125; ~ManProxy() &#123; delete m_pMan; m_pMan = nullptr; &#125; void profess() &#123; m_pMan-&gt;profess(); &#125;private: YoungMan* m_pMan;&#125;;int main(int argc, char *argv[])&#123; Gril gril(&quot;heihei&quot;); ManProxy* proxy = new ManProxy(gril); proxy-&gt;profess(); delete proxy; proxy = nullptr; return 0;&#125; 观察者模式(Observer)观察者模式：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都要得到通知并自动更新。 观察者模式从根本上讲必须包含两个角色：观察者和被观察对象。 被观察对象自身应该包含一个容器来存放观察者对象，当被观察者自身发生改变时通知容器内所有的观察者对象自动更新。 观察者对象可以注册到被观察者的中，完成注册后可以检测被观察者的变化，接收被观察者的通知。当然观察者也可以被注销掉，停止对被观察者的监控。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138/** 关键代码：在目标类中增加一个ArrayList来存放观察者们。*/#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;memory&gt;using namespace std;class View;//被观察者抽象类 数据模型class DataModel&#123;public: virtual ~DataModel()&#123;&#125; virtual void addView(View* view) = 0; virtual void removeView(View* view) = 0; virtual void notify() = 0; //通知函数&#125;;//观察者抽象类 视图class View&#123;public: virtual ~View()&#123; cout &lt;&lt; &quot;~View()&quot; &lt;&lt; endl; &#125; virtual void update() = 0; virtual void setViewName(const string&amp; name) = 0; virtual const string&amp; name() = 0;&#125;;//具体的被观察类， 整数模型class IntDataModel:public DataModel&#123;public: ~IntDataModel() &#123; m_pViewList.clear(); &#125; virtual void addView(View* view) override &#123; shared_ptr&lt;View&gt; temp(view); auto iter = find(m_pViewList.begin(), m_pViewList.end(), temp); if(iter == m_pViewList.end()) &#123; m_pViewList.push_front(temp); &#125; else &#123; cout &lt;&lt; &quot;View already exists&quot; &lt;&lt; endl; &#125; &#125; void removeView(View* view) override &#123; auto iter = m_pViewList.begin(); for(; iter != m_pViewList.end(); iter++) &#123; if((*iter).get() == view) &#123; m_pViewList.erase(iter); cout &lt;&lt; &quot;remove view&quot; &lt;&lt; endl; return; &#125; &#125; &#125; virtual void notify() override &#123; auto iter = m_pViewList.begin(); for(; iter != m_pViewList.end(); iter++) &#123; (*iter).get()-&gt;update(); &#125; &#125;private: list&lt;shared_ptr&lt;View&gt;&gt; m_pViewList; &#125;;//具体的观察者类 表视图class TableView : public View&#123;public: TableView() : m_name(&quot;unknow&quot;)&#123;&#125; TableView(const string&amp; name) : m_name(name)&#123;&#125; ~TableView()&#123; cout &lt;&lt; &quot;~TableView(): &quot; &lt;&lt; m_name.data() &lt;&lt; endl; &#125; void setViewName(const string&amp; name) &#123; m_name = name; &#125; const string&amp; name() &#123; return m_name; &#125; void update() override &#123; cout &lt;&lt; m_name.data() &lt;&lt; &quot; update&quot; &lt;&lt; endl; &#125;private: string m_name;&#125;;int main()&#123; /* * 这里需要补充说明的是在此示例代码中，View一旦被注册到DataModel类之后，DataModel解析时会自动解析掉 * 内部容器中存储的View对象，因此注册后的View对象不需要在手动去delete，再去delete View对象会出错。 */ View* v1 = new TableView(&quot;TableView1&quot;); View* v2 = new TableView(&quot;TableView2&quot;); View* v3 = new TableView(&quot;TableView3&quot;); View* v4 = new TableView(&quot;TableView4&quot;); IntDataModel* model = new IntDataModel; model-&gt;addView(v1); model-&gt;addView(v2); model-&gt;addView(v3); model-&gt;addView(v4); model-&gt;notify(); cout &lt;&lt; &quot;-------------\\n&quot; &lt;&lt; endl; model-&gt;removeView(v1); model-&gt;notify(); delete model; model = nullptr; return 0;&#125; 策略模式(Strategy)策略模式是指定义一系列的算法，把它们单独封装起来，并且使它们可以互相替换，使得算法可以独立于使用它的客户端而变化，也是说这些算法所完成的功能类型是一样的，对外接口也是一样的，只是不同的策略为引起环境角色环境角色表现出不同的行为。 相比于使用大量的if…else，使用策略模式可以降低复杂度，使得代码更容易维护。 缺点：可能需要定义大量的策略类，并且这些策略类都要提供给客户端。 [环境角色] 持有一个策略类的引用，最终给客户端调用。 传统的策略模式实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116/** 关键代码：实现同一个接口。* 以下代码实例中，以游戏角色不同的攻击方式为不同的策略，游戏角色即为执行不同策略的环境角色。*/#include &lt;iostream&gt;using namespace std;//抽象策略类，提供一个接口class Hurt&#123;public: virtual void blood() = 0;&#125;;//具体的策略实现类，具体实现接口， Adc持续普通攻击class AdcHurt : public Hurt&#123;public: void blood() override &#123; cout &lt;&lt; &quot;Adc hurt, Blood loss&quot; &lt;&lt; endl; &#125;&#125;;//具体的策略实现类，具体实现接口， Apc技能攻击class ApcHurt : public Hurt&#123;public: void blood() override &#123; cout &lt;&lt; &quot;Apc Hurt, Blood loss&quot; &lt;&lt; endl; &#125;&#125;;//环境角色类， 游戏角色战士，传入一个策略类指针参数。class Soldier&#123;public: Soldier(Hurt* hurt):m_pHurt(hurt) &#123; &#125; //在不同的策略下，该游戏角色表现出不同的攻击 void attack() &#123; m_pHurt-&gt;blood(); &#125;private: Hurt* m_pHurt;&#125;;//定义策略标签typedef enum&#123; Hurt_Type_Adc, Hurt_Type_Apc, Hurt_Type_Num&#125;HurtType;//环境角色类， 游戏角色法师，传入一个策略标签参数。class Mage&#123;public: Mage(HurtType type) &#123; switch(type) &#123; case Hurt_Type_Adc: m_pHurt = new AdcHurt(); break; case Hurt_Type_Apc: m_pHurt = new ApcHurt(); break; default: break; &#125; &#125; ~Mage() &#123; delete m_pHurt; m_pHurt = nullptr; cout &lt;&lt; &quot;~Mage()&quot; &lt;&lt; endl; &#125; void attack() &#123; m_pHurt-&gt;blood(); &#125;private: Hurt* m_pHurt;&#125;;//环境角色类， 游戏角色弓箭手，实现模板传递策略。template&lt;typename T&gt;class Archer&#123;public: void attack() &#123; m_hurt.blood(); &#125;private: T m_hurt;&#125;;int main()&#123; Archer&lt;ApcHurt&gt;* arc = new Archer&lt;ApcHurt&gt;; arc-&gt;attack(); delete arc; arc = nullptr; return 0;&#125; 使用函数指针实现策略模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;functional&gt; void adcHurt()&#123; std::cout &lt;&lt; &quot;Adc Hurt&quot; &lt;&lt; std::endl;&#125;void apcHurt()&#123; std::cout &lt;&lt; &quot;Apc Hurt&quot; &lt;&lt; std::endl;&#125;//环境角色类， 使用传统的函数指针class Soldier&#123;public: typedef void (*Function)(); Soldier(Function fun): m_fun(fun) &#123; &#125; void attack() &#123; m_fun(); &#125;private: Function m_fun;&#125;;//环境角色类， 使用std::function&lt;&gt;class Mage&#123;public: typedef std::function&lt;void()&gt; Function; Mage(Function fun): m_fun(fun) &#123; &#125; void attack() &#123; m_fun(); &#125;private: Function m_fun;&#125;;int main()&#123; Soldier* soldier = new Soldier(apcHurt); soldier-&gt;attack(); delete soldier; soldier = nullptr; return 0;&#125; 建造者模式(Builder)建造者模式：将复杂对象的构建和其表示分离，使得相同的构建过程可以产生不同的表示。 以下情形可以考虑使用建造者模式： 对象的创建复杂，但是其各个部分的子对象创建算法一定。 需求变化大，构造复杂对象的子对象经常变化，但将其组合在一起的算法相对稳定。 建造者模式的优点： 将对象的创建和表示分离，客户端不需要了解具体的构建细节。 增加新的产品对象时，只需要增加其具体的建造类即可，不需要修改原来的代码，扩展方便。 产品之间差异性大，内部变化较大、较复杂时不建议使用建造者模式。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158/**关键代码：建造者类：创建和提供实例； Director类：管理建造出来的实例的依赖关系。*/#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//具体的产品类class Order&#123;public: void setFood(const string&amp; food) &#123; m_strFood = food; &#125; const string&amp; food() &#123; cout &lt;&lt; m_strFood.data() &lt;&lt; endl; return m_strFood; &#125; void setDrink(const string&amp; drink) &#123; m_strDrink = drink; &#125; const string&amp; drink() &#123; cout &lt;&lt; m_strDrink &lt;&lt; endl; return m_strDrink; &#125;private: string m_strFood; string m_strDrink;&#125;;//抽象建造类，提供建造接口。class OrderBuilder&#123;public: virtual ~OrderBuilder() &#123; cout &lt;&lt; &quot;~OrderBuilder()&quot; &lt;&lt; endl; &#125; virtual void setOrderFood() = 0; virtual void setOrderDrink() = 0; virtual Order* getOrder() = 0;&#125;;//具体的建造类class VegetarianOrderBuilder : public OrderBuilder &#123;public: VegetarianOrderBuilder() &#123; m_pOrder = new Order; &#125; ~VegetarianOrderBuilder() &#123; cout &lt;&lt; &quot;~VegetarianOrderBuilder()&quot; &lt;&lt; endl; delete m_pOrder; m_pOrder = nullptr; &#125; void setOrderFood() override &#123; m_pOrder-&gt;setFood(&quot;vegetable salad&quot;); &#125; void setOrderDrink() override &#123; m_pOrder-&gt;setDrink(&quot;water&quot;); &#125; Order* getOrder() override &#123; return m_pOrder; &#125;private: Order* m_pOrder;&#125;;//具体的建造类class MeatOrderBuilder : public OrderBuilder&#123;public: MeatOrderBuilder() &#123; m_pOrder = new Order; &#125; ~MeatOrderBuilder() &#123; cout &lt;&lt; &quot;~MeatOrderBuilder()&quot; &lt;&lt; endl; delete m_pOrder; m_pOrder = nullptr; &#125; void setOrderFood() override &#123; m_pOrder-&gt;setFood(&quot;beef&quot;); &#125; void setOrderDrink() override &#123; m_pOrder-&gt;setDrink(&quot;beer&quot;); &#125; Order* getOrder() override &#123; return m_pOrder; &#125;private: Order* m_pOrder;&#125;;//Director类，负责管理实例创建的依赖关系，指挥构建者类创建实例class Director&#123;public: Director(OrderBuilder* builder) : m_pOrderBuilder(builder) &#123; &#125; void construct() &#123; m_pOrderBuilder-&gt;setOrderFood(); m_pOrderBuilder-&gt;setOrderDrink(); &#125;private: OrderBuilder* m_pOrderBuilder;&#125;;int main()&#123;// MeatOrderBuilder* mBuilder = new MeatOrderBuilder; OrderBuilder* mBuilder = new MeatOrderBuilder; //注意抽象构建类必须有虚析构函数，解析时才会 调用子类的析构函数 Director* director = new Director(mBuilder); director-&gt;construct();Order* order = mBuilder-&gt;getOrder();order-&gt;food();order-&gt;drink();delete director;director = nullptr;delete mBuilder;mBuilder = nullptr;return 0;&#125; 适配器模式(Adapter)适配器模式可以将一个类的接口转换成客户端希望的另一个接口，使得原来由于接口不兼容而不能在一起工作的那些类可以在一起工作。通俗的讲就是当我们已经有了一些类，而这些类不能满足新的需求，此时就可以考虑是否能将现有的类适配成可以满足新需求的类。适配器类需要继承或依赖已有的类，实现想要的目标接口。 缺点：过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 使用复合实现适配器模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** 关键代码：适配器继承或依赖已有的对象，实现想要的目标接口。* 以下示例中，假设我们之前有了一个双端队列，新的需求要求使用栈和队列来完成。 双端队列可以在头尾删减或增加元素。而栈是一种先进后出的数据结构，添加数据时添加到栈的顶部，删除数据时先删 除栈顶部的数据。因此我们完全可以将一个现有的双端队列适配成一个栈。*///双端队列， 被适配类class Deque&#123;public: void push_back(int x) &#123; cout &lt;&lt; &quot;Deque push_back:&quot; &lt;&lt; x &lt;&lt; endl; &#125; void push_front(int x) &#123; cout &lt;&lt; &quot;Deque push_front:&quot; &lt;&lt; x &lt;&lt; endl; &#125; void pop_back() &#123; cout &lt;&lt; &quot;Deque pop_back&quot; &lt;&lt; endl; &#125; void pop_front() &#123; cout &lt;&lt; &quot;Deque pop_front&quot; &lt;&lt; endl; &#125;&#125;;//顺序类，抽象目标类class Sequence &#123;public: virtual void push(int x) = 0; virtual void pop() = 0;&#125;;//栈,后进先出, 适配类class Stack:public Sequence &#123;public: //将元素添加到堆栈的顶部。 void push(int x) override &#123; m_deque.push_front(x); &#125; //从堆栈中删除顶部元素 void pop() override &#123; m_deque.pop_front(); &#125;private: Deque m_deque;&#125;;//队列，先进先出，适配类class Queue:public Sequence &#123;public: //将元素添加到队列尾部 void push(int x) override &#123; m_deque.push_back(x); &#125; //从队列中删除顶部元素 void pop() override &#123; m_deque.pop_front(); &#125;private: Deque m_deque;&#125;; 使用继承实现适配器模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//双端队列，被适配类class Deque &#123;public: void push_back(int x) &#123; cout &lt;&lt; &quot;Deque push_back:&quot; &lt;&lt; x &lt;&lt; endl; &#125; void push_front(int x) &#123; cout &lt;&lt; &quot;Deque push_front:&quot; &lt;&lt; x &lt;&lt; endl; &#125; void pop_back() &#123; cout &lt;&lt; &quot;Deque pop_back&quot; &lt;&lt; endl; &#125; void pop_front() &#123; cout &lt;&lt; &quot;Deque pop_front&quot; &lt;&lt; endl; &#125;&#125;;//顺序类，抽象目标类class Sequence &#123;public: virtual void push(int x) = 0; virtual void pop() = 0;&#125;;//栈,后进先出, 适配类class Stack:public Sequence, private Deque &#123;public: void push(int x) &#123; push_front(x); &#125; void pop() &#123; pop_front(); &#125;&#125;;//队列，先进先出，适配类class Queue:public Sequence, private Deque &#123;public: void push(int x) &#123; push_back(x); &#125; void pop() &#123; pop_front(); &#125;&#125;; 桥接模式(Bridge)桥接模式：将抽象部分与实现部分分离，使它们都可以独立变换。 以下情形考虑使用桥接模式： 当一个对象有多个变化因素的时候，考虑依赖于抽象的实现，而不是具体的实现。 当多个变化因素在多个对象间共享时，考虑将这部分变化的部分抽象出来再聚合/合成进来。 当一个对象的多个变化因素可以动态变化的时候。 优点： 将实现抽离出来，再实现抽象，使得对象的具体实现依赖于抽象，满足了依赖倒转原则。 更好的可扩展性。 可动态的切换实现。桥接模式实现了抽象和实现的分离，在实现桥接模式时，就可以实现动态的选择具体的实现。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/** 关键代码：将现实独立出来，抽象类依赖现实类。* 以下示例中，将各类App、各类手机独立开来，实现各种App和各种手机的自由桥接。*/#include &lt;iostream&gt;using namespace std;//抽象App类，提供接口class App&#123;public: virtual ~App()&#123; cout &lt;&lt; &quot;~App()&quot; &lt;&lt; endl; &#125; virtual void run() = 0;&#125;;//具体的App实现类class GameApp:public App&#123;public: void run() &#123; cout &lt;&lt; &quot;GameApp Running&quot; &lt;&lt; endl; &#125;&#125;;//具体的App实现类class TranslateApp:public App&#123;public: void run() &#123; cout &lt;&lt; &quot;TranslateApp Running&quot; &lt;&lt; endl; &#125;&#125;;//抽象手机类，提供接口class MobilePhone&#123;public: virtual ~MobilePhone()&#123; cout &lt;&lt; &quot;~MobilePhone()&quot; &lt;&lt; endl;&#125; virtual void appRun(App* app) = 0; //实现App与手机的桥接&#125;;//具体的手机实现类class XiaoMi:public MobilePhone&#123;public: void appRun(App* app) &#123; cout &lt;&lt; &quot;XiaoMi: &quot;; app-&gt;run(); &#125;&#125;;//具体的手机实现类class HuaWei:public MobilePhone&#123;public: void appRun(App* app) &#123; cout &lt;&lt; &quot;HuaWei: &quot;; app-&gt;run(); &#125;&#125;;int main()&#123; App* gameApp = new GameApp; App* translateApp = new TranslateApp; MobilePhone* mi = new XiaoMi; MobilePhone* hua = new HuaWei; mi-&gt;appRun(gameApp); mi-&gt;appRun(translateApp); hua-&gt;appRun(gameApp); hua-&gt;appRun(translateApp); delete hua; hua = nullptr; delete mi; mi = nullptr; delete gameApp; gameApp = nullptr; delete translateApp; translateApp = nullptr; return 0;&#125; 装饰模式(Decorator)装饰模式：动态地给一个对象添加一些额外的功能，它是通过创建一个包装对象，也就是装饰来包裹真实的对象。新增加功能来说，装饰器模式比生产子类更加灵活。 以下情形考虑使用装饰模式： 需要扩展一个类的功能，或给一个类添加附加职责。 需要动态的给一个对象添加功能，这些功能可以再动态的撤销。 需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变的不现实。 当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122/** 关键代码：1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。*/#include &lt;iostream&gt;using namespace std;//抽象构件（Component）角色：给出一个抽象接口，以规范准备接收附加责任的对象。class Component&#123;public: virtual ~Component()&#123;&#125; virtual void configuration() = 0;&#125;;//具体构件（Concrete Component）角色：定义一个将要接收附加责任的类。class Car : public Component&#123;public: void configuration() override &#123; cout &lt;&lt; &quot;A Car&quot; &lt;&lt; endl; &#125;&#125;;//装饰（Decorator）角色：持有一个构件（Component）对象的实例，并实现一个与抽象构件接口一致的接口。class DecorateCar : public Component&#123;public: DecorateCar(Component* car) : m_pCar(car)&#123;&#125; void configuration() override &#123; m_pCar-&gt;configuration(); &#125;private: Component* m_pCar;&#125;;//具体装饰（Concrete Decorator）角色：负责给构件对象添加上附加的责任。class DecorateLED : public DecorateCar&#123;public: DecorateLED(Component* car) : DecorateCar(car)&#123;&#125; void configuration() override &#123; DecorateCar::configuration(); addLED(); &#125;private: void addLED() &#123; cout &lt;&lt; &quot;Install LED&quot; &lt;&lt; endl; &#125;&#125;;//具体装饰（Concrete Decorator）角色：负责给构件对象添加上附加的责任。class DecoratePC : public DecorateCar&#123;public: DecoratePC(Component* car) : DecorateCar(car)&#123;&#125; void configuration() override &#123; DecorateCar::configuration(); addPC(); &#125;private: void addPC() &#123; cout &lt;&lt; &quot;Install PC&quot; &lt;&lt; endl; &#125;&#125;;//具体装饰（Concrete Decorator）角色：负责给构件对象添加上附加的责任。class DecorateEPB : public DecorateCar&#123;public: DecorateEPB(Component* car) : DecorateCar(car)&#123;&#125; void configuration() override &#123; DecorateCar::configuration(); addEPB(); &#125;private: void addEPB() &#123; cout &lt;&lt; &quot;Install Electrical Park Brake&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; Car* car = new Car; DecorateLED* ledCar = new DecorateLED(car); DecoratePC* pcCar = new DecoratePC(ledCar); DecorateEPB* epbCar = new DecorateEPB(pcCar); epbCar-&gt;configuration(); delete epbCar; epbCar = nullptr; delete pcCar; pcCar = nullptr; delete ledCar; ledCar = nullptr; delete car; car = nullptr; return 0;&#125; 中介者模式(Mediator)中介者模式：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之前的交互。 如果对象与对象之前存在大量的关联关系，若一个对象改变，常常需要跟踪与之关联的对象，并做出相应的处理，这样势必会造成系统变得复杂，遇到这种情形可以考虑使用中介者模式。当多个对象存在关联关系时，为它们设计一个中介对象，当一个对象改变时，只需要通知它的中介对象，再由它的中介对象通知每个与它相关的对象。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131/** 关键代码：将相关对象的通信封装到一个类中单独处理。*/#include &lt;iostream&gt;using namespace std;class Mediator;//抽象同事类。class Businessman&#123;public: Businessman()&#123;&#125; Businessman(Mediator* mediator) : m_pMediator(mediator)&#123;&#125; virtual ~Businessman()&#123;&#125; virtual void setMediator(Mediator* m) &#123; m_pMediator = m; &#125; virtual void sendMessage(const string&amp; msg) = 0; virtual void getMessage(const string&amp; msg) = 0;protected: Mediator* m_pMediator;&#125;;//抽象中介者类。class Mediator&#123;public: virtual ~Mediator()&#123;&#125; virtual void setBuyer(Businessman* buyer) = 0; virtual void setSeller(Businessman* seller) = 0; virtual void send(const string&amp; msg, Businessman* man) = 0;&#125;;//具体同事类class Buyer : public Businessman&#123;public: Buyer() : Businessman()&#123;&#125; Buyer(Mediator* mediator) : Businessman(mediator)&#123;&#125; void sendMessage(const string&amp; msg) override &#123; m_pMediator-&gt;send(msg, this); &#125; void getMessage(const string&amp; msg) &#123; cout &lt;&lt; &quot;Buyer recv: &quot; &lt;&lt; msg.data() &lt;&lt; endl; &#125;&#125;;//具体同事类class Seller : public Businessman&#123;public: Seller() : Businessman()&#123;&#125; Seller(Mediator* mediator) : Businessman(mediator)&#123;&#125; void sendMessage(const string&amp; msg) override &#123; m_pMediator-&gt;send(msg, this); &#125; void getMessage(const string&amp; msg) &#123; cout &lt;&lt; &quot;Seller recv: &quot; &lt;&lt; msg.data() &lt;&lt; endl; &#125;&#125;;//具体中介者类class HouseMediator : public Mediator&#123;public: void setBuyer(Businessman* buyer) override &#123; m_pBuyer = buyer; &#125; void setSeller(Businessman* seller) override &#123; m_pSeller = seller; &#125; void send(const string&amp; msg, Businessman* man) override &#123; if(man == m_pBuyer) &#123; m_pSeller-&gt;getMessage(msg); &#125; else if(man == m_pSeller) &#123; m_pBuyer-&gt;getMessage(msg); &#125; &#125;private: Businessman* m_pBuyer; Businessman* m_pSeller;&#125;;int main()&#123; HouseMediator* hMediator = new HouseMediator; Buyer* buyer = new Buyer(hMediator); Seller* seller = new Seller(hMediator); hMediator-&gt;setBuyer(buyer); hMediator-&gt;setSeller(seller); buyer-&gt;sendMessage(&quot;Sell not to sell?&quot;); seller-&gt;sendMessage(&quot;Of course selling!&quot;); delete buyer; buyer = nullptr; delete seller; seller = nullptr; delete hMediator; hMediator = nullptr; return 0;&#125; 备忘录模式(Memento)备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原来保存的状态。 备忘录模式中需要定义的角色类： Originator(发起人)：负责创建一个备忘录Memento，用以记录当前时刻自身的内部状态，并可使用备忘录恢复内部状态。Originator可以根据需要决定Memento存储自己的哪些内部状态。 Memento(备忘录)：负责存储Originator对象的内部状态，并可以防止Originator以外的其他对象访问备忘录。备忘录有两个接口：Caretaker只能看到备忘录的窄接口，他只能将备忘录传递给其他对象。Originator却可看到备忘录的宽接口，允许它访问返回到先前状态所需要的所有数据。 Caretaker(管理者):负责备忘录Memento，不能对Memento的内容进行访问或者操作。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/** 关键代码：Memento类、Originator类、Caretaker类；Originator类不与Memento类耦合，而是与Caretaker类耦合。*/include &lt;iostream&gt;using namespace std;//需要保存的信息typedef struct &#123; int grade; string arm; string corps;&#125;GameValue;//Memento类class Memento &#123;public: Memento()&#123;&#125; Memento(GameValue value):m_gameValue(value)&#123;&#125; GameValue getValue() &#123; return m_gameValue; &#125;private: GameValue m_gameValue;&#125;;//Originator类class Game &#123;public: Game(GameValue value):m_gameValue(value) &#123;&#125; void addGrade() //等级增加 &#123; m_gameValue.grade++; &#125; void replaceArm(string arm) //更换武器 &#123; m_gameValue.arm = arm; &#125; void replaceCorps(string corps) //更换工会 &#123; m_gameValue.corps = corps; &#125; Memento saveValue() //保存当前信息 &#123; Memento memento(m_gameValue); return memento; &#125; void load(Memento memento) //载入信息 &#123; m_gameValue = memento.getValue(); &#125; void showValue() &#123; cout &lt;&lt; &quot;Grade: &quot; &lt;&lt; m_gameValue.grade &lt;&lt; endl; cout &lt;&lt; &quot;Arm : &quot; &lt;&lt; m_gameValue.arm.data() &lt;&lt; endl; cout &lt;&lt; &quot;Corps: &quot; &lt;&lt; m_gameValue.corps.data() &lt;&lt; endl; &#125;private: GameValue m_gameValue;&#125;;//Caretaker类class Caretake &#123;public: void save(Memento memento) //保存信息 &#123; m_memento = memento; &#125; Memento load() //读已保存的信息 &#123; return m_memento; &#125;private: Memento m_memento;&#125;;int main()&#123; GameValue v1 = &#123;0, &quot;Ak&quot;, &quot;3K&quot;&#125;; Game game(v1); //初始值 game.addGrade(); game.showValue(); cout &lt;&lt; &quot;----------&quot; &lt;&lt; endl; Caretake care; care.save(game.saveValue()); //保存当前值 game.addGrade(); //修改当前值 game.replaceArm(&quot;M16&quot;); game.replaceCorps(&quot;123&quot;); game.showValue(); cout &lt;&lt; &quot;----------&quot; &lt;&lt; endl; game.load(care.load()); //恢复初始值 game.showValue(); return 0;&#125; 原型模式(Prototype)原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。通俗的讲就是当需要创建一个新的实例化对象时，我们刚好有一个实例化对象，但是已经存在的实例化对象又不能直接使用。这种情况下拷贝一个现有的实例化对象来用，可能会更方便。 以下情形可以考虑使用原型模式： 当new一个对象，非常繁琐复杂时，可以使用原型模式来进行复制一个对象。比如创建对象时，构造函数的参数很多，而自己又不完全的知道每个参数的意义，就可以使用原型模式来创建一个新的对象，不必去理会创建的过程。 当需要new一个新的对象，这个对象和现有的对象区别不大，我们就可以直接复制一个已有的对象，然后稍加修改。 当需要一个对象副本时，比如需要提供对象的数据，同时又需要避免外部对数据对象进行修改，那就拷贝一个对象副本供外部使用。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** 关键代码：拷贝，return new className(*this);*/#include &lt;iostream&gt;using namespace std;//提供一个抽象克隆基类。class Clone&#123;public: virtual Clone* clone() = 0; virtual void show() = 0;&#125;;//具体的实现类class Sheep:public Clone&#123;public: Sheep(int id, string name):Clone(), m_id(id),m_name(name) &#123; cout &lt;&lt; &quot;Sheep() id address:&quot; &lt;&lt; &amp;m_id &lt;&lt; endl; cout &lt;&lt; &quot;Sheep() name address:&quot; &lt;&lt; &amp;m_name &lt;&lt; endl; &#125; ~Sheep() &#123; &#125; //关键代码拷贝构造函数 Sheep(const Sheep&amp; obj) &#123; this-&gt;m_id = obj.m_id; this-&gt;m_name = obj.m_name; cout &lt;&lt; &quot;Sheep(const Sheep&amp; obj) id address:&quot; &lt;&lt; &amp;m_id &lt;&lt; endl; cout &lt;&lt; &quot;Sheep(const Sheep&amp; obj) name address:&quot; &lt;&lt; &amp;m_name &lt;&lt; endl; &#125; //关键代码克隆函数，返回return new Sheep(*this) Clone* clone() &#123; return new Sheep(*this); &#125; void show() &#123; cout &lt;&lt; &quot;id :&quot; &lt;&lt; m_id &lt;&lt; endl; cout &lt;&lt; &quot;name:&quot; &lt;&lt; m_name.data() &lt;&lt; endl; &#125;private: int m_id; string m_name;&#125;;int main()&#123; Clone* s1 = new Sheep(1, &quot;abs&quot;); s1-&gt;show(); Clone* s2 = s1-&gt;clone(); s2-&gt;show(); delete s1; s1 = nullptr; delete s2; s2 = nullptr; return 0;&#125; 享元模式(Flyweight)享元模式：运用共享技术有效地支持大量细粒度的对象。在有大量对象时，把其中共同的部分抽象出来，如果有相同的业务请求，直接返回内存中已有的对象，避免重新创建。 以下情况可以考虑使用享元模式：*系统中有大量的对象，这些对象消耗大量的内存，且这些对象的状态可以被外部化。 对于享元模式，需要将对象的信息分为两个部分：内部状态和外部状态。内部状态是指被共享出来的信息，储存在享元对象内部且不随环境变化而改变；外部状态是不可以共享的，它随环境改变而改变，是由客户端控制的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/** 关键代码：将内部状态作为标识，进行共享。*/#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;memory&gt;using namespace std;//抽象享元类，提供享元类外部接口。class AbstractConsumer&#123;public: virtual ~AbstractConsumer()&#123;&#125; virtual void setArticle(const string&amp;) = 0; virtual const string&amp; article() = 0;&#125;;//具体的享元类class Consumer : public AbstractConsumer&#123;public: Consumer(const string&amp; strName) : m_user(strName)&#123;&#125; ~Consumer() &#123; cout &lt;&lt; &quot; ~Consumer()&quot; &lt;&lt; endl; &#125; void setArticle(const string&amp; info) override &#123; m_article = info; &#125; const string&amp; article() override &#123; return m_article; &#125;private: string m_user; string m_article;&#125;;//享元工厂类class Trusteeship&#123;public: ~Trusteeship() &#123; m_consumerMap.clear(); &#125; void hosting(const string&amp; user, const string&amp; article) &#123; if(m_consumerMap.count(user)) &#123; cout &lt;&lt; &quot;A customer named &quot; &lt;&lt; user.data() &lt;&lt; &quot; already exists&quot; &lt;&lt; endl; Consumer* consumer = m_consumerMap.at(user).get(); consumer-&gt;setArticle(article); &#125; else &#123; shared_ptr&lt;Consumer&gt; consumer(new Consumer(user)); consumer.get()-&gt;setArticle(article); m_consumerMap.insert(pair&lt;string, shared_ptr&lt;Consumer&gt;&gt;(user, consumer)); &#125; &#125; void display() &#123; map&lt;string, shared_ptr&lt;Consumer&gt;&gt;::iterator iter = m_consumerMap.begin(); for(; iter != m_consumerMap.end(); iter++) &#123; cout &lt;&lt; iter-&gt;first.data() &lt;&lt; &quot; : &quot;&lt;&lt; iter-&gt;second.get()-&gt;article().data() &lt;&lt; endl; &#125; &#125;private: map&lt;string, shared_ptr&lt;Consumer&gt;&gt; m_consumerMap;&#125;;int main()&#123; Trusteeship* ts = new Trusteeship; ts-&gt;hosting(&quot;zhangsan&quot;, &quot;computer&quot;); ts-&gt;hosting(&quot;lisi&quot;, &quot;phone&quot;); ts-&gt;hosting(&quot;wangwu&quot;, &quot;watch&quot;); ts-&gt;display(); ts-&gt;hosting(&quot;zhangsan&quot;, &quot;TT&quot;); ts-&gt;hosting(&quot;lisi&quot;, &quot;TT&quot;); ts-&gt;hosting(&quot;wangwu&quot;, &quot;TT&quot;); ts-&gt;display(); delete ts; ts = nullptr; return 0;&#125; 职责链模式(Chain of Resp.)职责链模式：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之前的耦合关系，将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。 职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无需关心请求的处理细节和请求的传递，所有职责链将请求的发送者和请求的处理者解耦了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/** 关键代码：Handler内指明其上级，handleRequest()里判断是否合适，不合适则传递给上级。*/#include &lt;iostream&gt;using namespace std;enum RequestLevel&#123; Level_One = 0, Level_Two, Level_Three, Level_Num&#125;;//抽象处理者（Handler）角色，提供职责链的统一接口。class Leader&#123;public: Leader(Leader* leader):m_leader(leader)&#123;&#125; virtual ~Leader()&#123;&#125; virtual void handleRequest(RequestLevel level) = 0;protected: Leader* m_leader;&#125;;//具体处理者（Concrete Handler）角色class Monitor:public Leader //链扣1&#123;public: Monitor(Leader* leader):Leader(leader)&#123;&#125; void handleRequest(RequestLevel level) &#123; if(level &lt; Level_Two) &#123; cout &lt;&lt; &quot;Mointor handle request : &quot; &lt;&lt; level &lt;&lt; endl; &#125; else &#123; m_leader-&gt;handleRequest(level); &#125; &#125;&#125;;//具体处理者（Concrete Handler）角色class Captain:public Leader //链扣2&#123;public: Captain(Leader* leader):Leader(leader)&#123;&#125; void handleRequest(RequestLevel level) &#123; if(level &lt; Level_Three) &#123; cout &lt;&lt; &quot;Captain handle request : &quot; &lt;&lt; level &lt;&lt; endl; &#125; else &#123; m_leader-&gt;handleRequest(level); &#125; &#125;&#125;;//具体处理者（Concrete Handler）角色class General:public Leader //链扣3&#123;public: General(Leader* leader):Leader(leader)&#123;&#125; void handleRequest(RequestLevel level) &#123; cout &lt;&lt; &quot;General handle request : &quot; &lt;&lt; level &lt;&lt; endl; &#125;&#125;;int main()&#123; Leader* general = new General(nullptr); Leader* captain = new Captain(general); Leader* monitor = new Monitor(captain); monitor-&gt;handleRequest(Level_One); delete monitor; monitor = nullptr; delete captain; captain = nullptr; delete general; general = nullptr; return 0;&#125;","categories":[{"name":"八股文","slug":"八股文","permalink":"https://wangtianyang.com/categories/%E5%85%AB%E8%82%A1%E6%96%87/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://wangtianyang.com/tags/C/"}]},{"title":"【C++】语言特性相关","slug":"【C-】语言特性相关","date":"2022-03-06T06:50:44.000Z","updated":"2023-01-06T13:44:51.104Z","comments":true,"path":"2022/03/06/【C-】语言特性相关/","link":"","permalink":"https://wangtianyang.com/2022/03/06/%E3%80%90C-%E3%80%91%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E7%9B%B8%E5%85%B3/","excerpt":"左值和右值的区别？左值引用和右值引用的区别，如何将左值转换成右值？左值：指表达式结束后依然存在的持久对象。 右值：表达式结束就不再存在的临时对象。 左值和右值的区别：左值持久，右值短暂 右值引用和左值引用的区别： 左值引用不能绑定到要转换的表达式、字面常量或返回右值的表达式。右值引用恰好相反，可以绑定到这类表达式，但不能绑定到一个左值上。 右值引用必须绑定到右值的引用，通过 &amp;&amp; 获得。右值引用只能绑定到一个将要销毁的对象上，因此可以自由地移动其资源。","text":"左值和右值的区别？左值引用和右值引用的区别，如何将左值转换成右值？左值：指表达式结束后依然存在的持久对象。 右值：表达式结束就不再存在的临时对象。 左值和右值的区别：左值持久，右值短暂 右值引用和左值引用的区别： 左值引用不能绑定到要转换的表达式、字面常量或返回右值的表达式。右值引用恰好相反，可以绑定到这类表达式，但不能绑定到一个左值上。 右值引用必须绑定到右值的引用，通过 &amp;&amp; 获得。右值引用只能绑定到一个将要销毁的对象上，因此可以自由地移动其资源。 std::move可以将一个左值强制转化为右值，继而可以通过右值引用使用该值，以用于移动语义。1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;void fun1(int&amp; tmp) &#123; cout &lt;&lt; &quot;fun1(int&amp; tmp):&quot; &lt;&lt; tmp &lt;&lt; endl; &#125; void fun2(int&amp;&amp; tmp) &#123; cout &lt;&lt; &quot;fun2(int&amp;&amp; tmp)&quot; &lt;&lt; tmp &lt;&lt; endl; &#125; int main() &#123; int var = 11; fun1(12); // error: cannot bind non-const lvalue reference of type &#x27;int&amp;&#x27; to an rvalue of type &#x27;int&#x27; fun1(var); fun2(1); &#125; std::move() 函数的实现原理std::move()函数原型：12345template &lt;typename T&gt;typename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; t)&#123; return static_cast&lt;typename remove_reference&lt;T&gt;::type &amp;&amp;&gt;(t);&#125;说明：引用折叠原理 右值传递给上述函数的形参 T&amp;&amp; 依然是右值，即 T&amp;&amp; &amp;&amp; 相当于 T&amp;&amp;。 左值传递给上述函数的形参 T&amp;&amp; 依然是左值，即 T&amp;&amp; &amp; 相当于 T&amp;。 小结：通过引用折叠原理可以知道，move()函数的形参既可以是左值也可以是右值。remove_reference具体实现：1234567891011121314151617//原始的，最通用的版本template &lt;typename T&gt; struct remove_reference&#123; typedef T type; //定义 T 的类型别名为 type&#125;; //部分版本特例化，将用于左值引用和右值引用template &lt;class T&gt; struct remove_reference&lt;T&amp;&gt; //左值引用&#123; typedef T type; &#125; template &lt;class T&gt; struct remove_reference&lt;T&amp;&amp;&gt; //右值引用&#123; typedef T type; &#125; //举例如下,下列定义的a、b、c三个变量都是int类型int i;remove_refrence&lt;decltype(42)&gt;::type a; //使用原版本，remove_refrence&lt;decltype(i)&gt;::type b; //左值引用特例版本remove_refrence&lt;decltype(std::move(i))&gt;::type b; //右值引用特例版本 举例：1nt var = 10; 转化过程： std::move(var)=&gt;std::move(int&amp;&amp; &amp;)=&gt;折叠后std::move(int&amp;) 此时：T的类型为int&amp;，typename remove_reference&lt;T&gt;::type为int，这里使用remove_reference的左值引用的特例化版本 通过static_cast将int&amp;强制转换为int&amp;&amp; 整个std::move被实例化如下1234string&amp;&amp; move(int&amp; t) &#123; return static_cast&lt;int&amp;&amp;&gt;(t); &#125;总结：std::move()实现原理： 利用引用折叠原理将右值经过 T&amp;&amp; 传递类型保持不变还是右值，而左值经过 T&amp;&amp; 变为普通的左值引用，以保证模板可以传递任意实参，且保持类型不变； 然后通过 remove_refrence 移除引用，得到具体的类型 T； 最后通过 static_cast&lt;&gt; 进行强制类型转换，返回 T&amp;&amp; 右值引用。 什么是指针？指针的大小及用法？指针：指向另外一种类型的复合类型。指针的大小：在 64 位计算机中，指针占 8 个字节空间。 什么是野指针和悬空指针？悬空指针：若指针指向一块内存空间，当这块内存空间被释放后，该指针依然指向这块内存空间，此时，称该指针为“悬空指针”。 举例：123void *p = malloc(size);free(p); // 此时，p 指向的内存空间已释放， p 就是悬空指针。野指针：“野指针”是指不确定其指向的指针，未初始化的指针为“野指针”12void *p; // 此时 p 是“野指针”。 C++ 11 nullptr 比 NULL 优势NULL：预处理变量，是一个宏，它的值是 0，定义在头文件 中，即#define NULL 0。nullptr：C++ 11 中的关键字，是一种特殊类型的字面值，可以被转换成任意其他类型。 nullptr 的优势： 有类型，类型是 typdef decltype(nullptr) nullptr_t;，使用 nullptr 提高代码的健壮性。 函数重载：因为 NULL 本质上是 0，在函数调用过程中，若出现函数重载并且传递的实参是 NULL，可能会出现，不知和哪一个函数匹配的情况；但是传递实参 nullptr 就不会出现这种情况。 指针和引用的区别？ 指针所指向的内存空间在程序运行过程中可以改变，而引用所绑定的对象一旦绑定就不能改变。（是否可变） 指针本身在内存中占有内存空间，引用相当于变量的别名，在内存中不占内存空间。（是否占内存） 指针可以为空，但是引用必须绑定对象。（是否可为空） 指针可以有多级，但是引用只能一级。（是否能为多级） 常量指针和指针常量的区别常量指针：常量指针本质上是个指针，只不过这个指针指向的对象是常量。 特点：const 的位置在指针声明运算符*的左侧。只要const位于*的左侧，无论它在类型名的左边或右边，都表示指向常量的指针。（可以这样理解*左侧表示指针指向的对象，该对象为常量，那么该指针为常量指针。）12const int * p;int const * p;注意 1：指针指向的对象不能通过这个指针来修改，也就是说常量指针可以被赋值为变量的地址，之所以叫做常量指针，是限制了通过这个指针修改变量的值。 注意 2：虽然常量指针指向的对象不能变化，可是因为常量指针本身是一个变量，因此，可以被重新赋值。 指针常量：指针常量的本质上是个常量，只不过这个常量的值是一个指针。特点：const位于指针声明操作符右侧，表明该对象本身是一个常量，*左侧表示该指针指向的类型，即以*为分界线，其左侧表示指针指向的类型，右侧表示指针本身的性质。12const int var;int * const c_p = &amp;var; 注意 1：指针常量的值是指针，这个值因为是常量，所以指针本身不能改变。 注意 2：指针的内容可以改变。 函数指针和指针函数的区别指针函数：指针函数本质是一个函数，只不过该函数的返回值是一个指针。相对于普通函数而言，只是返回值是指针。123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;struct Type&#123; int var1; int var2;&#125;;Type * fun(int tmp1, int tmp2)&#123; Type * t = new Type(); t-&gt;var1 = tmp1; t-&gt;var2 = tmp2; return t;&#125;int main()&#123; Type *p = fun(5, 6); return 0;&#125; 函数指针：函数指针本质是一个指针变量，只不过这个指针指向一个函数。函数指针即指向函数的指针。12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;int fun1(int tmp1, int tmp2)&#123; return tmp1 * tmp2;&#125;int fun2(int tmp1, int tmp2)&#123; return tmp1 / tmp2;&#125;int main()&#123; int (*fun)(int x, int y); fun = fun1; cout &lt;&lt; fun(15, 5) &lt;&lt; endl; fun = fun2; cout &lt;&lt; fun(15, 5) &lt;&lt; endl; return 0;&#125;/*运行结果：753*/ 函数指针和指针函数的区别： 本质不同 指针函数本质是一个函数，其返回值为指针。 函数指针本质是一个指针变量，其指向一个函数。 强制类型转换有哪几种？ static_cast：用于数据的强制类型转换，强制将一种数据类型转换为另一种数据类型。 用于基本数据类型的转换。 用于类层次之间的基类和派生类之间 指针或者引用 的转换（不要求必须包含虚函数，但必须是有相互联系的类），进行上行转换（派生类的指针或引用转换成基类表示）是安全的；进行下行转换（基类的指针或引用转换成派生类表示）由于没有动态类型检查，所以是不安全的，最好用 dynamic_cast 进行下行转换。 可以将空指针转化成目标类型的空指针。 可以将任何类型的表达式转化成 void 类型 const_cast：强制去掉常量属性，不能用于去掉变量的常量性，只能用于去除指针或引用的常量性，将常量指针转化为非常量指针或者将常量引用转化为非常量引用（注意：表达式的类型和要转化的类型是相同的）。 reinterpret_cast：改变指针或引用的类型、将指针或引用转换为一个足够长度的整型、将整型转化为指针或引用类型。 dynamic_cast： 其他三种都是编译时完成的，动态类型转换是在程序运行时处理的，运行时会进行类型检查。 只能用于带有虚函数的基类或派生类的指针或者引用对象的转换，转换成功返回指向类型的指针或引用，转换失败返回 NULL；不能用于基本数据类型的转换。 在向上进行转换时，即派生类类的指针转换成基类类的指针和 static_cast 效果是一样的，（注意：这里只是改变了指针的类型，指针指向的对象的类型并未发生改变）12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;class Base&#123;&#125;;class Derive : public Base&#123;&#125;;int main()&#123; Base *p1 = new Derive(); Derive *p2 = new Derive(); //向上类型转换 p1 = dynamic_cast&lt;Base *&gt;(p2); if (p1 == NULL) &#123; cout &lt;&lt; &quot;NULL&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;NOT NULL&quot; &lt;&lt; endl; //输出 &#125; return 0;&#125; 在下行转换时，基类的指针类型转化为派生类类的指针类型，只有当要转换的指针指向的对象类型和转化以后的对象类型相同时，才会转化成功。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;class Base&#123;public: virtual void fun() &#123; cout &lt;&lt; &quot;Base::fun()&quot; &lt;&lt; endl; &#125;&#125;;class Derive : public Base&#123;public: virtual void fun() &#123; cout &lt;&lt; &quot;Derive::fun()&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; Base *p1 = new Derive(); Base *p2 = new Base(); Derive *p3 = new Derive(); //转换成功 p3 = dynamic_cast&lt;Derive *&gt;(p1); if (p3 == NULL) &#123; cout &lt;&lt; &quot;NULL&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;NOT NULL&quot; &lt;&lt; endl; // 输出 &#125; //转换失败 p3 = dynamic_cast&lt;Derive *&gt;(p2); if (p3 == NULL) &#123; cout &lt;&lt; &quot;NULL&quot; &lt;&lt; endl; // 输出 &#125; else &#123; cout &lt;&lt; &quot;NOT NULL&quot; &lt;&lt; endl; &#125; return 0;&#125; 参数传递时，值传递、引用传递、指针传递的区别？参数传递的三种方式： 值传递：形参是实参的拷贝，函数对形参的所有操作不会影响实参。 指针传递：本质上是值传递，只不过拷贝的是指针的值，拷贝之后，实参和形参是不同的指针，通过指针可以间接的访问指针所指向的对象，从而可以修改它所指对象的值。 引用传递：当形参是引用类型时，我们说它对应的实参被引用传递。1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;void fun1(int tmp)&#123; // 值传递 cout &lt;&lt; &amp;tmp &lt;&lt; endl;&#125;void fun2(int * tmp)&#123; // 指针传递 cout &lt;&lt; tmp &lt;&lt; endl;&#125;void fun3(int &amp;tmp)&#123; // 引用传递 cout &lt;&lt; &amp;tmp &lt;&lt; endl;&#125;int main()&#123; int var = 5; cout &lt;&lt; &quot;var 在主函数中的地址：&quot; &lt;&lt; &amp;var &lt;&lt; endl; cout &lt;&lt; &quot;var 值传递时的地址：&quot;; fun1(var); cout &lt;&lt; &quot;var 指针传递时的地址：&quot;; fun2(&amp;var); cout &lt;&lt; &quot;var 引用传递时的地址：&quot;; fun3(var); return 0;&#125;/*运行结果：var 在主函数中的地址：0x23fe4cvar 值传递时的地址：0x23fe20var 指针传递时的地址：0x23fe4cvar 引用传递时的地址：0x23fe4c*/ 说明：从上述代码的运行结果可以看出，只有在值传递时，形参和实参的地址不一样，在函数体内操作的不是变量本身。引用传递和指针传递，在函数体内操作的是变量本身。 什么是模板？如何实现？模板：创建类或者函数的蓝图或者公式，分为函数模板和类模板。 实现方式：模板定义以关键字 template 开始，后跟一个模板参数列表。 模板参数列表不能为空； 模板类型参数前必须使用关键字 class 或者 typename，在模板参数列表中这两个关键字含义相同，可互换使用。1template &lt;typename T, typename U, ...&gt; 函数模板：通过定义一个函数模板，可以避免为每一种类型定义一个新函数。 对于函数模板而言，模板类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换。 函数模板实例化：当调用一个模板时，编译器用函数实参来推断模板实参，从而使用实参的类型来确定绑定到模板参数的类型12345678910111213141516171819#include&lt;iostream&gt;using namespace std;template &lt;typename T&gt;T add_fun(const T &amp; tmp1, const T &amp; tmp2)&#123; return tmp1 + tmp2;&#125;int main()&#123; int var1, var2; cin &gt;&gt; var1 &gt;&gt; var2; cout &lt;&lt; add_fun(var1, var2); double var3, var4; cin &gt;&gt; var3 &gt;&gt; var4; cout &lt;&lt; add_fun(var3, var4); return 0;&#125; 类模板：类似函数模板，类模板以关键字 template 开始，后跟模板参数列表。但是，编译器不能为类模板推断模板参数类型，需要在使用该类模板时，在模板名后面的尖括号中指明类型。123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;class Complex&#123;public: //构造函数 Complex(T a, T b) &#123; this-&gt;a = a; this-&gt;b = b; &#125; //运算符重载 Complex&lt;T&gt; operator+(Complex &amp;c) &#123; Complex&lt;T&gt; tmp(this-&gt;a + c.a, this-&gt;b + c.b); cout &lt;&lt; tmp.a &lt;&lt; &quot; &quot; &lt;&lt; tmp.b &lt;&lt; endl; return tmp; &#125;private: T a; T b;&#125;;int main()&#123; Complex&lt;int&gt; a(10, 20); Complex&lt;int&gt; b(20, 30); Complex&lt;int&gt; c = a + b; return 0;&#125; 函数模板和类模板的区别？ 实例化方式不同：函数模板实例化由编译程序在处理函数调用时自动完成，类模板实例化需要在程序中显式指定。 实例化的结果不同：函数模板实例化后是一个函数，类模板实例化后是一个类。 默认参数：类模板在模板参数列表中可以有默认参数。 特化：函数模板只能全特化；而类模板可以全特化，也可以偏特化。 调用方式不同：函数模板可以隐式调用，也可以显式调用；类模板只能显式调用。 什么是模板特化？为什么特化？模板特化的原因：模板并非对任何模板实参都合适、都能实例化，某些情况下，通用模板的定义对特定类型不合适，可能会编译失败，或者得不到正确的结果。因此，当不希望使用模板版本时，可以定义类或者函数模板的一个特例化版本。 模板特化：模板参数在某种特定类型下的具体实现。分为函数模板特化和类模板特化 函数模板特化：将函数模板中的全部类型进行特例化，称为函数模板特化。 类模板特化：将类模板中的部分或全部类型进行特例化，称为类模板特化。 特化分为全特化和偏特化： 全特化：模板中的模板参数全部特例化。 偏特化：模板中的模板参数只确定了一部分，剩余部分需要在编译器编译时确定。 说明：要区分下函数重载与函数模板特化 定义函数模板的特化版本，本质上是接管了编译器的工作，为原函数模板定义了一个特殊实例，而不是函数重载，函数模板特化并不影响函数匹配。 实例：123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;//函数模板template &lt;class T&gt;bool compare(T t1, T t2)&#123; cout &lt;&lt; &quot;通用版本：&quot;; return t1 == t2;&#125;template &lt;&gt; //函数模板特化bool compare(char *t1, char *t2)&#123; cout &lt;&lt; &quot;特化版本：&quot;; return strcmp(t1, t2) == 0;&#125;int main(int argc, char *argv[])&#123; char arr1[] = &quot;hello&quot;; char arr2[] = &quot;abc&quot;; cout &lt;&lt; compare(123, 123) &lt;&lt; endl; cout &lt;&lt; compare(arr1, arr2) &lt;&lt; endl; return 0;&#125;/*运行结果：通用版本：1特化版本：0*/ include “ “ 和 &lt;&gt; 的区别include&lt;文件名&gt;和#include&quot;文件名&quot;的区别: 查找文件的位置：include&lt;文件名&gt;在标准库头文件所在的目录中查找，如果没有，再到当前源文件所在目录下查找；#include&quot;文件名&quot;在当前源文件所在目录中进行查找，如果没有；再到系统目录中查找。 使用习惯：对于标准库中的头文件常用include&lt;文件名&gt;，对于自己定义的头文件，常用#include&quot;文件名&quot; switch 的 case 里为何不能定义变量switch 下面的这个花括号表示一块作用域，而不是每一个 case 表示一块作用域。如果在某一 case 中定义了变量，其作用域在这块花括号内，按理说在另一个 case 内可以使用该变量，但是在实际使用时，每一个 case 之间互不影响，是相对封闭的，参考如下实例。 迭代器的作用？作用：在无需知道容器底层原理的情况下，遍历容器中的元素。 泛型编程如何实现？泛型编程实现的基础：模板。模板是创建类或者函数的蓝图或者说公式，当时用一个 vector 这样的泛型，或者 find 这样的泛型函数时，编译时会转化为特定的类或者函数。 泛型编程涉及到的知识点较广，例如：容器、迭代器、算法等都是泛型编程的实现实例。面试者可选择自己掌握比较扎实的一方面进行展开。 容器：涉及到 STL 中的容器，例如：vector、list、map 等，可选其中熟悉底层原理的容器进行展开讲解。 迭代器：在无需知道容器底层原理的情况下，遍历容器中的元素。 模板：可参考本章节中的模板相关问题。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://wangtianyang.com/tags/C/"}]},{"title":"【C++】类相关","slug":"【C-】类相关","date":"2022-03-06T06:16:19.000Z","updated":"2023-01-06T13:46:32.286Z","comments":true,"path":"2022/03/06/【C-】类相关/","link":"","permalink":"https://wangtianyang.com/2022/03/06/%E3%80%90C-%E3%80%91%E7%B1%BB%E7%9B%B8%E5%85%B3/","excerpt":"虚函数虚函数：被 virtual 关键字修饰的成员函数，就是虚函数。12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;class A&#123;public: virtual void v_fun() // 虚函数 &#123; cout &lt;&lt; &quot;A::v_fun()&quot; &lt;&lt; endl; &#125;&#125;;class B : public A&#123;public: void v_fun() &#123; cout &lt;&lt; &quot;B::v_fun()&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; A *p = new B(); p-&gt;v_fun(); // B::v_fun() return 0;&#125;","text":"虚函数虚函数：被 virtual 关键字修饰的成员函数，就是虚函数。12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;class A&#123;public: virtual void v_fun() // 虚函数 &#123; cout &lt;&lt; &quot;A::v_fun()&quot; &lt;&lt; endl; &#125;&#125;;class B : public A&#123;public: void v_fun() &#123; cout &lt;&lt; &quot;B::v_fun()&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; A *p = new B(); p-&gt;v_fun(); // B::v_fun() return 0;&#125;纯虚函数： 纯虚函数在类中声明时，加上=0； 含有纯虚函数的类称为抽象类（只要含有纯虚函数这个类就是抽象类），类中只有接口，没有具体的实现方法； 继承纯虚函数的派生类，如果没有完全实现基类纯虚函数，依然是抽象类，不能实例化对象。 说明： 抽象类对象不能作为函数的参数，不能创建对象，不能作为函数返回类型； 可以声明抽象类指针，可以声明抽象类的引用； 子类必须继承父类的纯虚函数，并全部实现后，才能创建子类的对象。 虚函数和纯虚函数的区别？ 虚函数和纯虚函数可以出现在同一个类中，该类称为抽象基类。（含有纯虚函数的类称为抽象基类） 使用方式不同：虚函数可以直接使用，纯虚函数必须在派生类中实现后才能使用； 定义形式不同：虚函数在定义时在普通函数的基础上加上 virtual 关键字，纯虚函数定义时除了加上virtual 关键字还需要加上=0; 纯虚函数必须实现，否则编译器会报错； 对于实现纯虚函数的派生类，该纯虚函数在派生类中被称为虚函数，虚函数和纯虚函数都可以在派生类中重写； 析构函数最好定义为虚函数，特别是对于含有继承关系的类；析构函数可以定义为纯虚函数，此时，其所在的类为抽象基类，不能创建实例化对象。 虚函数的实现机制实现机制：虚函数通过虚函数表来实现。虚函数的地址保存在虚函数表中，在类的对象所在的内存空间中，保存了指向虚函数表的指针（称为“虚表指针”），通过虚表指针可以找到类对应的虚函数表。虚函数表解决了基类和派生类的继承问题和类中成员函数的覆盖问题，当用基类的指针来操作一个派生类的时候，这张虚函数表就指明了实际应该调用的函数。虚函数表相关知识点： 虚函数表存放的内容：类的虚函数的地址。 虚函数表建立的时间：编译阶段，即程序的编译过程中会将虚函数的地址放在虚函数表中。 虚表指针保存的位置：虚表指针存放在对象的内存空间中最前面的位置，这是为了保证正确取到虚函数的偏移量。 虚函数表和类绑定，虚表指针和对象绑定。即类的不同的对象的虚函数表是一样的，但是每个对象都有自己的虚表指针，来指向类的虚函数表。 实例123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;class Base&#123;public: virtual void B_fun1() &#123; cout &lt;&lt; &quot;Base::B_fun1()&quot; &lt;&lt; endl; &#125; virtual void B_fun2() &#123; cout &lt;&lt; &quot;Base::B_fun2()&quot; &lt;&lt; endl; &#125; virtual void B_fun3() &#123; cout &lt;&lt; &quot;Base::B_fun3()&quot; &lt;&lt; endl; &#125;&#125;;class Derive : public Base&#123;public: virtual void D_fun1() &#123; cout &lt;&lt; &quot;Derive::D_fun1()&quot; &lt;&lt; endl; &#125; virtual void D_fun2() &#123; cout &lt;&lt; &quot;Derive::D_fun2()&quot; &lt;&lt; endl; &#125; virtual void D_fun3() &#123; cout &lt;&lt; &quot;Derive::D_fun3()&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; Base *p = new Derive(); p-&gt;B_fun1(); // Base::B_fun1() return 0;&#125;基类和派生类的继承关系：基类的虚函数表：派生类的虚函数表：主函数中基类的指针p指向了派生类的对象，当调用函数B_fun1()时，通过派生类的虚函数表找到该函数的地址，从而完成调用。 单继承和多继承的虚函数表结构编译器处理虚函数表： 编译器将虚函数表的指针放在类的实例对象的内存空间中，该对象调用该类的虚函数时，通过指针找到虚函数表，根据虚函数表中存放的虚函数的地址找到对应的虚函数。 如果派生类没有重新定义基类的虚函数 A，则派生类的虚函数表中保存的是基类的虚函数 A 的地址，也就是说基类和派生类的虚函数 A 的地址是一样的。 如果派生类重写了基类的某个虚函数 B，则派生的虚函数表中保存的是重写后的虚函数 B 的地址，也就是说虚函数 B 有两个版本，分别存放在基类和派生类的虚函数表中。 如果派生类重新定义了新的虚函数 C，派生类的虚函数表保存新的虚函数 C 的地址。 单继承无虚函数覆盖的情况：123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;class Base&#123;public: virtual void B_fun1() &#123; cout &lt;&lt; &quot;Base::B_fun1()&quot; &lt;&lt; endl; &#125; virtual void B_fun2() &#123; cout &lt;&lt; &quot;Base::B_fun2()&quot; &lt;&lt; endl; &#125; virtual void B_fun3() &#123; cout &lt;&lt; &quot;Base::B_fun3()&quot; &lt;&lt; endl; &#125;&#125;;class Derive : public Base&#123;public: virtual void D_fun1() &#123; cout &lt;&lt; &quot;Derive::D_fun1()&quot; &lt;&lt; endl; &#125; virtual void D_fun2() &#123; cout &lt;&lt; &quot;Derive::D_fun2()&quot; &lt;&lt; endl; &#125; virtual void D_fun3() &#123; cout &lt;&lt; &quot;Derive::D_fun3()&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; Base *p = new Derive(); p-&gt;B_fun1(); // Base::B_fun1() return 0;&#125; 基类和派生类的继承关系：基类的虚函数表：派生类的虚函数表： 单继承有虚函数覆盖的情况：123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;class Base&#123;public: virtual void fun1() &#123; cout &lt;&lt; &quot;Base::fun1()&quot; &lt;&lt; endl; &#125; virtual void B_fun2() &#123; cout &lt;&lt; &quot;Base::B_fun2()&quot; &lt;&lt; endl; &#125; virtual void B_fun3() &#123; cout &lt;&lt; &quot;Base::B_fun3()&quot; &lt;&lt; endl; &#125;&#125;;class Derive : public Base&#123;public: virtual void fun1() &#123; cout &lt;&lt; &quot;Derive::fun1()&quot; &lt;&lt; endl; &#125; virtual void D_fun2() &#123; cout &lt;&lt; &quot;Derive::D_fun2()&quot; &lt;&lt; endl; &#125; virtual void D_fun3() &#123; cout &lt;&lt; &quot;Derive::D_fun3()&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; Base *p = new Derive(); p-&gt;fun1(); // Derive::fun1() return 0;&#125; 派生类的虚函数表： 多继承无虚函数覆盖的情况：1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;class Base1&#123;public: virtual void B1_fun1() &#123; cout &lt;&lt; &quot;Base1::B1_fun1()&quot; &lt;&lt; endl; &#125; virtual void B1_fun2() &#123; cout &lt;&lt; &quot;Base1::B1_fun2()&quot; &lt;&lt; endl; &#125; virtual void B1_fun3() &#123; cout &lt;&lt; &quot;Base1::B1_fun3()&quot; &lt;&lt; endl; &#125;&#125;;class Base2&#123;public: virtual void B2_fun1() &#123; cout &lt;&lt; &quot;Base2::B2_fun1()&quot; &lt;&lt; endl; &#125; virtual void B2_fun2() &#123; cout &lt;&lt; &quot;Base2::B2_fun2()&quot; &lt;&lt; endl; &#125; virtual void B2_fun3() &#123; cout &lt;&lt; &quot;Base2::B2_fun3()&quot; &lt;&lt; endl; &#125;&#125;;class Base3&#123;public: virtual void B3_fun1() &#123; cout &lt;&lt; &quot;Base3::B3_fun1()&quot; &lt;&lt; endl; &#125; virtual void B3_fun2() &#123; cout &lt;&lt; &quot;Base3::B3_fun2()&quot; &lt;&lt; endl; &#125; virtual void B3_fun3() &#123; cout &lt;&lt; &quot;Base3::B3_fun3()&quot; &lt;&lt; endl; &#125;&#125;;class Derive : public Base1, public Base2, public Base3&#123;public: virtual void D_fun1() &#123; cout &lt;&lt; &quot;Derive::D_fun1()&quot; &lt;&lt; endl; &#125; virtual void D_fun2() &#123; cout &lt;&lt; &quot;Derive::D_fun2()&quot; &lt;&lt; endl; &#125; virtual void D_fun3() &#123; cout &lt;&lt; &quot;Derive::D_fun3()&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; Base1 *p = new Derive(); p-&gt;B1_fun1(); // Base1::B1_fun1() return 0;&#125; 基类和派生类的关系：派生类的虚函数表：（基类的顺序和声明的顺序一致） 多继承有虚函数覆盖的情况：123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;class Base1&#123;public: virtual void fun1() &#123; cout &lt;&lt; &quot;Base1::fun1()&quot; &lt;&lt; endl; &#125; virtual void B1_fun2() &#123; cout &lt;&lt; &quot;Base1::B1_fun2()&quot; &lt;&lt; endl; &#125; virtual void B1_fun3() &#123; cout &lt;&lt; &quot;Base1::B1_fun3()&quot; &lt;&lt; endl; &#125;&#125;;class Base2&#123;public: virtual void fun1() &#123; cout &lt;&lt; &quot;Base2::fun1()&quot; &lt;&lt; endl; &#125; virtual void B2_fun2() &#123; cout &lt;&lt; &quot;Base2::B2_fun2()&quot; &lt;&lt; endl; &#125; virtual void B2_fun3() &#123; cout &lt;&lt; &quot;Base2::B2_fun3()&quot; &lt;&lt; endl; &#125;&#125;;class Base3&#123;public: virtual void fun1() &#123; cout &lt;&lt; &quot;Base3::fun1()&quot; &lt;&lt; endl; &#125; virtual void B3_fun2() &#123; cout &lt;&lt; &quot;Base3::B3_fun2()&quot; &lt;&lt; endl; &#125; virtual void B3_fun3() &#123; cout &lt;&lt; &quot;Base3::B3_fun3()&quot; &lt;&lt; endl; &#125;&#125;;class Derive : public Base1, public Base2, public Base3&#123;public: virtual void fun1() &#123; cout &lt;&lt; &quot;Derive::fun1()&quot; &lt;&lt; endl; &#125; virtual void D_fun2() &#123; cout &lt;&lt; &quot;Derive::D_fun2()&quot; &lt;&lt; endl; &#125; virtual void D_fun3() &#123; cout &lt;&lt; &quot;Derive::D_fun3()&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; Base1 *p1 = new Derive(); Base2 *p2 = new Derive(); Base3 *p3 = new Derive(); p1-&gt;fun1(); // Derive::fun1() p2-&gt;fun1(); // Derive::fun1() p3-&gt;fun1(); // Derive::fun1() return 0;&#125; 基类和派生类的关系：派生类的虚函数表： 如何禁止构造函数的使用？为类的构造函数增加= delete修饰符，可以达到虽然声明了构造函数但禁止使用的目的。1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;class A &#123;public: int var1, var2; A()&#123; var1 = 10; var2 = 20; &#125; A(int tmp1, int tmp2) = delete;&#125;;int main()&#123; A ex1; A ex2(12,13); // error: use of deleted function &#x27;A::A(int, int)&#x27; return 0;&#125; 什么是类的默认构造函数？默认构造函数：未提供任何实参，来控制默认初始化过程的构造函数称为默认构造函数。1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;class A&#123;public: A()&#123; // 类的默认构造函数 var = 10; c = &#x27;q&#x27;; &#125; int var; char c;&#125;;int main()&#123; A ex; cout &lt;&lt; ex.c &lt;&lt; endl &lt;&lt; ex.var &lt;&lt; endl; return 0;&#125;/*运行结果：q10*/ 构造函数、析构函数是否需要定义成虚函数？为什么？构造函数一般不定义为虚函数，原因： 从存储空间的角度考虑：构造函数是在实例化对象的时候进行调用，如果此时将构造函数定义成虚函数，需要通过访问该对象所在的内存空间才能进行虚函数的调用（因为需要通过指向虚函数表的指针调用虚函数表，虽然虚函数表在编译时就有了，但是没有虚函数的指针，虚函数的指针只有在创建了对象才有），但是此时该对象还未创建，便无法进行虚函数的调用。所以构造函数不能定义成虚函数。 从使用的角度考虑：虚函数是基类的指针指向派生类的对象时，通过该指针实现对派生类的虚函数的调用，构造函数是在创建对象时自动调用的。 从实现上考虑：虚函数表是在创建对象之后才有的，因此不能定义成虚函数。 从类型上考虑：在创建对象时需要明确其类型 析构函数一般定义成虚函数，原因： 析构函数定义成虚函数是为了防止内存泄漏，因为当基类的指针或者引用指向或绑定到派生类的对象时，如果未将基类的析构函数定义成虚函数，会调用基类的析构函数，那么只能将基类的成员所占的空间释放掉，派生类中特有的就会无法释放内存空间导致内存泄漏。 如何避免拷贝？最直观的想法是：将类的拷贝构造函数和赋值构造函数声明为私有 private，但对于类的成员函数和友元函数依然可以调用，达不到完全禁止类的对象被拷贝的目的，而且程序会出现错误，因为未对函数进行定义。 解决方法：声明一个基类，具体做法如下。 定义一个基类，将其中的拷贝构造函数和赋值构造函数声明为私有 private 派生类以私有 private 的方式继承基类12345678910111213class Uncopyable&#123;public: Uncopyable() &#123;&#125; ~Uncopyable() &#123;&#125;private: Uncopyable(const Uncopyable &amp;); // 拷贝构造函数 Uncopyable &amp;operator=(const Uncopyable &amp;); // 赋值构造函数&#125;;class A : private Uncopyable // 注意继承方式&#123; &#125;; 简单解释： 能够保证，在派生类 A 的成员函数和友元函数中无法进行拷贝操作，因为无法调用基类 Uncopyable 的拷贝构造函数或赋值构造函数。同样，在类的外部也无法进行拷贝操作。 如何减少构造函数开销？在构造函数中使用类初始化列表，会减少调用默认的构造函数产生的开销，具体原因可以参考本章“为什么用成员初始化列表会快些？”这个问题。12345678910111213141516171819202122232425class A&#123;private: int val;public: A() &#123; cout &lt;&lt; &quot;A()&quot; &lt;&lt; endl; &#125; A(int tmp) &#123; val = tmp; cout &lt;&lt; &quot;A(int &quot; &lt;&lt; val &lt;&lt; &quot;)&quot; &lt;&lt; endl; &#125;&#125;;class Test1&#123;private: A ex;public: Test1() : ex(1) // 成员列表初始化方式 &#123; &#125;&#125;; 多重继承时会出现什么状况？如何解决？多重继承（多继承）：是指从多个直接基类中产生派生类。多重继承容易出现的问题：命名冲突和数据冗余问题。 举例:123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;// 间接基类class Base1&#123;public: int var1;&#125;;// 直接基类class Base2 : public Base1&#123;public: int var2;&#125;;// 直接基类class Base3 : public Base1&#123;public: int var3;&#125;;// 派生类class Derive : public Base2, public Base3&#123;public: void set_var1(int tmp) &#123; var1 = tmp; &#125; // error: reference to &#x27;var1&#x27; is ambiguous. 命名冲突 void set_var2(int tmp) &#123; var2 = tmp; &#125; void set_var3(int tmp) &#123; var3 = tmp; &#125; void set_var4(int tmp) &#123; var4 = tmp; &#125;private: int var4;&#125;;int main()&#123; Derive d; return 0;&#125;上述程序的继承关系如下：（菱形继承）上述代码中存的问题：对于派生类Derive上述代码中存在直接继承关系和间接继承关系。 直接继承：Base2 、Base3 间接继承：Base1 对于派生类中继承的的成员变量 var1 ，从继承关系来看，实际上保存了两份，一份是来自基类 Base2，一份来自基类 Base3。因此，出现了命名冲突。解决方法 1： 声明出现冲突的成员变量来源于哪个类123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;// 间接基类class Base1&#123;public: int var1;&#125;;// 直接基类class Base2 : public Base1&#123;public: int var2;&#125;;// 直接基类class Base3 : public Base1&#123;public: int var3;&#125;;// 派生类 class Derive : public Base2, public Base3&#123;public: void set_var1(int tmp) &#123; Base2::var1 = tmp; &#125; // 这里声明成员变量来源于类 Base2，当然也可以声明来源于类 Base3 void set_var2(int tmp) &#123; var2 = tmp; &#125; void set_var3(int tmp) &#123; var3 = tmp; &#125; void set_var4(int tmp) &#123; var4 = tmp; &#125;private: int var4;&#125;;int main()&#123; Derive d; return 0;&#125;解决方法 2：虚继承使用虚继承的目的：保证存在命名冲突的成员变量在派生类中只保留一份，即使间接基类中的成员在派生类中只保留一份。在菱形继承关系中，间接基类称为虚基类，直接基类和间接基类之间的继承关系称为虚继承。实现方式：在继承方式前面加上virtual关键字。123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;// 间接基类，即虚基类class Base1&#123;public: int var1;&#125;;// 直接基类 class Base2 : virtual public Base1 // 虚继承&#123;public: int var2;&#125;;// 直接基类 class Base3 : virtual public Base1 // 虚继承&#123;public: int var3;&#125;;// 派生类class Derive : public Base2, public Base3&#123;public: void set_var1(int tmp) &#123; var1 = tmp; &#125; void set_var2(int tmp) &#123; var2 = tmp; &#125; void set_var3(int tmp) &#123; var3 = tmp; &#125; void set_var4(int tmp) &#123; var4 = tmp; &#125;private: int var4;&#125;;int main()&#123; Derive d; return 0;&#125;类之间的继承关系： 空类占多少字节？C++ 编译器会给一个空类自动生成哪些函数空类声明时编译器不会生成任何成员函数：对于空类，声明编译器不会生成任何的成员函数，只会生成 1 个字节的占位符。空类定义时编译器会生成 6 个成员函数：当空类 A 定义对象时，sizeof(A)仍是为 1，但编译器会生成 6 个成员函数：缺省的构造函数、拷贝构造函数、析构函数、赋值运算符、两个取址运算符。123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;/*class A&#123;&#125;; 该空类的等价写法如下：*/class A&#123;public: A()&#123;&#125;; // 缺省构造函数 A(const A &amp;tmp)&#123;&#125;; // 拷贝构造函数 ~A()&#123;&#125;; // 析构函数 A &amp;operator=(const A &amp;tmp)&#123;&#125;; // 赋值运算符 A *operator&amp;() &#123; return this; &#125;; // 取址运算符 const A *operator&amp;() const &#123; return this; &#125;; // 取址运算符（const 版本）&#125;;int main()&#123; A *p = new A(); cout &lt;&lt; &quot;sizeof(A):&quot; &lt;&lt; sizeof(A) &lt;&lt; endl; // sizeof(A):1 delete p; return 0;&#125; 为什么拷贝构造函数必须为引用？原因：避免拷贝构造函数无限制的递归，最终导致栈溢出。 C++ 类对象的初始化顺序构造函数调用顺序： 按照派生类继承基类的顺序，即派生列表中声明的顺序，依次调用基类的构造函数； 按照派生类中成员变量的声明顺序，依次调用派生类中成员变量所属类的构造函数； 执行派生类自身的构造函数。 综上可以得出，类对象的初始化顺序：基类构造函数–&gt;派生类成员变量的构造函数–&gt;自身构造函数注： 基类构造函数的调用顺序与派生类的派生列表中的顺序有关； 成员变量的初始化顺序与声明顺序有关； 析构顺序和构造顺序相反。12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;using namespace std;class A&#123;public: A() &#123; cout &lt;&lt; &quot;A()&quot; &lt;&lt; endl; &#125; ~A() &#123; cout &lt;&lt; &quot;~A()&quot; &lt;&lt; endl; &#125;&#125;;class B&#123;public: B() &#123; cout &lt;&lt; &quot;B()&quot; &lt;&lt; endl; &#125; ~B() &#123; cout &lt;&lt; &quot;~B()&quot; &lt;&lt; endl; &#125;&#125;;class Test : public A, public B // 派生列表&#123;public: Test() &#123; cout &lt;&lt; &quot;Test()&quot; &lt;&lt; endl; &#125; ~Test() &#123; cout &lt;&lt; &quot;~Test()&quot; &lt;&lt; endl; &#125;private: B ex1; A ex2;&#125;;int main()&#123; Test ex; return 0;&#125;/*运行结果：A()B()B()A()Test()~Test()~A()~B()~B()~A()*/ 程序运行结果分析： 首先调用基类 A 和 B 的构造函数，按照派生列表 public A, public B 的顺序构造； 然后调用派生类 Test 的成员变量 ex1 和 ex2 的构造函数，按照派生类中成员变量声明的顺序构造； 最后调用派生类的构造函数； 接下来调用析构函数，和构造函数调用的顺序相反。 如何禁止一个类被实例化？方法一： 在类中定义一个纯虚函数，使该类成为抽象基类，因为不能创建抽象基类的实例化对象； 方法二： 将类的构造函数声明为私有private 为什么用成员初始化列表会快一些？说明：数据类型可分为内置类型和用户自定义类型（类类型），对于用户自定义类型，利用成员初始化列表效率高。原因：用户自定义类型如果使用类初始化列表，直接调用该成员变量对应的构造函数即完成初始化；如果在构造函数中初始化，因为 C++ 规定，对象的成员变量的初始化动作发生在进入构造函数本体之前，那么在执行构造函数的函数体之前首先调用默认的构造函数为成员变量设初值，在进入函数体之后，调用该成员变量对应的构造函数。因此，使用列表初始化会减少调用默认的构造函数的过程，效率高。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;using namespace std;class A&#123;private: int val;public: A() &#123; cout &lt;&lt; &quot;A()&quot; &lt;&lt; endl; &#125; A(int tmp) &#123; val = tmp; cout &lt;&lt; &quot;A(int &quot; &lt;&lt; val &lt;&lt; &quot;)&quot; &lt;&lt; endl; &#125;&#125;;class Test1&#123;private: A ex;public: Test1() : ex(1) // 成员列表初始化方式 &#123; &#125;&#125;;class Test2&#123;private: A ex;public: Test2() // 函数体中赋值的方式 &#123; ex = A(2); &#125;&#125;;int main()&#123; Test1 ex1; cout &lt;&lt; endl; Test2 ex2; return 0;&#125;/*运行结果：A(int 1)A()A(int 2)*/说明： 从程序运行结果可以看出，使用成员列表初始化的方式会省去调用默认的构造函数的过程。 实例化一个对象需要哪几个阶段 分配空间 创建类对象首先要为该对象分配内存空间。不同的对象，为其分配空间的时机未必相同。全局对象、静态对象、分配在栈区域内的对象，在编译阶段进行内存分配；存储在堆空间的对象，是在运行阶段进行内存分配。 初始化 首先明确一点：初始化不同于赋值。初始化发生在赋值之前，初始化随对象的创建而进行，而赋值是在对象创建好后，为其赋上相应的值。这一点可以联想下上一个问题中提到：初始化列表先于构造函数体内的代码执行，初始化列表执行的是数据成员的初始化过程，这个可以从成员对象的构造函数被调用看的出来。 赋值 对象初始化完成后，可以对其进行赋值。对于一个类的对象，其成员变量的赋值过程发生在类的构造函数的函数体中。当执行完该函数体，也就意味着类对象的实例化过程完成了。（总结：构造函数实现了对象的初始化和赋值两个过程，对象的初始化是通过初始化列表来完成，而对象的赋值则才是通过构造函数的函数体来实现。） 注：对于拥有虚函数的类的对象，还需要给虚表指针赋值。 没有继承关系的类，分配完内存后，首先给虚表指针赋值，然后再列表初始化以及执行构造函数的函数体，即上述中的初始化和赋值操作。 有继承关系的类，分配内存之后，首先进行基类的构造过程，然后给该派生类的虚表指针赋值，最后再列表初始化以及执行构造函数的函数体，即上述中的初始化和赋值操作。 友元函数的作用及使用场景作用：友元提供了不同类的成员函数之间、类的成员函数与一般函数之间进行数据共享的机制。通过友元，一个不同函数或另一个类中的成员函数可以访问类中的私有成员和保护成员。 使用场景： 普通函数定义为友元函数，使普通函数能够访问类的私有成员。1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;class A&#123; friend ostream &amp;operator&lt;&lt;(ostream &amp;_cout, const A &amp;tmp); // 声明为类的友元函数public: A(int tmp) : var(tmp) &#123; &#125;private: int var;&#125;;ostream &amp;operator&lt;&lt;(ostream &amp;_cout, const A &amp;tmp)&#123; _cout &lt;&lt; tmp.var; return _cout;&#125;int main()&#123; A ex(4); cout &lt;&lt; ex &lt;&lt; endl; // 4 return 0;&#125; 友元类：类之间共享数据。123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;class A&#123; friend class B;public: A() : var(10)&#123;&#125; A(int tmp) : var(tmp) &#123;&#125; void fun() &#123; cout &lt;&lt; &quot;fun():&quot; &lt;&lt; var &lt;&lt; endl; &#125;private: int var;&#125;;class B&#123;public: B() &#123;&#125; void fun() &#123; cout &lt;&lt; &quot;fun():&quot; &lt;&lt; ex.var &lt;&lt; endl; // 访问类 A 中的私有成员 &#125;private: A ex;&#125;;int main()&#123; B ex; ex.fun(); // fun():10 return 0;&#125; 深拷贝和浅拷贝的区别如果一个类拥有资源，该类的对象进行复制时，如果资源重新分配，就是深拷贝，否则就是浅拷贝。 深拷贝：该对象和原对象占用不同的内存空间，既拷贝存储在栈空间中的内容，又拷贝存储在堆空间中的内容。 浅拷贝：该对象和原对象占用同一块内存空间，仅拷贝类中位于栈空间中的内容 当类的成员变量中有指针变量时，最好使用深拷贝。因为当两个对象指向同一块内存空间，如果使用浅拷贝，当其中一个对象的删除后，该块内存空间就会被释放，另外一个对象指向的就是垃圾内存。 浅拷贝实例123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;class Test&#123;private: int *p;public: Test(int tmp) &#123; this-&gt;p = new int(tmp); cout &lt;&lt; &quot;Test(int tmp)&quot; &lt;&lt; endl; &#125; ~Test() &#123; if (p != NULL) &#123; delete p; &#125; cout &lt;&lt; &quot;~Test()&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; Test ex1(10); Test ex2 = ex1; return 0;&#125;/*运行结果：Test(int tmp)~Test()*/说明：上述代码中，类对象 ex1、ex2 实际上是指向同一块内存空间，对象析构时，ex2 先将内存释放了一次，之后 析构对象 ex1 时又将这块已经被释放过的内存再释放一次。对同一块内存空间释放了两次，会导致程序崩溃。 深拷贝实例：123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;class Test&#123;private: int *p;public: Test(int tmp) &#123; p = new int(tmp); cout &lt;&lt; &quot;Test(int tmp)&quot; &lt;&lt; endl; &#125; ~Test() &#123; if (p != NULL) &#123; delete p; &#125; cout &lt;&lt; &quot;~Test()&quot; &lt;&lt; endl; &#125; Test(const Test &amp;tmp) // 定义拷贝构造函数 &#123; p = new int(*tmp.p); cout &lt;&lt; &quot;Test(const Test &amp;tmp)&quot; &lt;&lt; endl; &#125;&#125;; 编译时多态和运行时多态的区别编译时多态：在程序编译过程中出现，发生在模板和函数重载中（泛型编程）。 运行时多态：在程序运行过程中出现，发生在继承体系中，是指通过基类的指针或引用访问派生类中的虚函数。 编译时多态和运行时多态的区别： 时期不同：编译时多态发生在程序编译过程中，运行时多态发生在程序的运行过程中； 实现方式不同：编译时多态运用泛型编程来实现，运行时多态借助虚函数来实现。 实现一个类成员函数，要求不允许修改类的成员变量？如果想达到一个类的成员函数不能修改类的成员变量，只需用 const 关键字来修饰该函数即可。123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;class A&#123;public: int var1, var2; A() &#123; var1 = 10; var2 = 20; &#125; void fun() const // 不能在 const 修饰的成员函数中修改成员变量的值，除非该成员变量用 mutable 修饰 &#123; var1 = 100; // error: assignment of member &#x27;A::var1&#x27; in read-only object &#125;&#125;;int main()&#123; A ex1; return 0;&#125; 如何让类不能被继承？解决方法一：借助final关键字，用该关键字修饰的类不能被继承。1234567891011121314151617#include &lt;iostream&gt;using namespace std;class Base final&#123;&#125;;class Derive: public Base&#123; // error: cannot derive from &#x27;final&#x27; base &#x27;Base&#x27; in derived type &#x27;Derive&#x27;&#125;;int main()&#123; Derive ex; return 0;&#125;解决方法二：借助友元、虚继承和私有构造函数来实现123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;class Base&#123; friend T;private: Base()&#123; cout &lt;&lt; &quot;base&quot; &lt;&lt; endl; &#125; ~Base()&#123;&#125;&#125;;class B:virtual public Base&lt;B&gt;&#123; //一定注意 必须是虚继承public: B()&#123; cout &lt;&lt; &quot;B&quot; &lt;&lt; endl; &#125;&#125;;class C:public B&#123;public: C()&#123;&#125; // error: &#x27;Base&lt;T&gt;::Base() [with T = B]&#x27; is private within this context&#125;;int main()&#123; B b; return 0;&#125;;说明：在上述代码中 B 类是不能被继承的类。 具体原因： 虽然 Base 类构造函数和析构函数被声明为私有 private，在 B 类中，由于 B 是 Base 的友元，因此可以访问 Base 类构造函数，从而正常创建 B 类的对象； B 类继承 Base 类采用虚继承的方式，创建 C 类的对象时，C 类的构造函数要负责 Base 类的构造，但是 Base 类的构造函数私有化了，C 类没有权限访问。因此，无法创建 C 类的对象， B 类是不能被继承的类。 注意：在继承体系中，友元关系不能被继承，虽然 C 类继承了 B 类，B 类是 Base 类的友元，但是 C 类和 Base 类没有友元关系。","categories":[{"name":"八股文","slug":"八股文","permalink":"https://wangtianyang.com/categories/%E5%85%AB%E8%82%A1%E6%96%87/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://wangtianyang.com/tags/C/"}]},{"title":"【C++】关键字库函数","slug":"【C-】关键字库函数","date":"2022-03-06T05:37:20.000Z","updated":"2023-01-06T13:46:43.923Z","comments":true,"path":"2022/03/06/【C-】关键字库函数/","link":"","permalink":"https://wangtianyang.com/2022/03/06/%E3%80%90C-%E3%80%91%E5%85%B3%E9%94%AE%E5%AD%97%E5%BA%93%E5%87%BD%E6%95%B0/","excerpt":"strlen和sizeof的区别strlen测量的是字符串的实际长度（其源代码如下），以\\0结束。而sizeof测量的是字符数组的分配大小。123456789101112#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main()&#123; char arr[10] = &quot;hello&quot;; cout &lt;&lt; strlen(arr) &lt;&lt; endl; // 5 cout &lt;&lt; sizeof(arr) &lt;&lt; endl; // 10 return 0;&#125;若字符数组 arr 作为函数的形参，sizeof(arr) 中 arr 被当作字符指针来处理，strlen(arr) 中 arr 依然是字符数组，从下述程序的运行结果中就可以看出。","text":"strlen和sizeof的区别strlen测量的是字符串的实际长度（其源代码如下），以\\0结束。而sizeof测量的是字符数组的分配大小。123456789101112#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main()&#123; char arr[10] = &quot;hello&quot;; cout &lt;&lt; strlen(arr) &lt;&lt; endl; // 5 cout &lt;&lt; sizeof(arr) &lt;&lt; endl; // 10 return 0;&#125;若字符数组 arr 作为函数的形参，sizeof(arr) 中 arr 被当作字符指针来处理，strlen(arr) 中 arr 依然是字符数组，从下述程序的运行结果中就可以看出。12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;void size_of(char arr[])&#123; cout &lt;&lt; sizeof(arr) &lt;&lt; endl; // warning: &#x27;sizeof&#x27; on array function parameter &#x27;arr&#x27; will return size of &#x27;char*&#x27; . cout &lt;&lt; strlen(arr) &lt;&lt; endl; &#125;int main()&#123; char arr[20] = &quot;hello&quot;; size_of(arr); return 0;&#125;/*输出结果：85*/ strlen本身是库函数，因此在程序运行过程中，计算长度；而sizeof在编译时，计算长度； sizeof的参数可以是类型，也可以是变量；strlen的参数必须是char*类型的变量。 lambda 表达式（匿名函数）的具体应用和使用场景lambda 表达式的定义形式如下：1234[capture list] (parameter list) -&gt; reurn type&#123; function body&#125;其中： capture list：捕获列表，指 lambda 表达式所在函数中定义的局部变量的列表，通常为空，但如果函数体中用到了 lambda 表达式所在函数的局部变量，必须捕获该变量，即将此变量写在捕获列表中。捕获方式分为：引用捕获方式 [&amp;]、值捕获方式 [=]。 return type、parameter list、function body：分别表示返回值类型、参数列表、函数体，和普通函数一样。 举例：lambda表达式常搭配排序算法使用。123456789101112131415161718#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; vector&lt;int&gt; arr = &#123;3, 4, 76, 12, 54, 90, 34&#125;; sort(arr.begin(), arr.end(), [](int a, int b) &#123; return a &gt; b; &#125;); // 降序排序 for (auto a : arr) &#123; cout &lt;&lt; a &lt;&lt; &quot; &quot;; &#125; return 0;&#125;/*运行结果：90 76 54 34 12 4 3*/ explicit 的作用（如何避免编译器进行隐式类型转换）作用：用来声明类构造函数是显示调用[1]的，而非隐式调用，可以阻止调用构造函数时进行隐式转换。只可用于修饰单参构造函数，因为无参构造函数和多参构造函数本身就是显示调用的，再加上explicit关键字也没有什么意义。123456789101112131415161718#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;class A&#123;public: int var; A(int tmp) &#123; var = tmp; &#125;&#125;;int main()&#123; A ex = 10; // 发生了隐式转换 return 0;&#125;上述代码中，A ex = 10;在编译时，进行了隐式转换，将 10 转换成 A 类型的对象，然后将该对象赋值给 ex，等同于如下操作：为了避免隐式转换，可用 explicit 关键字进行声明：1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;class A&#123;public: int var; explicit A(int tmp) &#123; var = tmp; cout &lt;&lt; var &lt;&lt; endl; &#125;&#125;;int main()&#123; A ex(100); A ex1 = 10; // error: conversion from &#x27;int&#x27; to non-scalar type &#x27;A&#x27; requested return 0;&#125; static 的作用作用： static 定义静态变量，静态函数。 保持变量内容持久：static 作用于局部变量，改变了局部变量的生存周期，使得该变量存在于定义后直到程序运行结束的这段时间。123456789101112131415#include &lt;iostream&gt;using namespace std;int fun()&#123; static int var = 1; // var 只在第一次进入这个函数的时初始化 var += 1; return var;&#125; int main()&#123; for(int i = 0; i &lt; 10; ++i) cout &lt;&lt; fun() &lt;&lt; &quot; &quot;; // 2 3 4 5 6 7 8 9 10 11 return 0;&#125; 隐藏：static 作用于全局变量和函数，改变了全局变量和函数的作用域，使得全局变量和函数只能在定义它的文件中使用，在源文件中不具有全局可见性。（注：普通全局变量和函数具有全局可见性，即其他的源文件也可以使用。） static 作用于类的成员变量和类的成员函数，使得类变量或者类成员函数和类有关，也就是说可以不定义类的对象就可以通过类访问这些静态成员。注意：类的静态成员函数中只能访问静态成员变量或者静态成员函数，不能将静态成员函数定义成虚函数。123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;using namespace std;class A&#123;private: int var; static int s_var; // 静态成员变量public: void show() &#123; cout &lt;&lt; s_var++ &lt;&lt; endl; &#125; static void s_show() &#123; cout &lt;&lt; s_var &lt;&lt; endl; // cout &lt;&lt; var &lt;&lt; endl; // error: invalid use of member &#x27;A::a&#x27; in static member function. 静态成员函数不能调用非静态成员变量。无法使用 this.var // show(); // error: cannot call member function &#x27;void A::show()&#x27; without object. 静态成员函数不能调用非静态成员函数。无法使用 this.show() &#125;&#125;;int A::s_var = 1; // 静态成员变量在类外进行初始化赋值，默认初始化为 0int main()&#123; // cout &lt;&lt; A::sa &lt;&lt; endl; // error: &#x27;int A::sa&#x27; is private within this context A ex; ex.show(); A::s_show();&#125; static 在类中使用的注意事项（定义、初始化和使用）static 静态成员变量： 静态成员变量是在类内进行声明，在类外进行定义和初始化，在类外进行定义和初始化的时候不要出现 static 关键字和private、public、protected 访问规则。 静态成员变量相当于类域中的全局变量，被类的所有对象所共享，包括派生类的对象。 静态成员变量可以作为成员函数的参数，而普通成员变量不可以。123456789101112131415#include &lt;iostream&gt;using namespace std;class A&#123;public: static int s_var; int var; void fun1(int i = s_var); // 正确，静态成员变量可以作为成员函数的参数 void fun2(int i = var); // error: invalid use of non-static data member &#x27;A::var&#x27;&#125;;int main()&#123; return 0;&#125; 静态数据成员的类型可以是所属类的类型，而普通数据成员的类型只能是该类类型的指针或引用。12345678910111213141516#include &lt;iostream&gt;using namespace std;class A&#123;public: static A s_var; // 正确，静态数据成员 A var; // error: field &#x27;var&#x27; has incomplete type &#x27;A&#x27; A *p; // 正确，指针 A &amp;var1; // 正确，引用&#125;;int main()&#123; return 0;&#125; static 静态成员函数： 静态成员函数不能调用非静态成员变量或者非静态成员函数，因为静态成员函数没有 this 指针。静态成员函数做为类作用域的全局函数。 静态成员函数不能声明成虚函数（virtual）、const 函数和 volatile 函数。 static 全局变量和普通全局变量的异同相同点： 存储方式：普通全局变量和 static 全局变量都是静态存储方式。 不同点： 作用域：普通全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，普通全局变量在各个源文件中都是有效的；静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。 初始化：静态全局变量只初始化一次，防止在其他文件中使用。 const 作用及用法作用： const 修饰成员变量，定义成 const 常量，相较于宏常量，可进行类型检查，节省内存空间，提高了效率。 const 修饰函数参数，使得传递过来的函数参数的值不能改变。 const 修饰成员函数，使得成员函数不能修改任何类型的成员变量（mutable 修饰的变量除外），也不能调用非 const 成员函数，因为非 const 成员函数可能会修改成员变量 在类中的用法：const 成员变量： const 成员变量只能在类内声明、定义，在构造函数初始化列表中初始化。 const 成员变量只在某个对象的生存周期内是常量，对于整个类而言却是可变的，因为类可以创建多个对象，不同类的 const 成员变量的值是不同的。因此不能在类的声明中初始化 const 成员变量，类的对象还没有创建，编译器不知道他的值。 const 成员函数： 不能修改成员变量的值，除非有 mutable 修饰；只能访问成员变量。 不能调用非常量成员函数，以防修改成员变量的值。123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;class A&#123;public: int var; A(int tmp) : var(tmp) &#123;&#125; void c_fun(int tmp) const // const 成员函数 &#123; var = tmp; // error: assignment of member &#x27;A::var&#x27; in read-only object. 在 const 成员函数中，不能修改任何类成员变量。 fun(tmp); // error: passing &#x27;const A&#x27; as &#x27;this&#x27; argument discards qualifiers. const 成员函数不能调用非 const 成员函数，因为非 const 成员函数可能会修改成员变量。 &#125; void fun(int tmp) &#123; var = tmp; &#125;&#125;;int main()&#123; return 0;&#125; define 和 const 的区别区别： 编译阶段：define 是在编译预处理阶段进行替换，const 是在编译阶段确定其值。 安全性：define 定义的宏常量没有数据类型，只是进行简单的替换，不会进行类型安全的检查；const 定义的常量是有类型的，是要进行判断的，可以避免一些低级的错误。 内存占用：define 定义的宏常量，在程序中使用多少次就会进行多少次替换，内存中有多个备份，占用的是代码段的空间；const 定义的常量占用静态存储区的空间，程序运行过程中只有一份。 调试：define 定义的宏常量不能调试，因为在预编译阶段就已经进行替换了；const 定义的常量可以进行调试。 const 的优点： 有数据类型，在定义式可进行安全性检查。 可调试。 占用较少的空间。 define 和 typedef 的区别 原理：#define作为预处理指令，在编译预处理时进行替换操作，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。typedef是关键字，在编译时处理，有类型检查功能，用来给一个已经存在的类型一个别名，但不能在一个函数定义里面使用typedef。 功能：typedef用来定义类型的别名，方便使用。#define不仅可以为类型取别名，还可以定义常量、变量、编译开关等。 作用域：#define没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而typedef有自己的作用域。 指针的操作：typedef和#define在处理指针时不完全一样。1234567891011121314151617#include &lt;iostream&gt;#define INTPTR1 int *typedef int * INTPTR2;using namespace std;int main()&#123; INTPTR1 p1, p2; // p1: int *; p2: int INTPTR2 p3, p4; // p3: int *; p4: int * int var = 1; const INTPTR1 p5 = &amp;var; // 相当于 const int * p5; 常量指针，即不可以通过 p5 去修改 p5 指向的内容，但是 p5 可以指向其他内容。 const INTPTR2 p6 = &amp;var; // 相当于 int * const p6; 指针常量，不可使 p6 再指向其他内容。 return 0;&#125; inline 作用及使用方法作用： inline 是一个关键字，可以用于定义内联函数。内联函数，像普通函数一样被调用，但是在调用时并不通过函数调用的机制而是直接在调用点处展开，这样可以大大减少由函数调用带来的开销，从而提高程序的运行效率。 使用方法： 类内定义成员函数默认是内联函数 在类内定义成员函数，可以不用在函数头部加 inline 关键字，因为编译器会自动将类内定义的函数（构造函数、析构函数、普通成员函数等）声明为内联函数，代码如下：123456789101112131415161718#include &lt;iostream&gt;using namespace std;class A&#123;public: int var; A(int tmp)&#123; var = tmp; &#125; void fun()&#123; cout &lt;&lt; var &lt;&lt; endl; &#125;&#125;;int main()&#123; return 0;&#125; 类外定义成员函数，若想定义为内联函数，需用关键字声明 当在类内声明函数，在类外定义函数时，如果想将该函数定义为内联函数，则可以在类内声明时不加 inline 关键字，而在类外定义函数时加上 inline 关键字。1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;class A&#123;public: int var; A(int tmp)&#123; var = tmp; &#125; void fun();&#125;;inline void A::fun()&#123; cout &lt;&lt; var &lt;&lt; endl;&#125;int main()&#123; return 0;&#125; 另外，可以在声明函数和定义函数的同时加上 inline；也可以只在函数声明时加 inline，而定义函数时不加 inline。只要确保在调用该函数之前把 inline 的信息告知编译器即可。 inline 函数工作原理 内联函数不是在调用时发生控制转移关系，而是在编译阶段将函数体嵌入到每一个调用该函数的语句块中，编译器会将程序中出现内联函数的调用表达式用内联函数的函数体来替换。 普通函数是将程序执行转移到被调用函数所存放的内存地址，当函数执行完后，返回到执行此函数前的地方。转移操作需要保护现场，被调函数执行完后，再恢复现场，该过程需要较大的资源开销。 宏定义（define）和内联函数（inline）的区别 内联函数是在编译时展开，而宏在编译预处理时展开；在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。 内联函数是真正的函数，和普通函数调用的方法一样，在调用点处直接展开，避免了函数的参数压栈操作，减少了调用的开销。而宏定义编写较为复杂，常需要增加一些括号来避免歧义。 宏定义只进行文本替换，不会对参数的类型、语句能否正常编译等进行检查。而内联函数是真正的函数，会对参数的类型、函数体内的语句编写是否正确等进行检查。 new 和 malloc 如何判断是否申请到内存？ malloc ：成功申请到内存，返回指向该内存的指针；分配失败，返回 NULL 指针。 new ：内存分配成功，返回该对象类型的指针；分配失败，抛出 bad_alloc 异常。 delete 实现原理？delete 和 delete[] 的区别？delete 的实现原理： 首先执行该对象所属类的析构函数； 进而通过调用 operator delete 的标准库函数来释放所占的内存空间。 delete 和 delete [] 的区别： delete 用来释放单个对象所占的空间，只会调用一次析构函数； delete [] 用来释放数组空间，会对数组中的每个成员都调用一次析构函数。 new 和 malloc 的区别，delete 和 free 的区别在使用的时候new、delete搭配使用，malloc、free搭配使用。 malloc、free是库函数，而new、delete是关键字。new申请空间时，无需指定分配空间的大小，编译器会根据类型自行计算；malloc在申请空间时，需要确定所申请空间的大小。 new申请空间时，返回的类型是对象的指针类型，无需强制类型转换，是类型安全的操作符；malloc申请空间时，返回的是void*类型，需要进行强制类型的转换，转换为对象类型的指针。 new分配失败时，会抛出bad_alloc异常，malloc分配失败时返回空指针。 对于自定义的类型，new首先调用operator new()函数申请空间（底层通过malloc实现），然后调用构造函数进行初始化，最后返回自定义类型的指针；delete首先调用析构函数，然后调用operator delete()释放空间（底层通过free实现）。malloc、free无法进行自定义类型的对象的构造和析构。 new操作符从自由存储区上为对象动态分配内存，而malloc函数从堆上动态分配内存。（自由存储区不等于堆） malloc 的原理？malloc 的底层实现？malloc的原理: 当开辟的空间小于 128K 时，调用brk()函数，通过移动_enddata来实现； 当开辟空间大于 128 K 时，调用mmap()函数，通过在虚拟地址空间中开辟一块内存空间来实现。 malloc的底层实现： brk()函数实现原理：向高地址的方向移动指向数据段的高地址的指针_enddata。 mmap内存映射原理： 进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域； 调用内核空间的系统调用函数mmap()，实现文件物理地址和进程虚拟地址的一一映射关系； 进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝。 C 和 C++ struct 的区别？ 在 C 语言中struct是用户自定义数据类型；在 C++ 中struct是抽象数据类型，支持成员函数的定义。 C 语言中struct没有访问权限的设置，是一些变量的集合体，不能定义成员函数；C++ 中struct可以和类一样，有访问权限，并可以定义成员函数。 C 语言中struct定义的自定义数据类型，在定义该类型的变量时，需要加上struct关键字，例如：struct A var;，定义 A 类型的变量；而 C++ 中，不用加该关键字，例如：A var; struct 和 union 的区别说明：union 是联合体，struct 是结构体。区别： 联合体和结构体都是由若干个数据类型不同的数据成员组成。使用时，联合体只有一个有效的成员；而结构体所有的成员都有效。 对联合体的不同成员赋值，将会对覆盖其他成员的值，而对于结构体的对不同成员赋值时，相互不影响。 联合体的大小为其内部所有变量的最大值，按照最大类型的倍数进行分配大小；结构体分配内存的大小遵循内存对齐原则。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;using namespace std;typedef union&#123; char c[10]; char cc1; // char 1 字节，按该类型的倍数分配大小&#125; u11;typedef union&#123; char c[10]; int i; // int 4 字节，按该类型的倍数分配大小&#125; u22;typedef union&#123; char c[10]; double d; // double 8 字节，按该类型的倍数分配大小&#125; u33;typedef struct s1&#123; char c; // 1 字节 double d; // 1（char）+ 7（内存对齐）+ 8（double）= 16 字节&#125; s11;typedef struct s2&#123; char c; // 1 字节 char cc; // 1（char）+ 1（char）= 2 字节 double d; // 2 + 6（内存对齐）+ 8（double）= 16 字节&#125; s22;typedef struct s3&#123; char c; // 1 字节 double d; // 1（char）+ 7（内存对齐）+ 8（double）= 16 字节 char cc; // 16 + 1（char）+ 7（内存对齐）= 24 字节&#125; s33;int main()&#123; cout &lt;&lt; sizeof(u11) &lt;&lt; endl; // 10 cout &lt;&lt; sizeof(u22) &lt;&lt; endl; // 12 cout &lt;&lt; sizeof(u33) &lt;&lt; endl; // 16 cout &lt;&lt; sizeof(s11) &lt;&lt; endl; // 16 cout &lt;&lt; sizeof(s22) &lt;&lt; endl; // 16 cout &lt;&lt; sizeof(s33) &lt;&lt; endl; // 24 cout &lt;&lt; sizeof(int) &lt;&lt; endl; // 4 cout &lt;&lt; sizeof(double) &lt;&lt; endl; // 8 return 0;&#125; class 和 struct 的异同 struct和class都可以自定义数据类型，也支持继承操作。 struct中默认的访问级别是public，默认的继承级别也是public；class中默认的访问级别是private，默认的继承级别也是private。 当class继承struct或者struct继承class时，默认的继承级别取决于class或struct本身，class（private 继承），struct（public 继承），即取决于派生类的默认继承级别。123struct A&#123;&#125;；class B : A&#123;&#125;; // private 继承 struct C : B&#123;&#125;； // public 继承 举例：12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;using namespace std;class A&#123;public: void funA()&#123; cout &lt;&lt; &quot;class A&quot; &lt;&lt; endl; &#125;&#125;;struct B: A&#123; // 由于 B 是 struct，A 的默认继承级别为 publicpublic: void funB()&#123; cout &lt;&lt; &quot;class B&quot; &lt;&lt; endl; &#125;&#125;;class C: B&#123; // 由于 C 是 class，B 的默认继承级别为 private，所以无法访问基类 B 中的 printB 函数&#125;;int main()&#123; A ex1; ex1.funA(); // class A B ex2; ex2.funA(); // class A ex2.funB(); // class B C ex3; ex3.funB(); // error: &#x27;B&#x27; is not an accessible base of &#x27;C&#x27;. return 0;&#125; volatile 的作用？是否具有原子性，对编译器有什么影响？volatile的作用：当对象的值可能在程序的控制或检测之外被改变时，应该将该对象声明为 violatile，告知编译器不应对这样的对象进行优化。volatile不具有原子性。volatile对编译器的影响：使用该关键字后，编译器不会对相应的对象进行优化，即不会将变量从内存缓存到寄存器中，防止多个线程有可能使用内存中的变量，有可能使用寄存器中的变量，从而导致程序错误。 什么情况下一定要用 volatile， 能否和 const 一起使用？使用volatile关键字的场景： 当多个线程都会用到某一变量，并且该变量的值有可能发生改变时，需要用volatile关键字对该变量进行修饰； 中断服务程序中访问的变量或并行设备的硬件寄存器的变量，最好用volatile关键字修饰。 volatile关键字和const关键字可以同时使用，某种类型可以既是volatile又是const，同时具有二者的属性。 返回函数中静态变量的地址会发生什么？123456789101112131415161718#include &lt;iostream&gt;using namespace std;int * fun(int tmp)&#123; static int var = 10; var *= tmp; return &amp;var;&#125;int main() &#123; cout &lt;&lt; *fun(5) &lt;&lt; endl; return 0;&#125;/*运行结果：50*/ 说明：上述代码中在函数fun中定义了静态局部变量var，使得离开该函数的作用域后，该变量不会销毁，返回到主函数中，该变量依然存在，从而使程序得到正确的运行结果。但是，该静态局部变量直到程序运行结束后才销毁，浪费内存空间。 extern C 的作用？当 C++ 程序 需要调用 C 语言编写的函数，C++ 使用链接指示，即extern &quot;C&quot;指出任意非 C++ 函数所用的语言。 举例：1234// 可能出现在 C++ 头文件&lt;cstring&gt;中的链接指示extern &quot;C&quot;&#123; int strcmp(const char*, const char*);&#125; sizeof(1==1) 在 C 和 C++ 中分别是什么结果？C 语言代码：12345678910#include&lt;stdio.h&gt;void main()&#123; printf(&quot;%d\\n&quot;, sizeof(1==1));&#125;/*运行结果：4*/C++ 代码：1234567891011#include &lt;iostream&gt;using namespace std;int main() &#123; cout &lt;&lt; sizeof(1==1) &lt;&lt; endl; return 0;&#125;/*1*/ memmove函数的底层原理？12345678910111213141516171819202122232425262728293031void *memcpy(void *dst, const void *src, size_t size)&#123; char *psrc; char *pdst; if (NULL == dst || NULL == src) &#123; return NULL; &#125; if ((src &lt; dst) &amp;&amp; (char *)src + size &gt; (char *)dst) // 出现地址重叠的情况，自后向前拷贝 &#123; psrc = (char *)src + size - 1; pdst = (char *)dst + size - 1; while (size--) &#123; *pdst-- = *psrc--; &#125; &#125; else &#123; psrc = (char *)src; pdst = (char *)dst; while (size--) &#123; *pdst++ = *psrc++; &#125; &#125; return dst;&#125; strcpy 函数有什么缺陷？strcpy 函数的缺陷：strcpy 函数不检查目的缓冲区的大小边界，而是将源字符串逐一的全部赋值给目的字符串地址起始的一块连续的内存空间，同时加上字符串终止符，会导致其他变量被覆盖。12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main()&#123; int var = 0x11112222; char arr[10]; cout &lt;&lt; &quot;Address : var &quot; &lt;&lt; &amp;var &lt;&lt; endl; cout &lt;&lt; &quot;Address : arr &quot; &lt;&lt; &amp;arr &lt;&lt; endl; strcpy(arr, &quot;hello world!&quot;); cout &lt;&lt; &quot;var:&quot; &lt;&lt; hex &lt;&lt; var &lt;&lt; endl; // 将变量 var 以 16 进制输出 cout &lt;&lt; &quot;arr:&quot; &lt;&lt; arr &lt;&lt; endl; return 0;&#125;/*Address : var 0x23fe4cAddress : arr 0x23fe42var:11002164arr:hello world!*/说明：从上述代码中可以看出，变量var的后六位被字符串&quot;hello world!&quot;的&quot;d!\\0&quot;这三个字符改变，这三个字符对应的 ASCII 码的十六进制为：\\0(0x00)，!(0x21)，d(0x64)。 原因：变量arr只分配的 10 个内存空间，通过上述程序中的地址可以看出arr和var在内存中是连续存放的，但是在调用strcpy函数进行拷贝时，源字符串&quot;hello world!&quot;所占的内存空间为 13，因此在拷贝的过程中会占用var的内存空间，导致var的后六位被覆盖。 auto 类型推导的原理auto类型推导的原理： 编译器根据初始值来推算变量的类型，要求用auto定义变量时必须有初始值。编译器推断出来的auto类型有时和初始值类型并不完全一样，编译器会适当改变结果类型使其更符合初始化规则。 1.显示调用和隐式调用：显示调用是指在程序中能找到相应的调用代码，或者说是手动调用的；隐式调用是指程序中找不到相应的调用代码，或者说是编译器自动调用的 ↩","categories":[{"name":"八股文","slug":"八股文","permalink":"https://wangtianyang.com/categories/%E5%85%AB%E8%82%A1%E6%96%87/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://wangtianyang.com/tags/C/"}]},{"title":"【C++】面向对象","slug":"【C-】面向对象","date":"2022-03-04T06:06:50.000Z","updated":"2023-01-06T13:46:16.001Z","comments":true,"path":"2022/03/04/【C-】面向对象/","link":"","permalink":"https://wangtianyang.com/2022/03/04/%E3%80%90C-%E3%80%91%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/","excerpt":"什么是面向对象？面向对象的三大特性面向对象：对象是指具体的某一个事物，这些事物的抽象就是类，类中包含数据（成员变量）和动作（成员方法）。面向对象的三大特性： 封装：将具体的实现过程和数据封装成一个函数，只能通过接口进行访问，降低耦合性。 继承：子类继承父类的特征和行为，子类有父类的非 private 方法或成员变量，子类可以对父类的方法进行重写，增强了类之间的耦合性，但是当父类中的成员变量、成员函数或者类本身被 final 关键字修饰时，修饰的类不能继承，修饰的成员不能重写或修改。 多态：多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。","text":"什么是面向对象？面向对象的三大特性面向对象：对象是指具体的某一个事物，这些事物的抽象就是类，类中包含数据（成员变量）和动作（成员方法）。面向对象的三大特性： 封装：将具体的实现过程和数据封装成一个函数，只能通过接口进行访问，降低耦合性。 继承：子类继承父类的特征和行为，子类有父类的非 private 方法或成员变量，子类可以对父类的方法进行重写，增强了类之间的耦合性，但是当父类中的成员变量、成员函数或者类本身被 final 关键字修饰时，修饰的类不能继承，修饰的成员不能重写或修改。 多态：多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。 重载、重写、隐藏的区别概念解释： 重载：是指同一可访问区内被声明几个具有不同参数列（参数的类型、个数、顺序）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。123456789class A&#123;public: void fun(int tmp); void fun(float tmp); // 重载 参数类型不同（相对于上一个函数） void fun(int tmp, float tmp1); // 重载 参数个数不同（相对于上一个函数） void fun(float tmp, int tmp1); // 重载 参数顺序不同（相对于上一个函数） int fun(int tmp); // error: &#x27;int A::fun(int)&#x27; cannot be overloaded 错误：注意重载不关心函数返回类型&#125;; 隐藏：是指派生类的函数屏蔽了与其同名的基类函数，主要只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;class Base&#123;public: void fun(int tmp, float tmp1) &#123; cout &lt;&lt; &quot;Base::fun(int tmp, float tmp1)&quot; &lt;&lt; endl; &#125;&#125;;class Derive : public Base&#123;public: void fun(int tmp) &#123; cout &lt;&lt; &quot;Derive::fun(int tmp)&quot; &lt;&lt; endl; &#125; // 隐藏基类中的同名函数&#125;;int main()&#123; Derive ex; ex.fun(1); // Derive::fun(int tmp) ex.fun(1, 0.01); // error: candidate expects 1 argument, 2 provided return 0;&#125; 说明：上述代码中ex.fun(1, 0.01);出现错误，说明派生类中将基类的同名函数隐藏了。若是想调用基类中的同名函数，可以加上类型名指明ex.Base::fun(1, 0.01);，这样就可以调用基类中的同名函数。 重写(覆盖)：是指派生类中存在重新定义的函数。函数名、参数列表、返回值类型都必须同基类中被重写的函数一致，只有函数体不同。派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;class Base&#123;public: virtual void fun(int tmp) &#123; cout &lt;&lt; &quot;Base::fun(int tmp) : &quot; &lt;&lt; tmp &lt;&lt; endl; &#125;&#125;;class Derived : public Base&#123;public: virtual void fun(int tmp) &#123; cout &lt;&lt; &quot;Derived::fun(int tmp) : &quot; &lt;&lt; tmp &lt;&lt; endl; &#125; // 重写基类中的 fun 函数&#125;;int main()&#123; Base *p = new Derived(); p-&gt;fun(3); // Derived::fun(int) : 3 return 0;&#125; 重写和重载的区别： 范围区别：对于类中函数的重载或者重写而言，重载发生在同一个类的内部，重写发生在不同的类之间（子类和父类之间）。 参数区别：重载的函数需要与原函数有相同的函数名、不同的参数列表，不关注函数的返回值类型；重写的函数的函数名、参数列表和返回值类型都需要和原函数相同，父类中被重写的函数需要有 virtual 修饰。 virtual 关键字：重写的函数基类中必须有 virtual关键字的修饰，重载的函数可以有 virtual 关键字的修饰也可以没有。 隐藏和重写，重载的区别： 范围区别：隐藏与重载范围不同，隐藏发生在不同类中。 参数区别：隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定相同；当参数不同时，无论基类中的函数是否被 virtual 修饰，基类函数都是被隐藏，而不是重写。 如何理解 C++ 是面向对象编程?面向对象是首先抽象出各种对象（各种类），把数据和方法都封装在对象中（类），然后各个对象之间发生相互作用。面向过程是将问题分解成若干步骤（动作），每个步骤（动作）用一个函数来实现，在使用的时候，将数据传递给这些函数。网上有一个典型的例子：把大象放入冰箱里面。C++是这么做的：涉及到两个对象：冰箱和大象。三个动作：打开冰箱，放置大象，关闭冰箱。而C是这么做的：首先打开冰箱门，然后把大象放入进去，最后关闭冰箱门。 什么是多态？多态如何实现？多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。在基类的函数前加上 virtual 关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。 实现方法：多态是通过虚函数实现的，虚函数的地址保存在虚函数表中，虚函数表的地址保存在含有虚函数的类的实例对象的内存空间中。 实现过程： 在类中用 virtual 关键字声明的函数叫做虚函数； 存在虚函数的类都有一个虚函数表，当创建一个该类的对象时，该对象有一个指向虚函数表的虚表指针（虚函数表和类对应的，虚表指针是和对象对应）； 当基类指针指向派生类对象，基类指针调用虚函数时，基类指针指向派生类的虚表指针，由于该虚表指针指向派生类虚函数表，通过遍历虚表，寻找相应的虚函数。 举例：123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;class Base&#123;public: virtual void fun() &#123; cout &lt;&lt; &quot;Base::fun()&quot; &lt;&lt; endl; &#125; virtual void fun1() &#123; cout &lt;&lt; &quot;Base::fun1()&quot; &lt;&lt; endl; &#125; virtual void fun2() &#123; cout &lt;&lt; &quot;Base::fun2()&quot; &lt;&lt; endl; &#125;&#125;;class Derive : public Base&#123;public: void fun() &#123; cout &lt;&lt; &quot;Derive::fun()&quot; &lt;&lt; endl; &#125; virtual void D_fun1() &#123; cout &lt;&lt; &quot;Derive::D_fun1()&quot; &lt;&lt; endl; &#125; virtual void D_fun2() &#123; cout &lt;&lt; &quot;Derive::D_fun2()&quot; &lt;&lt; endl; &#125;&#125;;int main()&#123; Base *p = new Derive(); p-&gt;fun(); // Derive::fun() 调用派生类中的虚函数 return 0;&#125;基类的虚函数表如下：派生类的对象虚函数表如下：简单解释：当基类的指针指向派生类的对象时，通过派生类的对象的虚表指针找到虚函数表（派生类的对象虚函数表），进而找到相应的虚函数Derive::f()进行调用。","categories":[{"name":"八股文","slug":"八股文","permalink":"https://wangtianyang.com/categories/%E5%85%AB%E8%82%A1%E6%96%87/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://wangtianyang.com/tags/C/"}]},{"title":"【C++】11&14&17新特性","slug":"【C-】11、14、17新特性","date":"2022-03-04T05:21:41.000Z","updated":"2023-01-06T13:47:27.462Z","comments":true,"path":"2022/03/04/【C-】11、14、17新特性/","link":"","permalink":"https://wangtianyang.com/2022/03/04/%E3%80%90C-%E3%80%9111%E3%80%8114%E3%80%8117%E6%96%B0%E7%89%B9%E6%80%A7/","excerpt":"C++11新特性说明：C++11 的新特性有很多，从面试的角度来讲，如果面试官问到该问题，常以该问题作为引子，对面试者提到的知识点进行深入展开提问。面试者尽可能的列举常用的并且熟悉的特性，尽可能的掌握相关原理，下文只是对相关知识点进行了简单的阐述，有关细节还需要结合相关知识点的相关问题。 下面对常用的做一下总结： auto 类型推导 auto 关键字：自动类型推导，编译器会在 编译期间 通过初始值推导出变量的类型，通过 auto 定义的变量必须有初始值。auto 关键字基本的使用语法如下：1auto var = val1 + val2; // 根据 val1 和 val2 相加的结果推断出 var 的类型， 注意：编译器推导出来的类型和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。 decltype 类型推导 decltype 关键字：decltype 是“declare type”的缩写，译为“声明类型”。和 auto 的功能一样，都用来在编译时期进行自动类型推导。如果希望从表达式中推断出要定义的变量的类型，但是不想用该表达式的值初始化变量，这时就不能再用 auto。decltype 作用是选择并返回操作数的数据类型","text":"C++11新特性说明：C++11 的新特性有很多，从面试的角度来讲，如果面试官问到该问题，常以该问题作为引子，对面试者提到的知识点进行深入展开提问。面试者尽可能的列举常用的并且熟悉的特性，尽可能的掌握相关原理，下文只是对相关知识点进行了简单的阐述，有关细节还需要结合相关知识点的相关问题。 下面对常用的做一下总结： auto 类型推导 auto 关键字：自动类型推导，编译器会在 编译期间 通过初始值推导出变量的类型，通过 auto 定义的变量必须有初始值。auto 关键字基本的使用语法如下：1auto var = val1 + val2; // 根据 val1 和 val2 相加的结果推断出 var 的类型， 注意：编译器推导出来的类型和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。 decltype 类型推导 decltype 关键字：decltype 是“declare type”的缩写，译为“声明类型”。和 auto 的功能一样，都用来在编译时期进行自动类型推导。如果希望从表达式中推断出要定义的变量的类型，但是不想用该表达式的值初始化变量，这时就不能再用 auto。decltype 作用是选择并返回操作数的数据类型 区别：12auto var = val1 + val2; decltype(val1 + val2) var1 = 0; auto 根据 = 右边的初始值 val1 + val2 推导出变量的类型，并将该初始值赋值给变量 var；decltype 根据 val1 + val2 表达式推导出变量的类型，变量的初始值和与表达式的值无关。 auto 要求变量必须初始化，因为它是根据初始化的值推导出变量的类型，而 decltype 不要求，定义变量的时候可初始化也可以不初始化。 lambda 表达式 lambda 表达式，又被称为 lambda 函数或者 lambda 匿名函数lambda匿名函数的定义:1234[capture list] (parameter list) -&gt; return type&#123; function body;&#125;; 其中： capture list：捕获列表，指 lambda 所在函数中定义的局部变量的列表，通常为空。 return type、parameter list、function body：分别表示返回值类型、参数列表、函数体，和普通函数一样。举例：1234567891011121314#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int arr[4] = &#123;4, 2, 3, 1&#125;; //对 a 数组中的元素进行升序排序 sort(arr, arr+4, [=](int x, int y) -&gt; bool&#123; return x &lt; y; &#125; ); for(int n : arr)&#123; cout &lt;&lt; n &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 范围 for 语句语法格式：123for (declaration : expression)&#123; statement&#125; 参数的含义：expression：必须是一个序列，例如用花括号括起来的初始值列表、数组、vector ，string 等，这些类型的共同特点是拥有能返回迭代器的 beign、end 成员。 declaration：此处定义一个变量，序列中的每一个元素都能转化成该变量的类型，常用 auto 类型说明符。 右值引用 右值引用：绑定到右值的引用，用 &amp;&amp; 来获得右值引用，右值引用只能绑定到要销毁的对象。为了和右值引用区分开，常规的引用称为左值引用。举例：1234567891011#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; int var = 42; int &amp;l_var = var; int &amp;&amp;r_var = var; // error: cannot bind rvalue reference of type &#x27;int&amp;&amp;&#x27; to lvalue of type &#x27;int&#x27; 错误：不能将右值引用绑定到左值上 int &amp;&amp;r_var2 = var + 40; // 正确：将 r_var2 绑定到求和结果上 return 0;&#125; 标准库 move() 函数 move() 函数：通过该函数可获得绑定到左值上的右值引用，该函数包括在 utility 头文件中。该知识点会在后续的章节中做详细的说明。 智能指针 相关知识已在上一章中进行了详细的说明，这里不再重复。 delete 函数和 default 函数 delete 函数：= delete 表示该函数不能被调用。 default 函数：= default 表示编译器生成默认的函数，例如：生成默认的构造函数。12345678910111213141516171819#include &lt;iostream&gt;using namespace std;class A&#123;public: A() = default; // 表示使用默认的构造函数 ~A() = default; // 表示使用默认的析构函数 A(const A &amp;) = delete; // 表示类的对象禁止拷贝构造 A &amp;operator=(const A &amp;) = delete; // 表示类的对象禁止拷贝赋值&#125;;int main()&#123; A ex1; A ex2 = ex1; // error: use of deleted function &#x27;A::A(const A&amp;)&#x27; A ex3; ex3 = ex1; // error: use of deleted function &#x27;A&amp; A::operator=(const A&amp;)&#x27; return 0;&#125; C++14新特性C++14的主要特性可以分为三个领域：Lambda函数、constexpr和类型推导。 Lambda函数C++14的泛型Lambda使编写如下语句成为可能：1auto lambda = [](auto x, auto y) &#123;return x + y;&#125;; 而C++11要求Lambda参数使用具体的类型声明，比如：1auto lambda = [](int x, int y) &#123;return x + y;&#125;; 此外，新标准中的std::move函数可用于捕获Lambda表达式中的变量，这是通过移动对象而非复制或引用对象实现的：12std::unique_ptr ptr(new int(10));auto lambda = [value = std::move(ptr)] &#123;return *value;&#125;; constexpr在C++11中，使用constexpr声明的函数可以在编译时执行，生成一个值，用在需要常量表达式的地方，比如作为初始化模板的整形参数。C++11的constexpr函数只能包含一个表达式，C++14放松了这些限制，支持诸如if 和switch等条件语句，支持循环，其中包括基于区间（range）的for 循环。 类型推导C++11仅支持Lambda函数的类型推导，C++14对其加以扩展，支持所有函数的返回类型推导：1auto DeducedReturnTypeFunction(); 因为C++14是强类型语言，有些限制需要考虑： 如果一个函数的实现中有多个返回语句，这些语句一定要推导出同样的类型。 返回类型推导可以用在前向声明中，但是在使用它们之前，翻译单元中必须能够得到函数定义。 返回类型推导可以用在递归函数中，但是递归调用必须以至少一个返回语句作为先导，以便编译器推导出返回类型。C++14带来的另一个类型推导方面的改进是decltype(auto)语法，它支持使用与auto同样的机制计算给定表达式的类型。auto和 decltype在C++11中就已经出现了，但是它们在推导类型时使用了不同的机制，这可能会产生不同的结果。 C++17新特性C++17的入选特性有： 非类型模板参数的 auto模板参数分为两种，一种是类型模板参数，也是我们用得最多的一种：1234template &lt;typename T, typename U&gt;auto add(T t, U u) &#123; return t+u;&#125; 里面的 T 和 U 都是类型模板参数。另一种是非类型模板参数，它可以让不同的字面量成为模板的参数：12345678910template &lt;typename T, int BufSize&gt;class buffer_t &#123;public: T&amp; alloc(); void free(T&amp; item);private: T data[BufSize];&#125; buffer_t&lt;int, 100&gt; buf; // 100 作为模板参数 遗憾的是我们在编写模板的时候就必须明确非类型模板参数的具体类型，C++17 打破了这一限制，让我们能够在非类型模板参数中使用 auto 关键字，从而让编译器推导具体的类型：12345template &lt;auto value&gt; void foo() &#123; return;&#125; foo&lt;10&gt;(); // value 被推导为 int 类型 std::variant&lt;&gt;熟悉 boost 的人应该很早就听说过 variant&lt;&gt; 了。variant&lt;&gt; 可以用于存储和操作不同类型的对象。我们在前面（对标准库的扩充：新增容器）对于迭代 std::tuple 时，简单使用了 boost::variant&lt;&gt;。提供给 variant&lt;&gt; 的类型模板参数可以让一个 variant&lt;&gt; 从而容纳提供的几种类型的变量（在其他语言(例如 Python/JavaScript 等)表现为动态类型）。C++17 正式将 variant&lt;&gt; 纳入标准库，摇身一变成为 std::variant&lt;&gt;，有了它之后，我们可以将前面的代码更改为：1234567891011121314#include &lt;variant&gt;template &lt;size_t n, typename... Args&gt;std::variant&lt;Args...&gt; _tuple_index(size_t i, const std::tuple&lt;Args...&gt;&amp; tpl) &#123; if (i == n) return std::get&lt;n&gt;(tpl); else if (n == sizeof...(Args) - 1) throw std::out_of_range(&quot;越界.&quot;); else return _tuple_index&lt;(n &lt; sizeof...(Args)-1 ? n+1 : 0)&gt;(i, tpl);&#125;template &lt;typename... Args&gt;std::variant&lt;Args...&gt; tuple_index(size_t i, const std::tuple&lt;Args...&gt;&amp; tpl) &#123; return _tuple_index&lt;0&gt;(i, tpl);&#125; 结构化绑定(Structured bindings)结构化绑定提供了类似其他语言中提供的多返回值的功能。到目前为止，我们可以通过 std::tuple 来构造一个元组，囊括多个返回值。但缺陷是显而易见的，我们没有一种简单的方法直接从元组中拿到并定义元组中的元素，尽管我们可以使用 std::tie 对元组进行拆包，但我们依然必须非常清楚这个元组包含多少个对象，各个对象是什么类型。C++17 给出的结构化绑定可以让我们写出这样的代码：1234std::tuple&lt;int,double,std::string&gt; f() &#123; return std::make_tuple(1,2.3,&quot;456&quot;);&#125;auto [x,y,z] = f(); // x,y,z 分别被推导为int,double,std::string 变量声明的强化变量的声明在虽然能够位于任何位置，甚至于 for 语句内能够声明一个临时变量 int，但始终没有办法在 if 和 switch语句中声明一个临时的变量。例如：123456auto p = map_container.try_emplace(key, value);if(!p.second) &#123; //...&#125; else &#123; //...&#125; C++17 消除了这一限制，使得我们可以：12345if (auto p = m.try_emplace(key, value); !p.second) &#123; //...&#125; else &#123; //...&#125;","categories":[{"name":"八股文","slug":"八股文","permalink":"https://wangtianyang.com/categories/%E5%85%AB%E8%82%A1%E6%96%87/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://wangtianyang.com/tags/C/"}]},{"title":"【C++】编译内存","slug":"【C-】编译内存","date":"2022-03-03T09:33:19.000Z","updated":"2023-01-06T13:47:04.633Z","comments":true,"path":"2022/03/03/【C-】编译内存/","link":"","permalink":"https://wangtianyang.com/2022/03/03/%E3%80%90C-%E3%80%91%E7%BC%96%E8%AF%91%E5%86%85%E5%AD%98/","excerpt":"C++程序编译过程编译过程分为四个过程：编译（编译预处理、编译、优化），汇编，链接。 编译预处理：处理以 # 开头的指令； 编译、优化：将源码 .cpp 文件翻译成 .s 汇编代码； 汇编：将汇编代码 .s 翻译成机器指令 .o 文件； 链接：汇编程序生成的目标文件，即 .o 文件，并不会立即执行，因为可能会出现：.cpp 文件中的函数引用了另一个 .cpp 文件中定义的符号或者调用了某个库文件中的函数。那链接的目的就是将这些文件对应的目标文件连接成一个整体，从而生成可执行的程序 .exe 文件。","text":"C++程序编译过程编译过程分为四个过程：编译（编译预处理、编译、优化），汇编，链接。 编译预处理：处理以 # 开头的指令； 编译、优化：将源码 .cpp 文件翻译成 .s 汇编代码； 汇编：将汇编代码 .s 翻译成机器指令 .o 文件； 链接：汇编程序生成的目标文件，即 .o 文件，并不会立即执行，因为可能会出现：.cpp 文件中的函数引用了另一个 .cpp 文件中定义的符号或者调用了某个库文件中的函数。那链接的目的就是将这些文件对应的目标文件连接成一个整体，从而生成可执行的程序 .exe 文件。 链接分为两种： 静态链接：代码从其所在的静态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中。 动态链接：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间。 二者的优缺点： 静态链接：浪费空间，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（更新困难）；优点就是执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容。 动态链接：节省内存、更新方便，但是动态链接是在程序运行时，每次执行都需要链接，相比静态链接会有一定的性能损失。 C++ 内存管理C++ 内存分区：栈、堆、全局/静态存储区、常量存储区、代码区。 栈：存放函数的局部变量、函数参数、返回地址等，由编译器自动分配和释放。 堆：动态申请的内存空间，就是由 malloc 分配的内存块，由程序员控制它的分配和释放，如果程序执行结束还没有释放，操作系统会自动回收。 全局区/静态存储区（.bss 段和 .data 段）：存放全局变量和静态变量，程序运行结束操作系统自动释放，在 C 语言中，未初始化的放在 .bss 段中，初始化的放在 .data 段中，C++ 中不再区分了。 常量存储区（.data 段）：存放的是常量，不允许修改，程序运行结束自动释放。 代码区（.text 段）：存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里。 说明： 从操作系统的本身来讲，以上存储区在内存中的分布是如下形式(从低地址到高地址)：.text 段 —&gt; .data 段 —&gt; .bss 段 —&gt; 堆 —&gt; unused —&gt; 栈 —&gt; env 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;/*说明：C++ 中不再区分初始化和未初始化的全局变量、静态变量的存储区，如果非要区分下述程序标注在了括号中*/int g_var = 0; // g_var 在全局区（.data 段）char *gp_var; // gp_var 在全局区（.bss 段）int main()&#123; int var; // var 在栈区 char *p_var; // p_var 在栈区 char arr[] = &quot;abc&quot;; // arr 为数组变量，存储在栈区；&quot;abc&quot;为字符串常量，存储在常量区 char *p_var1 = &quot;123456&quot;; // p_var1 在栈区；&quot;123456&quot;为字符串常量，存储在常量区 static int s_var = 0; // s_var 为静态变量，存在静态存储区（.data 段） p_var = (char *)malloc(10); // 分配得来的 10 个字节的区域在堆区 free(p_var); return 0;&#125; 栈和堆的区别 申请方式：栈是系统自动分配，堆是程序员主动申请。 申请后系统响应：分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；申请堆空间，堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上。 栈在内存中是连续的一块空间（向低地址扩展）最大容量是系统预定好的，堆在内存中的空间（向高地址扩展）是不连续的。 申请效率：栈是有系统自动分配，申请效率高，但程序员无法控制；堆是由程序员主动申请，效率低，使用起来方便但是容易产生碎片。 存放的内容：栈中存放的是局部变量，函数的参数；堆中存放的内容由程序员控制。 变量的区别全局变量、局部变量、静态全局变量、静态局部变量的区别 C++ 变量根据定义的位置的不同的生命周期，具有不同的作用域，作用域可分为 6 种：全局作用域，局部作用域，语句作用域，类作用域，命名空间作用域和文件作用域。 从作用域看： 全局变量：具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用 extern 关键字再次声明这个全局变量。 静态全局变量：具有文件作用域。它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被 static 关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。 局部变量：具有局部作用域。它是自动对象（auto），在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。 静态局部变量：具有局部作用域。它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。 从分配内存空间看： 静态存储区：全局变量，静态局部变量，静态全局变量。 栈：局部变量。 说明： 静态变量和栈变量（存储在栈中的变量）、堆变量（存储在堆中的变量）的区别：静态变量会被放在程序的静态数据存储区（.data 段）中（静态变量会自动初始化），这样可以在下一次调用的时候还可以保持原来的赋值。而栈变量或堆变量不能保证在下一次调用的时候依然保持原来的值。 静态变量和全局变量的区别：静态变量用 static 告知编译器，自己仅仅在变量的作用范围内可见。 全局变量定义在头文件中有什么问题？如果在头文件中定义全局变量，当该头文件被多个文件include时，该头文件中的全局变量就会被定义多次，导致重复定义，因此不能再头文件中定义全局变量。 如何限制类的对象只能在堆上创建？如何限制对象只能在栈上创建？说明：C++ 中的类的对象的建立分为两种：静态建立、动态建立。 静态建立：由编译器为对象在栈空间上分配内存，直接调用类的构造函数创建对象。例如：A a; 动态建立：使用 new 关键字在堆空间上创建对象，底层首先调用 operator new() 函数，在堆空间上寻找合适的内存并分配；然后，调用类的构造函数创建对象。例如：A *p = new A(); 限制对象只能建立在堆上： 最直观的思想：避免直接调用类的构造函数，因为对象静态建立时，会调用类的构造函数创建对象。但是直接将类的构造函数设为私有并不可行，因为当构造函数设置为私有后，不能在类的外部调用构造函数来构造对象，只能用 new 来建立对象。但是由于 new 创建对象时，底层也会调用类的构造函数，将构造函数设置为私有后，那就无法在类的外部使用 new 创建对象了。因此，这种方法不可行。 解决方法 1： 将析构函数设置为私有。原因：静态对象建立在栈上，是由编译器分配和释放内存空间，编译器为对象分配内存空间时，会对类的非静态函数进行检查，即编译器会检查析构函数的访问性。当析构函数设为私有时，编译器创建的对象就无法通过访问析构函数来释放对象的内存空间，因此，编译器不会在栈上为对象分配内存。 1234567891011121314class A&#123;public: A() &#123;&#125; void destory() &#123; delete this; &#125;private: ~A() &#123; &#125;&#125;; 该方法存在的问题： 用 new 创建的对象，通常会使用 delete 释放该对象的内存空间，但此时类的外部无法调用析构函数，因此类内必须定义一个 destory() 函数，用来释放 new 创建的对象。 无法解决继承问题，因为如果这个类作为基类，析构函数要设置成 virtual，然后在派生类中重写该函数，来实现多态。但此时，析构函数是私有的，派生类中无法访问。 解决方法 2： 构造函数设置为 protected，并提供一个 public 的静态函数来完成构造，而不是在类的外部使用 new 构造；将析构函数设置为 protected。原因：类似于单例模式，也保证了在派生类中能够访问析构函数。通过调用 create() 函数在堆上创建对象。 12345678910111213141516class A&#123;protected: A() &#123;&#125; ~A() &#123;&#125;public: static A *create() &#123; return new A(); &#125; void destory() &#123; delete this; &#125;&#125;; 限制对象只能建立在栈上： 解决方法：将 operator new() 设置为私有。原因：当对象建立在堆上时，是采用 new 的方式进行建立，其底层会调用 operator new() 函数，因此只要对该函数加以限制，就能够防止对象建立在堆上。 123456789class A&#123;private: void *operator new(size_t t) &#123;&#125; // 注意函数的第一个参数和返回值都是固定的 void operator delete(void *ptr) &#123;&#125; // 重载了 new 就需要重载 deletepublic: A() &#123;&#125; ~A() &#123;&#125;&#125;; 什么是内存对齐？内存对齐的原则？为什么要进行内存对齐，有什么优点？内存对齐：编译器将程序中的每个“数据单元”安排在字的整数倍的地址指向的内存之中 内存对齐的原则： 结构体变量的首地址能够被其最宽基本类型成员大小与对齐基数中的较小者所整除； 结构体每个成员相对于结构体首地址的偏移量 （offset） 都是该成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在成员之间加上填充字节 （internal padding）； 结构体的总大小为结构体最宽基本类型成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在最末一个成员之后加上填充字节 （trailing padding）。 1234567891011121314151617181920212223242526272829303132/*说明：程序是在 64 位编译器下测试的*/#include &lt;iostream&gt;using namespace std;struct A&#123; short var; // 2 字节 int var1; // 8 字节 （内存对齐原则：填充 2 个字节） 2 (short) + 2 (填充) + 4 (int)= 8 long var2; // 12 字节 8 + 4 (long) = 12 char var3; // 16 字节 （内存对齐原则：填充 3 个字节）12 + 1 (char) + 3 (填充) = 16 string s; // 48 字节 16 + 32 (string) = 48&#125;;int main()&#123; short var; int var1; long var2; char var3; string s; A ex1; cout &lt;&lt; sizeof(var) &lt;&lt; endl; // 2 short cout &lt;&lt; sizeof(var1) &lt;&lt; endl; // 4 int cout &lt;&lt; sizeof(var2) &lt;&lt; endl; // 4 long cout &lt;&lt; sizeof(var3) &lt;&lt; endl; // 1 char cout &lt;&lt; sizeof(s) &lt;&lt; endl; // 32 string cout &lt;&lt; sizeof(ex1) &lt;&lt; endl; // 48 struct return 0;&#125; 进行内存对齐的原因：（主要是硬件设备方面的问题） 某些硬件设备只能存取对齐数据，存取非对齐的数据可能会引发异常； 某些硬件设备不能保证在存取非对齐数据的时候的操作是原子操作； 相比于存取对齐的数据，存取非对齐的数据需要花费更多的时间； 某些处理器虽然支持非对齐数据的访问，但会引发对齐陷阱（alignment trap）； 某些硬件设备只支持简单数据指令非对齐存取，不支持复杂数据指令的非对齐存取。 内存对齐的优点： 便于在不同的平台之间进行移植，因为有些硬件平台不能够支持任意地址的数据访问，只能在某些地址处取某些特定的数据，否则会抛出异常； 提高内存的访问效率，因为 CPU 在读取内存时，是一块一块的读取。 类的大小类的大小是指类的实例化对象的大小，用 sizeof 对类型名操作时，结果是该类型的对象的大小。计算原则： 遵循结构体的对齐原则。 与普通成员变量有关，与成员函数和静态成员无关。即普通成员函数，静态成员函数，静态数据成员，静态常量数据成员均对类的大小无影响。因为静态数据成员被类的对象共享，并不属于哪个具体的对象。 虚函数对类的大小有影响，是因为虚函数表指针的影响。 虚继承对类的大小有影响，是因为虚基表指针带来的影响。 空类的大小是一个特殊情况，空类的大小为 1，当用 new 来创建一个空类的对象时，为了保证不同对象的地址不同，空类也占用存储空间。 123456789101112131415161718192021222324252627282930/*说明：程序是在 64 位编译器下测试的*/#include &lt;iostream&gt;using namespace std;class A&#123;private: static int s_var; // 不影响类的大小 const int c_var; // 4 字节 int var; // 8 字节 4 + 4 (int) = 8 char var1; // 12 字节 8 + 1 (char) + 3 (填充) = 12public: A(int temp) : c_var(temp) &#123;&#125; // 不影响类的大小 ~A() &#123;&#125; // 不影响类的大小&#125;;class B&#123;&#125;;int main()&#123; A ex1(4); B ex2; cout &lt;&lt; sizeof(ex1) &lt;&lt; endl; // 12 字节 cout &lt;&lt; sizeof(ex2) &lt;&lt; endl; // 1 字节 return 0;&#125; 带有虚函数的情况：（注意：虚函数的个数并不影响所占内存的大小，因为类对象的内存中只保存了指向虚函数表的指针。）1234567891011121314151617181920212223242526272829303132/*说明：程序是在 64 位编译器下测试的*/#include &lt;iostream&gt;using namespace std;class A&#123;private: static int s_var; // 不影响类的大小 const int c_var; // 4 字节 int var; // 8 字节 4 + 4 (int) = 8 char var1; // 12 字节 8 + 1 (char) + 3 (填充) = 12public: A(int temp) : c_var(temp) &#123;&#125; // 不影响类的大小 ~A() &#123;&#125; // 不影响类的大小 virtual void f() &#123; cout &lt;&lt; &quot;A::f&quot; &lt;&lt; endl; &#125; virtual void g() &#123; cout &lt;&lt; &quot;A::g&quot; &lt;&lt; endl; &#125; virtual void h() &#123; cout &lt;&lt; &quot;A::h&quot; &lt;&lt; endl; &#125; // 24 字节 12 + 4 (填充) + 8 (指向虚函数的指针) = 24&#125;;int main()&#123; A ex1(4); A *p; cout &lt;&lt; sizeof(p) &lt;&lt; endl; // 8 字节 注意：指针所占的空间和指针指向的数据类型无关 cout &lt;&lt; sizeof(ex1) &lt;&lt; endl; // 24 字节 return 0;&#125; 什么是内存泄露内存泄漏：由于疏忽或错误导致的程序未能释放已经不再使用的内存。 进一步解释： 并非指内存从物理上消失，而是指程序在运行过程中，由于疏忽或错误而失去了对该内存的控制，从而造成了内存的浪费。 常指堆内存泄漏，因为堆是动态分配的，而且是用户来控制的，如果使用不当，会产生内存泄漏。 使用 malloc、calloc、realloc、new 等分配内存时，使用完后要调用相应的 free 或 delete 释放内存，否则这块内存就会造成内存泄漏。 指针重新赋值 123char *p = (char *)malloc(10);char *p1 = (char *)malloc(10);p = np; 开始时，指针 p 和 p 1 分别指向一块内存空间，但指针 p 被重新赋值，导致 p 初始时指向的那块内存空间无法找到，从而发生了内存泄漏。 怎么防止内存泄漏？内存泄漏检测工具的原理？智能指针 智能指针是 C++ 中已经对内存泄漏封装好了一个工具，可以直接拿来使用 智能指针是为了解决动态内存分配时带来的内存泄漏以及多次释放同一块内存空间而提出的。C++11 中封装在了 头文件中。 C++11 中智能指针有哪几种？ 共享指针（shared_ptr）：资源可以被多个指针共享，使用计数机制表明资源被几个指针共享。通过 use_count() 查看资源的所有者的个数，可以通过 unique_ptr、weak_ptr 来构造，调用 release() 释放资源的所有权，计数减一，当计数减为 0 时，会自动释放内存空间，从而避免了内存泄漏。 独占指针（unique_ptr）：独享所有权的智能指针，资源只能被一个指针占有，该指针不能拷贝构造和赋值。但可以进行移动构造和移动赋值构造（调用 move() 函数），即一个 unique_ptr 对象赋值给另一个 unique_ptr 对象，可以通过该方法进行赋值。 弱指针（weak_ptr）：指向 share_ptr 指向的对象，能够解决由shared_ptr带来的循环引用问题。 shared_ptr和unique_ptr的区别shared_ptr允许多个指针指向同一个对象，而unique_ptr 独占所指向的对象。与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr被销毁时，它所指向的对象也被销毁。 shared_ptr类12shared_ptr&lt;string&gt; p1; //可以指向stringshared_ptr&lt;list&lt;int&gt;&gt; p2; //可以指向int的list make_shared函数最安全的分配和使用动态内存的方法是调用一个名为make_shared的标准库函数。此函数在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr。当要用make_shared时，必须指定想要创建的对象的类型，如下：123456//指向一个值为42的int的shared_ptrshared_ptr&lt;int&gt; p3 = make_shared&lt;int&gt;(42);//p4指向一个值为&quot;9999999999&quot;的stringshared_ptr&lt;string&gt; p4 = make_shared&lt;string&gt;(10,&#x27;9&#x27;);//p5指向一个值初始化的int,值为0shared_ptr&lt;int&gt; p5 = make_shared&lt;int&gt;();也可以使用auto定义一个对象来保存make_shared的结果，更为简单：12//p6指向一个动态分配的空vector&lt;string&gt;auto p6 = make_shared&lt;vector&lt;string&gt;&gt;();当进行拷贝或赋值操作时，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象：12auto p = make_shared&lt;int&gt;(42); //p指向的对象只有p一个引用者auto q(p); //p和q指向相同对象，此对象有两个引用者 我们可以认为每个shared_ptr都有一个关联的计数器，通常称其为引用计数。无论何时我们拷贝一个shared_ptr，计数器都会递增。 unique_ptr类与shared_ptr不同，没有类似make_shared的标准库函数返回一个unique_ptr。所以初始化unique_ptr必须采用直接初始化形式，如下：12unique_ptr&lt;double&gt; p1; //可以指向一个double的unique_ptrunique_ptr&lt;int&gt; p2(new int(42)); //p2指向一个值为42的int shared_ptr指针的实现原理计数原理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;#include &lt;memory&gt;template &lt;typename T&gt;class SmartPtr&#123;private : T *_ptr; size_t *_count;public: SmartPtr(T *ptr = nullptr) : _ptr(ptr) &#123; if (_ptr) &#123; _count = new size_t(1); &#125; else &#123; _count = new size_t(0); &#125; &#125; ~SmartPtr() &#123; (*this-&gt;_count)--; if (*this-&gt;_count == 0) &#123; delete this-&gt;_ptr; delete this-&gt;_count; &#125; &#125; SmartPtr(const SmartPtr &amp;ptr) // 拷贝构造：计数 +1 &#123; if (this != &amp;ptr) &#123; this-&gt;_ptr = ptr._ptr; this-&gt;_count = ptr._count; (*this-&gt;_count)++; &#125; &#125; SmartPtr &amp;operator=(const SmartPtr &amp;ptr) // 赋值运算符重载 &#123; if (this-&gt;_ptr == ptr._ptr) &#123; return *this; &#125; if (this-&gt;_ptr) // 将当前的 ptr 指向的原来的空间的计数 -1 &#123; (*this-&gt;_count)--; if (this-&gt;_count == 0) &#123; delete this-&gt;_ptr; delete this-&gt;_count; &#125; &#125; this-&gt;_ptr = ptr._ptr; this-&gt;_count = ptr._count; (*this-&gt;_count)++; // 此时 ptr 指向了新赋值的空间，该空间的计数 +1 return *this; &#125; T &amp;operator*() &#123; assert(this-&gt;_ptr == nullptr); return *(this-&gt;_ptr); &#125; T *operator-&gt;() &#123; assert(this-&gt;_ptr == nullptr); return this-&gt;_ptr; &#125; size_t use_count() &#123; return *this-&gt;count; &#125;&#125;; 一个独占指针（unique_ptr）怎么赋值给另一个独占指针（unique_ptr）对象？借助 std::move() 可以实现将一个 unique_ptr 对象赋值给另一个 unique_ptr 对象，其目的是实现所有权的转移。 123// A 作为一个类 std::unique_ptr&lt;A&gt; ptr1(new A());std::unique_ptr&lt;A&gt; ptr2 = std::move(ptr1); 使用智能指针会出现什么问题？怎么解决？智能指针可能出现的问题：循环引用。在如下例子中定义了两个类 Parent、Child，在两个类中分别定义另一个类的对象的共享指针，由于在程序结束后，两个指针相互指向对方的内存空间，导致内存无法释放。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;class Child;class Parent;class Parent &#123;private: shared_ptr&lt;Child&gt; ChildPtr;public: void setChild(shared_ptr&lt;Child&gt; child) &#123; this-&gt;ChildPtr = child; &#125; void doSomething() &#123; if (this-&gt;ChildPtr.use_count()) &#123; &#125; &#125; ~Parent() &#123; &#125;&#125;;class Child &#123;private: shared_ptr&lt;Parent&gt; ParentPtr;public: void setPartent(shared_ptr&lt;Parent&gt; parent) &#123; this-&gt;ParentPtr = parent; &#125; void doSomething() &#123; if (this-&gt;ParentPtr.use_count()) &#123; &#125; &#125; ~Child() &#123; &#125;&#125;;int main() &#123; weak_ptr&lt;Parent&gt; wpp; weak_ptr&lt;Child&gt; wpc; &#123; shared_ptr&lt;Parent&gt; p(new Parent); shared_ptr&lt;Child&gt; c(new Child); p-&gt;setChild(c); c-&gt;setPartent(p); wpp = p; wpc = c; cout &lt;&lt; p.use_count() &lt;&lt; endl; // 2 cout &lt;&lt; c.use_count() &lt;&lt; endl; // 2 &#125; cout &lt;&lt; wpp.use_count() &lt;&lt; endl; // 1 cout &lt;&lt; wpc.use_count() &lt;&lt; endl; // 1 return 0;&#125; 循环引用的解决方法：weak_ptr循环引用：该被调用的析构函数没有被调用，从而出现了内存泄漏。 weak_ptr 对被 shared_ptr 管理的对象存在 非拥有性（弱）引用，在访问所引用的对象前必须先转化为 shared_ptr； weak_ptr 用来打断 shared_ptr 所管理对象的循环引用问题，若这种环被孤立（没有指向环中的外部共享指针），shared_ptr 引用计数无法抵达 0，内存被泄露；令环中的指针之一为弱指针可以避免该情况； weak_ptr 用来表达临时所有权的概念，当某个对象只有存在时才需要被访问，而且随时可能被他人删除，可以用 weak_ptr 跟踪该对象；需要获得所有权时将其转化为 shared_ptr，此时如果原来的 shared_ptr 被销毁，则该对象的生命期被延长至这个临时的 shared_ptr 同样被销毁。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;memory&gt;using namespace std;class Child;class Parent;class Parent &#123;private: //shared_ptr&lt;Child&gt; ChildPtr; weak_ptr&lt;Child&gt; ChildPtr;public: void setChild(shared_ptr&lt;Child&gt; child) &#123; this-&gt;ChildPtr = child; &#125; void doSomething() &#123; //new shared_ptr if (this-&gt;ChildPtr.lock()) &#123; &#125; &#125; ~Parent() &#123; &#125;&#125;;class Child &#123;private: shared_ptr&lt;Parent&gt; ParentPtr;public: void setPartent(shared_ptr&lt;Parent&gt; parent) &#123; this-&gt;ParentPtr = parent; &#125; void doSomething() &#123; if (this-&gt;ParentPtr.use_count()) &#123; &#125; &#125; ~Child() &#123; &#125;&#125;;int main() &#123; weak_ptr&lt;Parent&gt; wpp; weak_ptr&lt;Child&gt; wpc; &#123; shared_ptr&lt;Parent&gt; p(new Parent); shared_ptr&lt;Child&gt; c(new Child); p-&gt;setChild(c); c-&gt;setPartent(p); wpp = p; wpc = c; cout &lt;&lt; p.use_count() &lt;&lt; endl; // 2 cout &lt;&lt; c.use_count() &lt;&lt; endl; // 1 &#125; cout &lt;&lt; wpp.use_count() &lt;&lt; endl; // 0 cout &lt;&lt; wpc.use_count() &lt;&lt; endl; // 0 return 0;&#125;","categories":[{"name":"八股文","slug":"八股文","permalink":"https://wangtianyang.com/categories/%E5%85%AB%E8%82%A1%E6%96%87/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://wangtianyang.com/tags/C/"}]},{"title":"【C++】String转数组（split方法构建）","slug":"【C-】String转数组（split方法构建）","date":"2022-03-03T04:30:52.000Z","updated":"2023-01-06T13:44:28.180Z","comments":true,"path":"2022/03/03/【C-】String转数组（split方法构建）/","link":"","permalink":"https://wangtianyang.com/2022/03/03/%E3%80%90C-%E3%80%91String%E8%BD%AC%E6%95%B0%E7%BB%84%EF%BC%88split%E6%96%B9%E6%B3%95%E6%9E%84%E5%BB%BA%EF%BC%89/","excerpt":"思路是istringstream配合getline使用。 istringstream是C++的输入输出控制类，它的构造函数原型如下：1istringstream::istringstream(string str);它的作用是从string对象str中读取字符。 getline是C++标准库函数，它的原型如下：1istream&amp; getline (istream &amp;is, string &amp;str, char delim);其中，istream &amp;is 表示一个输入流，譬如cin，或者istringstream；string &amp;str表示把从输入流读入的字符串存放在这个字符串中（可以自己随便命名，str什么的都可以）；char delim表示遇到这个字符停止读入，在不设置的情况下系统默认该字符为’\\n’，也就是回车换行符（遇到回车停止读入）。","text":"思路是istringstream配合getline使用。 istringstream是C++的输入输出控制类，它的构造函数原型如下：1istringstream::istringstream(string str);它的作用是从string对象str中读取字符。 getline是C++标准库函数，它的原型如下：1istream&amp; getline (istream &amp;is, string &amp;str, char delim);其中，istream &amp;is 表示一个输入流，譬如cin，或者istringstream；string &amp;str表示把从输入流读入的字符串存放在这个字符串中（可以自己随便命名，str什么的都可以）；char delim表示遇到这个字符停止读入，在不设置的情况下系统默认该字符为’\\n’，也就是回车换行符（遇到回车停止读入）。 split函数代码1234567891011121314151617#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;sstream&gt;using namespace std;vector&lt;string&gt; split(const string&amp; s, char delim) &#123; istringstream iss(s); vector&lt;string&gt; strs; string temp; while (getline(iss, temp, delim)) &#123; if (temp == &quot;&quot;) continue; // 排除空字符串 strs.push_back(temp); &#125; return strs;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://wangtianyang.com/tags/C/"}]},{"title":"【LeetCode刷题笔记】222.完全二叉树的节点个数","slug":"【LeetCode刷题笔记】222-完全二叉树的节点个数","date":"2022-03-03T03:17:59.000Z","updated":"2023-01-06T13:43:34.729Z","comments":true,"path":"2022/03/03/【LeetCode刷题笔记】222-完全二叉树的节点个数/","link":"","permalink":"https://wangtianyang.com/2022/03/03/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/","excerpt":"题目222.完全二叉树的节点个数 给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。 完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。","text":"题目222.完全二叉树的节点个数 给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。 完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。 题解直接暴力dfs不难，但这肯定不是本题的考核目的，我们需要运用完全二叉树的特性来解此题。 首先，了解一下什么是满二叉树：满二叉树的每层都是满的，假设它的高（层数）为$h$，那么它的节点数为$2^h-1$。 而对于完全二叉树来说，最底层最少只有一个节点，最大为满二叉树，所以节点树在$2^{h-1}~2^h-1$之间。 我们还需要用到完全二叉树隐藏特性！！！完全二叉树的左右子树中至少有一颗是满二叉树！ 因此，我们可以这样考虑问题，首先算出左右子树的层数，如果相等，那么直接返回$2^h-1$，否则，递归（每次递归必有一颗满二叉树）。 代码12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: int countNodes(TreeNode* root) &#123; TreeNode* l = root, * r = root; int lc = 0, rc = 0; while (l != nullptr) &#123; ++lc; l = l-&gt;left; &#125; while (r != nullptr) &#123; ++rc; r = r-&gt;right; &#125; if (lc == rc) return pow(2, lc) -1; return 1 + countNodes(root-&gt;left) + countNodes(root-&gt;right); &#125;&#125;;","categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://wangtianyang.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://wangtianyang.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【LeetCode刷题笔记】460.LFU缓存","slug":"【LeetCode刷题笔记】460-LFU缓存","date":"2022-03-02T07:08:43.000Z","updated":"2023-01-06T13:43:05.985Z","comments":true,"path":"2022/03/02/【LeetCode刷题笔记】460-LFU缓存/","link":"","permalink":"https://wangtianyang.com/2022/03/02/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91460-LFU%E7%BC%93%E5%AD%98/","excerpt":"题目460.LFU缓存 请你为 最不经常使用（LFU）缓存算法设计并实现数据结构。 实现 LFUCache 类： LFUCache(int capacity) - 用数据结构的容量 capacity 初始化对象int get(int key) - 如果键 key 存在于缓存中，则获取键的值，否则返回 -1 。void put(int key, int value) - 如果键 key 已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量 capacity 时，则应该在插入新项之前，移除最不经常使用的项。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 最近最久未使用 的键。为了确定最不常使用的键，可以为缓存中的每个键维护一个 使用计数器 。使用计数最小的键是最久未使用的键。 当一个键首次插入到缓存中时，它的使用计数器被设置为 1 (由于 put 操作)。对缓存中的键执行 get 或 put 操作，使用计数器的值将会递增。 函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。 示例：1234567891011121314151617181920212223242526输入：[&quot;LFUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;][[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]输出：[null, null, null, 1, null, -1, 3, null, -1, 3, 4]解释：// cnt(x) = 键 x 的使用计数// cache=[] 将显示最后一次使用的顺序（最左边的元素是最近的）LFUCache lfu = new LFUCache(2);lfu.put(1, 1); // cache=[1,_], cnt(1)=1lfu.put(2, 2); // cache=[2,1], cnt(2)=1, cnt(1)=1lfu.get(1); // 返回 1 // cache=[1,2], cnt(2)=1, cnt(1)=2lfu.put(3, 3); // 去除键 2 ，因为 cnt(2)=1 ，使用计数最小 // cache=[3,1], cnt(3)=1, cnt(1)=2lfu.get(2); // 返回 -1（未找到）lfu.get(3); // 返回 3 // cache=[3,1], cnt(3)=2, cnt(1)=2lfu.put(4, 4); // 去除键 1 ，1 和 3 的 cnt 相同，但 1 最久未使用 // cache=[4,3], cnt(4)=1, cnt(3)=2lfu.get(1); // 返回 -1（未找到）lfu.get(3); // 返回 3 // cache=[3,4], cnt(4)=1, cnt(3)=3lfu.get(4); // 返回 4 // cache=[3,4], cnt(4)=2, cnt(3)=3 提示： 0 &lt;= capacity &lt;= 104 0 &lt;= key &lt;= 105 0 &lt;= value &lt;= 109 最多调用 2 * 105 次 get 和 put 方法","text":"题目460.LFU缓存 请你为 最不经常使用（LFU）缓存算法设计并实现数据结构。 实现 LFUCache 类： LFUCache(int capacity) - 用数据结构的容量 capacity 初始化对象int get(int key) - 如果键 key 存在于缓存中，则获取键的值，否则返回 -1 。void put(int key, int value) - 如果键 key 已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量 capacity 时，则应该在插入新项之前，移除最不经常使用的项。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 最近最久未使用 的键。为了确定最不常使用的键，可以为缓存中的每个键维护一个 使用计数器 。使用计数最小的键是最久未使用的键。 当一个键首次插入到缓存中时，它的使用计数器被设置为 1 (由于 put 操作)。对缓存中的键执行 get 或 put 操作，使用计数器的值将会递增。 函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。 示例：1234567891011121314151617181920212223242526输入：[&quot;LFUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;][[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]输出：[null, null, null, 1, null, -1, 3, null, -1, 3, 4]解释：// cnt(x) = 键 x 的使用计数// cache=[] 将显示最后一次使用的顺序（最左边的元素是最近的）LFUCache lfu = new LFUCache(2);lfu.put(1, 1); // cache=[1,_], cnt(1)=1lfu.put(2, 2); // cache=[2,1], cnt(2)=1, cnt(1)=1lfu.get(1); // 返回 1 // cache=[1,2], cnt(2)=1, cnt(1)=2lfu.put(3, 3); // 去除键 2 ，因为 cnt(2)=1 ，使用计数最小 // cache=[3,1], cnt(3)=1, cnt(1)=2lfu.get(2); // 返回 -1（未找到）lfu.get(3); // 返回 3 // cache=[3,1], cnt(3)=2, cnt(1)=2lfu.put(4, 4); // 去除键 1 ，1 和 3 的 cnt 相同，但 1 最久未使用 // cache=[4,3], cnt(4)=1, cnt(3)=2lfu.get(1); // 返回 -1（未找到）lfu.get(3); // 返回 3 // cache=[3,4], cnt(4)=1, cnt(3)=3lfu.get(4); // 返回 4 // cache=[3,4], cnt(4)=2, cnt(3)=3 提示： 0 &lt;= capacity &lt;= 104 0 &lt;= key &lt;= 105 0 &lt;= value &lt;= 109 最多调用 2 * 105 次 get 和 put 方法 题解（这道题太难了，不要试图自己做，巨浪费时间，以下复制力扣官方题解）双哈希表法我们定义两个哈希表，第一个 freq_table 以频率 freq 为索引，每个索引存放一个双向链表，这个链表里存放所有使用频率为 freq 的缓存，缓存里存放三个信息，分别为键 key，值 value，以及使用频率 freq。第二个 key_table 以键值 key 为索引，每个索引存放对应缓存在 freq_table 中链表里的内存地址，这样我们就能利用两个哈希表来使得两个操作的时间复杂度均为 O(1)O(1)。同时需要记录一个当前缓存最少使用的频率 minFreq，这是为了删除操作服务的。 对于 get(key) 操作，我们能通过索引 key 在 key_table 中找到缓存在 freq_table 中的链表的内存地址，如果不存在直接返回 -1，否则我们能获取到对应缓存的相关信息，这样我们就能知道缓存的键值还有使用频率，直接返回 key 对应的值即可。 但是我们注意到 get 操作后这个缓存的使用频率加一了，所以我们需要更新缓存在哈希表 freq_table 中的位置。已知这个缓存的键 key，值 value，以及使用频率 freq，那么该缓存应该存放到 freq_table 中 freq + 1 索引下的链表中。所以我们在当前链表中 O(1)O(1) 删除该缓存对应的节点，根据情况更新 minFreq 值，然后将其O(1)O(1) 插入到 freq + 1 索引下的链表头完成更新。这其中的操作复杂度均为 O(1)O(1)。你可能会疑惑更新的时候为什么是插入到链表头，这其实是为了保证缓存在当前链表中从链表头到链表尾的插入时间是有序的，为下面的删除操作服务。 对于 put(key, value) 操作，我们先通过索引 key在 key_table 中查看是否有对应的缓存，如果有的话，其实操作等价于 get(key) 操作，唯一的区别就是我们需要将当前的缓存里的值更新为 value。如果没有的话，相当于是新加入的缓存，如果缓存已经到达容量，需要先删除最近最少使用的缓存，再进行插入。 先考虑插入，由于是新插入的，所以缓存的使用频率一定是 1，所以我们将缓存的信息插入到 freq_table 中 1 索引下的列表头即可，同时更新 key_table[key] 的信息，以及更新 minFreq = 1。 那么剩下的就是删除操作了，由于我们实时维护了 minFreq，所以我们能够知道 freq_table 里目前最少使用频率的索引，同时因为我们保证了链表中从链表头到链表尾的插入时间是有序的，所以 freq_table[minFreq] 的链表中链表尾的节点即为使用频率最小且插入时间最早的节点，我们删除它同时根据情况更新 minFreq ，整个时间复杂度均为 O(1)O(1)。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 缓存的节点信息struct Node &#123; int key, val, freq; Node(int _key,int _val,int _freq): key(_key), val(_val), freq(_freq)&#123;&#125;&#125;;class LFUCache &#123; int minfreq, capacity; unordered_map&lt;int, list&lt;Node&gt;::iterator&gt; key_table; unordered_map&lt;int, list&lt;Node&gt;&gt; freq_table;public: LFUCache(int _capacity) &#123; minfreq = 0; capacity = _capacity; key_table.clear(); freq_table.clear(); &#125; int get(int key) &#123; if (capacity == 0) return -1; auto it = key_table.find(key); if (it == key_table.end()) return -1; list&lt;Node&gt;::iterator node = it -&gt; second; int val = node -&gt; val, freq = node -&gt; freq; freq_table[freq].erase(node); // 如果当前链表为空，我们需要在哈希表中删除，且更新minFreq if (freq_table[freq].size() == 0) &#123; freq_table.erase(freq); if (minfreq == freq) minfreq += 1; &#125; // 插入到 freq + 1 中 freq_table[freq + 1].push_front(Node(key, val, freq + 1)); key_table[key] = freq_table[freq + 1].begin(); return val; &#125; void put(int key, int value) &#123; if (capacity == 0) return; auto it = key_table.find(key); if (it == key_table.end()) &#123; // 缓存已满，需要进行删除操作 if (key_table.size() == capacity) &#123; // 通过 minFreq 拿到 freq_table[minFreq] 链表的末尾节点 auto it2 = freq_table[minfreq].back(); key_table.erase(it2.key); freq_table[minfreq].pop_back(); if (freq_table[minfreq].size() == 0) &#123; freq_table.erase(minfreq); &#125; &#125; freq_table[1].push_front(Node(key, value, 1)); key_table[key] = freq_table[1].begin(); minfreq = 1; &#125; else &#123; // 与 get 操作基本一致，除了需要更新缓存的值 list&lt;Node&gt;::iterator node = it -&gt; second; int freq = node -&gt; freq; freq_table[freq].erase(node); if (freq_table[freq].size() == 0) &#123; freq_table.erase(freq); if (minfreq == freq) minfreq += 1; &#125; freq_table[freq + 1].push_front(Node(key, value, freq + 1)); key_table[key] = freq_table[freq + 1].begin(); &#125; &#125;&#125;;","categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://wangtianyang.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://wangtianyang.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【LeetCode刷题笔记】494.目标和","slug":"【LeetCode刷题笔记】494-目标和","date":"2022-03-02T03:13:03.000Z","updated":"2023-01-06T13:42:57.964Z","comments":true,"path":"2022/03/02/【LeetCode刷题笔记】494-目标和/","link":"","permalink":"https://wangtianyang.com/2022/03/02/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91494-%E7%9B%AE%E6%A0%87%E5%92%8C/","excerpt":"题目494.目标和 给你一个整数数组nums和一个整数target。 向数组中的每个整数前添加&#39;+&#39;或&#39;-&#39;，然后串联起所有整数，可以构造一个表达式： 例如，nums = [2, 1]，可以在2之前添加&#39;+&#39;，在 1 之前添加&#39;-&#39;，然后串联起来得到表达式&quot;+2-1&quot;。返回可以通过上述方法构造的、运算结果等于target的不同 表达式 的数目。 示例 1：12345678输入：nums = [1,1,1,1,1], target = 3输出：5解释：一共有 5 种方法让最终目标和为 3 。-1 + 1 + 1 + 1 + 1 = 3+1 - 1 + 1 + 1 + 1 = 3+1 + 1 - 1 + 1 + 1 = 3+1 + 1 + 1 - 1 + 1 = 3+1 + 1 + 1 + 1 - 1 = 3示例 2：12输入：nums = [1], target = 1输出：1 提示： 1 &lt;= nums.length &lt;= 20 0 &lt;= nums[i] &lt;= 1000 0 &lt;= sum(nums[i]) &lt;= 1000 -1000 &lt;= target &lt;= 1000","text":"题目494.目标和 给你一个整数数组nums和一个整数target。 向数组中的每个整数前添加&#39;+&#39;或&#39;-&#39;，然后串联起所有整数，可以构造一个表达式： 例如，nums = [2, 1]，可以在2之前添加&#39;+&#39;，在 1 之前添加&#39;-&#39;，然后串联起来得到表达式&quot;+2-1&quot;。返回可以通过上述方法构造的、运算结果等于target的不同 表达式 的数目。 示例 1：12345678输入：nums = [1,1,1,1,1], target = 3输出：5解释：一共有 5 种方法让最终目标和为 3 。-1 + 1 + 1 + 1 + 1 = 3+1 - 1 + 1 + 1 + 1 = 3+1 + 1 - 1 + 1 + 1 = 3+1 + 1 + 1 - 1 + 1 = 3+1 + 1 + 1 + 1 - 1 = 3示例 2：12输入：nums = [1], target = 1输出：1 提示： 1 &lt;= nums.length &lt;= 20 0 &lt;= nums[i] &lt;= 1000 0 &lt;= sum(nums[i]) &lt;= 1000 -1000 &lt;= target &lt;= 1000 题解本题最容易想到的是回溯，即暴力遍历，挨个尝试每个数的加减就好了。但是会超时。所以我们尝试动态规划。动态规划比起暴力算法的优点就是它消除了重叠子问题，因此时间复杂度会更低。首先，我们要进行数学上的公式转换：令A和B分别表示nums中取正和负的数的子集，那么： \\sum A-\\sum B=target\\sum A=traget+\\sum B\\sum A+\\sum A=target+\\sum B+\\sum A2*\\sum A=target+\\sum nums\\sum A=(target+\\sum nums)/2接下来就好办多了，公式右边是个定值，那么设定dp[i][j]为nums的前i个元素有多少个子集A满足和为j，动态规划要素如下： 初始状态：dp[0][0]=1（空集也是子集），dp[0][else]=0。 终止状态：dp[n][(target+sum)/2] 状态转移：如果取当前元素加入子集A，则dp[i][j]=dp[i-1][j-nums[i]]；否则，dp[i][j]=dp[i-1]。故dp[i][j]=dp[i-1][j-nums[i]]+dp[i-1][j]。 转移方向：从上往下，从左往右。 优化：状态压缩 代码12345678910111213141516171819202122class Solution &#123;public: int findTargetSumWays(vector&lt;int&gt;&amp; nums, int target) &#123; int n = nums.size(), sum = 0; for (int num : nums) sum += num; target = target + sum; if (target % 2 || target &lt; 0) return 0; target = target /2; vector&lt;int&gt; dp(target+1, 0); dp[0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = target; j &gt;= 0; --j) &#123; if (j - nums[i-1] &gt;= 0) &#123; dp[j] = dp[j-nums[i-1]] + dp[j]; &#125; else &#123; dp[j] = dp[j]; &#125; &#125; &#125; return dp[target]; &#125;&#125;;","categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://wangtianyang.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://wangtianyang.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【面经】字节前端暑期一面（2022/03/01）","slug":"【面经】字节前端暑期一面（2022-03-01）","date":"2022-03-01T08:31:08.000Z","updated":"2023-01-06T13:49:40.717Z","comments":true,"path":"2022/03/01/【面经】字节前端暑期一面（2022-03-01）/","link":"","permalink":"https://wangtianyang.com/2022/03/01/%E3%80%90%E9%9D%A2%E7%BB%8F%E3%80%91%E5%AD%97%E8%8A%82%E5%89%8D%E7%AB%AF%E6%9A%91%E6%9C%9F%E4%B8%80%E9%9D%A2%EF%BC%882022-03-01%EF%BC%89/","excerpt":"","text":"vue2双向绑定说一下？和vue3有什么区别？优缺点？ vue2如何作用在数组上（重写数组方法原型进行监听 ） http和https的区别？ 说一下ssl建立连接过程？ 说一下如何获取证书过程？如何避免中间人攻击？验证方法？ 如何将dns（Domain Name System）解析成ip地址 全世界有多少根域名服务器？ 状态码？304 说一下协商缓存和强缓存的区别？如何知道资源是否过期？说一下他们有哪些请求头？cache-control中包含哪些字段？","categories":[{"name":"面经","slug":"面经","permalink":"https://wangtianyang.com/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[]},{"title":"【LeetCode刷题笔记】剑指OfferII101.分割等和子集","slug":"【LeetCode刷题笔记】剑指OfferII101-分割等和子集","date":"2022-03-01T03:20:12.000Z","updated":"2023-01-06T13:40:02.214Z","comments":true,"path":"2022/03/01/【LeetCode刷题笔记】剑指OfferII101-分割等和子集/","link":"","permalink":"https://wangtianyang.com/2022/03/01/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91%E5%89%91%E6%8C%87OfferII101-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/","excerpt":"题目剑指 Offer II 101. 分割等和子集 给定一个非空的正整数数组nums，请判断能否将这些数字分成元素和相等的两部分。 示例 1：123输入：nums = [1,5,11,5]输出：true解释：nums 可以分割成 [1, 5, 5] 和 [11] 。示例 2：123输入：nums = [1,2,3,5]输出：false解释：nums 不可以分为和相等的两部分","text":"题目剑指 Offer II 101. 分割等和子集 给定一个非空的正整数数组nums，请判断能否将这些数字分成元素和相等的两部分。 示例 1：123输入：nums = [1,5,11,5]输出：true解释：nums 可以分割成 [1, 5, 5] 和 [11] 。示例 2：123输入：nums = [1,2,3,5]输出：false解释：nums 不可以分为和相等的两部分 题解化成0-1背包问题！先计算数组的总和，则数组的元素如果能达到总和的一半，则返回true。dp[i][j]表示前i个元素能不能正好合成数字j。动态规划四要素： 初始状态：dp[0][0]=true; while(j!=0) dp[0][j]=false; while(i!=0) dp[i][0]=false; 很好理解，只有空数组和零可以互相匹配，否则空数组满足不了任何数，零也匹配不了任何非空正整数数组。 终止状态：dp[n][sum/2] 状态转移：只有两个选择，当前元素i要不要加入组合，如果加入，则dp[i][j]=dp[i-1][j-nums[i]]，否则，dp[i][j]=dp[i-1][j]。取或。 转移方向：从上往下，从左往右 优化：状态压缩可以看出，dp[i][j]都是通过上一行dp[i-1][...]转移过来的，这意味着可以进行压缩。压缩时需要注意，应该从右往左遍历，否则会覆盖。 代码12345678910111213141516171819class Solution &#123;public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(), sum = 0; for (int num : nums) &#123; sum += num; &#125; if (sum % 2) return false; sum /= 2; vector&lt;bool&gt; dp(sum+1, false); dp[0] = true; for (int i = 1; i &lt;=n; ++i) &#123; for (int j = sum; j &gt; 0; --j) &#123; if (nums[i-1] &lt;= j) dp[j] = dp[j] | dp[j-nums[i-1]]; &#125; &#125; return dp[sum]; &#125;&#125;;","categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://wangtianyang.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://wangtianyang.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【LeetCode刷题笔记】312.戳气球","slug":"【LeetCode刷题笔记】312-戳气球","date":"2022-02-28T09:41:09.000Z","updated":"2023-01-06T13:43:29.598Z","comments":true,"path":"2022/02/28/【LeetCode刷题笔记】312-戳气球/","link":"","permalink":"https://wangtianyang.com/2022/02/28/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91312-%E6%88%B3%E6%B0%94%E7%90%83/","excerpt":"题目312.戳气球 有n个气球，编号为0到n - 1，每个气球上都标有一个数字，这些数字存在数组nums中。 现在要求你戳破所有的气球。戳破第i个气球，你可以获得nums[i - 1] * nums[i] * nums[i + 1]枚硬币。 这里的i - 1和i + 1代表和i相邻的两个气球的序号。如果i - 1或i + 1超出了数组的边界，那么就当它是一个数字为1的气球。 求所能获得硬币的最大数量。 示例 1：12345输入：nums = [3,1,5,8]输出：167解释：nums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167示例 2：12输入：nums = [1,5]输出：10 提示： n == nums.length 1 &lt;= n &lt;= 500 0 &lt;= nums[i] &lt;= 100","text":"题目312.戳气球 有n个气球，编号为0到n - 1，每个气球上都标有一个数字，这些数字存在数组nums中。 现在要求你戳破所有的气球。戳破第i个气球，你可以获得nums[i - 1] * nums[i] * nums[i + 1]枚硬币。 这里的i - 1和i + 1代表和i相邻的两个气球的序号。如果i - 1或i + 1超出了数组的边界，那么就当它是一个数字为1的气球。 求所能获得硬币的最大数量。 示例 1：12345输入：nums = [3,1,5,8]输出：167解释：nums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167示例 2：12输入：nums = [1,5]输出：10 提示： n == nums.length 1 &lt;= n &lt;= 500 0 &lt;= nums[i] &lt;= 100 题解对于本题，最容易想到的方法应该是回溯，即遍历每一个气球，修改数组往下递归，再复原。但是此方法会超时，所以我们这里讨论动态规划。第一个气球和最后一个气球的左/右边都没有气球了，直接处理会非常麻烦，所以我们先扩宽边界，在0和n+1位置处放上两个值为1的虚拟气球。对于动态规划数组dp[i][j]，我们表示第i个气球与第j个气球之间的最大硬币数量（开区间）。于是我们可以定义动态规划要素了： 初始状态：当i&gt;=j时，dp[i][j]=0，因为i与j之间没有气球。 终止状态：我们最终要求的是第0个气球和第i+1个气球中间的最大值（开区间），即i==0&amp;&amp;j==n+1。 状态转移：我们需要逆向思维！！！不考虑先戳破哪个气球，而是考虑最后戳破哪个气球。假设最后戳破的是第k个气球（i&lt;k&lt;j），那么根据题目，所得硬币数应该是dp[i][j]=dp[i][k]+dp[k][j]+nums[i]*nums[j]*nums[k]。对于k的值，我们显然只需要遍历i+1～j-1即可！ 转移方向：已知最终状态在右上角，而dp[i][k]和dp[k][j]分别在dp[i][j]的左边和下面，因此，我们选择从下往上，从左往右。 代码1234567891011121314151617class Solution &#123;public: int maxCoins(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); nums.insert(nums.begin(), 1); nums.insert(nums.end(), 1); vector&lt;vector&lt;int&gt;&gt; dp(n+2, vector&lt;int&gt;(n+2, 0)); for (int i = n; i &gt;= 0; --i) &#123; for (int j = i+1; j &lt; n+2; ++j) &#123; for (int k = i+1; k &lt; j; ++k) &#123; dp[i][j] = max(dp[i][j], dp[i][k]+dp[k][j]+nums[k]*nums[i]*nums[j]); &#125; &#125; &#125; return dp[0][n+1]; &#125;&#125;;","categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://wangtianyang.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://wangtianyang.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【LeetCode刷题笔记】887.鸡蛋掉落","slug":"【LeetCode刷题笔记】887-鸡蛋掉落","date":"2022-02-27T07:38:25.000Z","updated":"2023-01-06T13:42:44.188Z","comments":true,"path":"2022/02/27/【LeetCode刷题笔记】887-鸡蛋掉落/","link":"","permalink":"https://wangtianyang.com/2022/02/27/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91887-%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BD/","excerpt":"题目887.鸡蛋掉落 给你k枚相同的鸡蛋，并可以使用一栋从第1层到第n层共有n层楼的建筑。 已知存在楼层f，满足0 &lt;= f &lt;= n，任何从高于f的楼层落下的鸡蛋都会碎，从f楼层或比它低的楼层落下的鸡蛋都不会破。 每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层x扔下（满足1 &lt;= x &lt;= n）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中重复使用这枚鸡蛋。 请你计算并返回要确定f确切的值的最小操作次数是多少？ 示例 1：1234567输入：k = 1, n = 2输出：2解释：鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f = 0 。 否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f = 1 。 如果它没碎，那么肯定能得出 f = 2 。 因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。 示例 2：12输入：k = 2, n = 6输出：3示例 3：12输入：k = 3, n = 14输出：4 提示： 1 &lt;= k &lt;= 100 1 &lt;= n &lt;= 104","text":"题目887.鸡蛋掉落 给你k枚相同的鸡蛋，并可以使用一栋从第1层到第n层共有n层楼的建筑。 已知存在楼层f，满足0 &lt;= f &lt;= n，任何从高于f的楼层落下的鸡蛋都会碎，从f楼层或比它低的楼层落下的鸡蛋都不会破。 每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层x扔下（满足1 &lt;= x &lt;= n）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中重复使用这枚鸡蛋。 请你计算并返回要确定f确切的值的最小操作次数是多少？ 示例 1：1234567输入：k = 1, n = 2输出：2解释：鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f = 0 。 否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f = 1 。 如果它没碎，那么肯定能得出 f = 2 。 因此，在最坏的情况下我们需要移动 2 次以确定 f 是多少。 示例 2：12输入：k = 2, n = 6输出：3示例 3：12输入：k = 3, n = 14输出：4 提示： 1 &lt;= k &lt;= 100 1 &lt;= n &lt;= 104 题解二维动态规划+二分搜索本题其实就是求最小时间复杂度。当我们选择楼层时，只有两个策略，要么遍历，要么不遍历。遍历也就是一层一层扔，此时最坏情况，也就是时间复杂度，为$O(n)$；不遍历的策略比如二分法，时间复杂度为$O(log_2n)$。动态规划四要素： 初始状态：楼层为零时，返回零；鸡蛋为一时，返回楼层数（因为只有一个鸡蛋的时候只能遍历，不能冒险）。 终止状态：dp[k-1][n]（因为增加了第零层） 状态转移：根据鸡蛋碎没碎，我们可以决定选更高的楼层还是选更低的楼层。计算时间复杂度时，要取两者中的最大值，而选择楼层策略时，又要去最大值中的最小值。假设当前楼层为n，我们在选取下一次的楼层时可以遍历1～n，每次遍历时计算最坏情况，再在n次遍历中取最小值，即为本次策略。 转移方向：从上往下，从左往右。 算法优化：游戏现在每次状态转移都要遍历，所以当前时间复杂度为$O(kn^2)$，我们可以使用二分搜索，则时间复杂度可以降低为$O(knlog_2n)$。 代码12345678910111213141516171819202122232425class Solution &#123;public: int superEggDrop(int k, int n) &#123; vector&lt;vector&lt;int&gt;&gt; dp(k, vector&lt;int&gt;(n+1, INT_MAX)); for (int i = 0; i &lt; k; ++i) &#123; dp[i][0] = 0; &#125; for (int i = 0; i &lt;= n; ++i) &#123; dp[0][i] = i; &#125; for (int i = 1; i &lt; k; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; int l = 1, r= j; while (l &lt;= r) &#123; int mid = l + (r-l)/2; int not_broken = dp[i][j-mid], broken = dp[i-1][mid-1]; if (not_broken &gt; broken) l = mid + 1; else r = mid - 1; dp[i][j] = min(dp[i][j], max(not_broken, broken) + 1); &#125; &#125; &#125; return dp[k-1][n]; &#125;&#125;;","categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://wangtianyang.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://wangtianyang.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【LeetCode刷题笔记】516.最长回文子序列","slug":"【LeetCode刷题笔记】516-最长回文子序列","date":"2022-02-27T03:39:41.000Z","updated":"2023-01-06T13:42:50.503Z","comments":true,"path":"2022/02/27/【LeetCode刷题笔记】516-最长回文子序列/","link":"","permalink":"https://wangtianyang.com/2022/02/27/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91516-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/","excerpt":"题目516.最长回文子序列 给你一个字符串s，找出其中最长的回文子序列，并返回该序列的长度。 子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。 示例 1：123输入：s = &quot;bbbab&quot;输出：4解释：一个可能的最长回文子序列为 &quot;bbbb&quot; 。示例 2：123输入：s = &quot;cbbd&quot;输出：2解释：一个可能的最长回文子序列为 &quot;bb&quot; 。 提示： 1 &lt;= s.length &lt;= 1000 s仅由小写英文字母组成","text":"题目516.最长回文子序列 给你一个字符串s，找出其中最长的回文子序列，并返回该序列的长度。 子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。 示例 1：123输入：s = &quot;bbbab&quot;输出：4解释：一个可能的最长回文子序列为 &quot;bbbb&quot; 。示例 2：123输入：s = &quot;cbbd&quot;输出：2解释：一个可能的最长回文子序列为 &quot;bb&quot; 。 提示： 1 &lt;= s.length &lt;= 1000 s仅由小写英文字母组成 题解对于最长子序列的问题，肯定考虑用动态规划。动态规划主要分为一维dp数组和二维dp数组，对于二维dp数组，又要分两种情况： 当涉及到两个字符串/数组时，dp[i][j]代表arr1[0…i]和arr2[0…j]； 当只涉及一个字符串/数组时，dp[i][j]代表arr[i…j] 本题使用二维dp数组。 动态规划需要考虑下面四点： 初始状态，即最简单的情况（base case） 对于本题，base case是对角线，即i==j，此时回文子序列长度必是1。 终止状态，即返回值 对于本题，显然要返回str[0…n]的情况，即dp[0][n] 状态转移 对于本题，当str[i]==str[j]时，显然dp[i][j]=dp[i+1][j-1]；而当str[i]!=str[j]时，说明这两个字符不可能同时出现在回文子序列中，经观察可以得出，dp[i][j]=max(dp[i+1][j], dp[i][j-1])。 转移方向 对于本题，由于i不可能小于j，所以我们可以从下往上，从左往右遍历。 代码1234567891011121314151617181920class Solution &#123;public: int longestPalindromeSubseq(string s) &#123; int n = s.size(); vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n, 0)); for (int i = 0; i &lt; n; ++i) &#123; dp[i][i] = 1; &#125; for (int i = n-2; i &gt;=0; --i) &#123; for (int j = i+1; j &lt; n; ++j) &#123; if (s[i] == s[j]) &#123; dp[i][j] = dp[i+1][j-1] + 2; &#125; else &#123; dp[i][j] = max(dp[i+1][j], dp[i][j-1]); &#125; &#125; &#125; return dp[0][n-1]; &#125;&#125;;","categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://wangtianyang.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://wangtianyang.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【操作系统】内存管理","slug":"【操作系统】内存管理","date":"2022-02-25T07:05:51.000Z","updated":"2023-01-06T13:52:51.505Z","comments":true,"path":"2022/02/25/【操作系统】内存管理/","link":"","permalink":"https://wangtianyang.com/2022/02/25/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","excerpt":"页式存储：用户空间划分为大小相等的部分称为页（page），内存空间划分为同样大小的区域称为页框，分配时以页为单位，按进程需要的页数分配，逻辑上相邻的页物理上不一定相邻； 段式存储：用户进程地址空间按照自身逻辑关系划分为若干个段（segment）（如代码段，数据段，堆栈段），内存空间被动态划分为长度不同的区域，分配时以段为单位，每段在内存中占据连续空间，各段可以不相邻； 段页式存储：用户进程先按段划分，段内再按页划分，内存划分和分配按页。 区别： 目的不同：分页的目的是管理内存，用于虚拟内存以获得更大的地址空间；分段的目的是满足用户的需要，使程序和数据可以被划分为逻辑上独立的地址空间； 大小不同：段的大小不固定，由其所完成的功能决定；页的大小固定，由系统决定； 地址空间维度不同：分段是二维地址空间（段号+段内偏移），分页是一维地址空间（每个进程一个页表/多级页表，通过一个逻辑地址就能找到对应的物理地址）； 分段便于信息的保护和共享；分页的共享收到限制； 碎片：分段没有内碎片，但会产生外碎片；分页没有外碎片，但会产生内碎片（一个页填不满）","text":"页式存储：用户空间划分为大小相等的部分称为页（page），内存空间划分为同样大小的区域称为页框，分配时以页为单位，按进程需要的页数分配，逻辑上相邻的页物理上不一定相邻； 段式存储：用户进程地址空间按照自身逻辑关系划分为若干个段（segment）（如代码段，数据段，堆栈段），内存空间被动态划分为长度不同的区域，分配时以段为单位，每段在内存中占据连续空间，各段可以不相邻； 段页式存储：用户进程先按段划分，段内再按页划分，内存划分和分配按页。 区别： 目的不同：分页的目的是管理内存，用于虚拟内存以获得更大的地址空间；分段的目的是满足用户的需要，使程序和数据可以被划分为逻辑上独立的地址空间； 大小不同：段的大小不固定，由其所完成的功能决定；页的大小固定，由系统决定； 地址空间维度不同：分段是二维地址空间（段号+段内偏移），分页是一维地址空间（每个进程一个页表/多级页表，通过一个逻辑地址就能找到对应的物理地址）； 分段便于信息的保护和共享；分页的共享收到限制； 碎片：分段没有内碎片，但会产生外碎片；分页没有外碎片，但会产生内碎片（一个页填不满） 内碎片和外碎片？“碎片的内存”描述一个系统中所有不可用的空闲内存。这些资源之所以仍然未被使用，是因为负责分配内存的分配器使这些内存无法使用。这一问题通常都会发生，原因在于空闲内存以小而不连续方式出现在不同的位置。 在内存管理中，内部碎片是已经被分配出去的的内存空间大于请求所需的内存空间。 外部碎片是指还没有分配出去，但是由于大小太小而无法分配给申请空间的新进程的内存空间空闲块。 什么是虚拟内存？每个程序都拥有自己的地址空间，这个地址空间被分成大小相等的页，这些页被映射到物理内存；但不需要所有的页都在物理内存中，当程序引用到不在物理内存中的页时，由操作系统将缺失的部分装入物理内存。这样，对于程序来说，逻辑上似乎有很大的内存空间，只是实际上有一部分是存储在磁盘上，因此叫做虚拟内存。 虚拟内存的优点是让程序可以获得更多的可用内存。 如何进行地址空间到物理内存的映射？内存管理单元（MMU）管理着逻辑地址和物理地址的转换，其中的页表（Page table）存储着页（逻辑地址）和页框（物理内存空间）的映射表，页表中还包含包含有效位（是在内存还是磁盘）、访问位（是否被访问过）、修改位（内存中是否被修改过）、保护位（只读还是可读写）。逻辑地址：页号+页内地址（偏移）；每个进程一个页表，放在内存，页表起始地址在PCB/寄存器中。 有哪些页面置换算法？在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘中来腾出空间。页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。 最佳页面置换算法OPT（Optimal replacement algorithm）：置换以后不需要或者最远的将来才需要的页面，是一种理论上的算法，是最优策略； 先进先出FIFO：置换在内存中驻留时间最长的页面。缺点：有可能将那些经常被访问的页面也被换出，从而使缺页率升高； 第二次机会算法SCR：按FIFO选择某一页面，若其访问位为1，给第二次机会，并将访问位置0； 时钟算法 Clock：SCR中需要将页面在链表中移动（第二次机会的时候要将这个页面从链表头移到链表尾），时钟算法使用环形链表，再使用一个指针指向最老的页面，避免了移动页面的开销； 最近未使用算法NRU（Not Recently Used）：检查访问位R、修改位M，优先置换R=M=0，其次是（R=0, M=1）； 最近最少使用算法LRU（Least Recently Used）：置换出未使用时间最长的一页；实现方式：维护时间戳，或者维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。 最不经常使用算法NFU：置换出访问次数最少的页面 局部性原理 时间上：最近被访问的页在不久的将来还会被访问； 空间上：内存中被访问的页周围的页也很可能被访问。 什么是颠簸现象颠簸本质上是指频繁的页调度行为。进程发生缺页中断时必须置换某一页。然而，其他所有的页都在使用，它置换一个页，但又立刻再次需要这个页。因此会不断产生缺页中断，导致整个系统的效率急剧下降，这种现象称为颠簸。内存颠簸的解决策略包括： 修改页面置换算法； 降低同时运行的程序的数量； 终止该进程或增加物理内存容量。 缓冲区溢出问题什么是缓冲区溢出？C 语言使用运行时栈来存储过程信息。每个函数的信息存储在一个栈帧中，包括寄存器、局部变量、参数、返回地址等。C 对于数组引用不进行任何边界检查，因此对越界的数组元素的写操作会破坏存储在栈中的状态信息，这种现象称为缓冲区溢出。缓冲区溢出会破坏程序运行，也可以被用来进行攻击计算机，如使用一个指向攻击代码的指针覆盖返回地址。 缓冲区溢出的防范方式防范缓冲区溢出攻击的机制有三种：随机化、栈保护和限制可执行代码区域。 随机化：包括栈随机化（程序开始时在栈上分配一段随机大小的空间）和地址空间布局随机化（Address-Space Layout Randomization，ASLR，即每次运行时程序的不同部分，包括代码段、数据段、栈、堆等都会被加载到内存空间的不同区域），但只能增加攻击一个系统的难度，不能完全保证安全。 栈保护：在每个函数的栈帧的局部变量和栈状态之间存储一个随机产生的特殊的值，称为金丝雀值（canary）。在恢复寄存器状态和函数返回之前，程序检测这个金丝雀值是否被改变了，如果是，那么程序异常终止。 限制可执行代码区域：内存页的访问形式有三种：可读、可写、可执行，只有编译器产生的那部分代码所处的内存才是可执行的，其他页限制为只允许读和写。 磁盘调度过程：磁头（找到对应的盘面）；磁道（一个盘面上的同心圆环，寻道时间）；扇区（旋转时间）。为减小寻道时间的调度算法： 先来先服务 最短寻道时间优先 电梯算法：电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。","categories":[{"name":"八股文","slug":"八股文","permalink":"https://wangtianyang.com/categories/%E5%85%AB%E8%82%A1%E6%96%87/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://wangtianyang.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"【操作系统】死锁","slug":"【操作系统】死锁","date":"2022-02-24T07:05:51.000Z","updated":"2023-01-06T13:52:45.426Z","comments":true,"path":"2022/02/24/【操作系统】死锁/","link":"","permalink":"https://wangtianyang.com/2022/02/24/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E6%AD%BB%E9%94%81/","excerpt":"什么是死锁？在两个或者多个并发进程中，每个进程持有某种资源而又等待其它进程释放它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁(deadlock)。 死锁产生的必要条件？ 互斥：一个资源一次只能被一个进程使用； 占有并等待：一个进程至少占有一个资源，并在等待另一个被其它进程占用的资源； 非抢占：已经分配给一个进程的资源不能被强制性抢占，只能由进程完成任务之后自愿释放； 循环等待：若干进程之间形成一种头尾相接的环形等待资源关系，该环路中的每个进程都在等待下一个进程所占有的资源。","text":"什么是死锁？在两个或者多个并发进程中，每个进程持有某种资源而又等待其它进程释放它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁(deadlock)。 死锁产生的必要条件？ 互斥：一个资源一次只能被一个进程使用； 占有并等待：一个进程至少占有一个资源，并在等待另一个被其它进程占用的资源； 非抢占：已经分配给一个进程的资源不能被强制性抢占，只能由进程完成任务之后自愿释放； 循环等待：若干进程之间形成一种头尾相接的环形等待资源关系，该环路中的每个进程都在等待下一个进程所占有的资源。 死锁有哪些处理方法？鸵鸟策略直接忽略死锁。因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。 死锁预防基本思想是破坏形成死锁的四个必要条件： 破坏互斥条件：允许某些资源同时被多个进程访问。但是有些资源本身并不具有这种属性，因此这种方案实用性有限； 破坏占有并等待条件： 实行资源预先分配策略（当一个进程开始运行之前，必须一次性向系统申请它所需要的全部资源，否则不运行）； 或者只允许进程在没有占用资源的时候才能申请资源（申请资源前先释放占有的资源）； 缺点：很多时候无法预知一个进程所需的全部资源；同时，会降低资源利用率，降低系统的并发性； 破坏非抢占条件：允许进程强行抢占被其它进程占有的资源。会降低系统性能； 破坏循环等待条件：对所有资源统一编号，所有进程对资源的请求必须按照序号递增的顺序提出，即只有占有了编号较小的资源才能申请编号较大的资源。这样避免了占有大号资源的进程去申请小号资源。 死锁避免动态地检测资源分配状态，以确保系统处于安全状态，只有处于安全状态时才会进行资源的分配。所谓安全状态是指：即使所有进程突然请求需要的所有资源，也能存在某种对进程的资源分配顺序，使得每一个进程运行完毕。 银行家算法 死锁解除 如何检测死锁：检测有向图是否存在环；或者使用类似死锁避免的检测算法。 死锁解除的方法： 利用抢占：挂起某些进程，并抢占它的资源。但应防止某些进程被长时间挂起而处于饥饿状态； 利用回滚：让某些进程回退到足以解除死锁的地步，进程回退时自愿释放资源。要求系统保持进程的历史信息，设置还原点； 利用杀死进程：强制杀死某些进程直到死锁解除为止，可以按照优先级进行。","categories":[{"name":"八股文","slug":"八股文","permalink":"https://wangtianyang.com/categories/%E5%85%AB%E8%82%A1%E6%96%87/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://wangtianyang.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"【操作系统】进程和线程","slug":"【操作系统】进程和线程","date":"2022-02-21T07:05:51.000Z","updated":"2023-01-06T13:53:03.553Z","comments":true,"path":"2022/02/21/【操作系统】进程和线程/","link":"","permalink":"https://wangtianyang.com/2022/02/21/%E3%80%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E3%80%91%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/","excerpt":"进程和线程有什么区别？ 进程（Process）是对运行时程序的封装，是系统进行资源分配和调度的基本单位；线程（Thread）是进程的子任务，是CPU调度和分派的基本单位； 线程依赖于进程而存在，一个进程至少有一个线程； 进程有自己的独立地址空间，线程共享所属进程的地址空间； 进程是拥有系统资源的一个独立单位，而线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，和其他线程共享本进程的相关资源如内存、I/O、CPU等； 在进程切换时，涉及到整个当前进程CPU环境的保存环境的设置以及新被调度运行的CPU环境的设置，而线程切换只需保存和设置少量的寄存器的内容，并不涉及存储器管理方面的操作，可见，进程切换的开销远大于线程切换的开销； 线程之间的通信更方便，同一进程下的线程共享全局变量等数据，而进程之间的通信需要以进程间通信(IPC)的方式进行； 多线程程序只要有一个线程崩溃，整个程序就崩溃了，但多进程程序中一个进程崩溃并不会对其它进程造成影响，因为进程有自己的独立地址空间，因此多进程更加健壮","text":"进程和线程有什么区别？ 进程（Process）是对运行时程序的封装，是系统进行资源分配和调度的基本单位；线程（Thread）是进程的子任务，是CPU调度和分派的基本单位； 线程依赖于进程而存在，一个进程至少有一个线程； 进程有自己的独立地址空间，线程共享所属进程的地址空间； 进程是拥有系统资源的一个独立单位，而线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，和其他线程共享本进程的相关资源如内存、I/O、CPU等； 在进程切换时，涉及到整个当前进程CPU环境的保存环境的设置以及新被调度运行的CPU环境的设置，而线程切换只需保存和设置少量的寄存器的内容，并不涉及存储器管理方面的操作，可见，进程切换的开销远大于线程切换的开销； 线程之间的通信更方便，同一进程下的线程共享全局变量等数据，而进程之间的通信需要以进程间通信(IPC)的方式进行； 多线程程序只要有一个线程崩溃，整个程序就崩溃了，但多进程程序中一个进程崩溃并不会对其它进程造成影响，因为进程有自己的独立地址空间，因此多进程更加健壮 同一进程中的线程可以共享哪些数据？ 进程代码段 进程的公有数据（全局变量、静态变量…） 进程打开的文件描述符 文件描述符是一个简单的整数，用以标明每一个被进程所打开的文件和socket。第一个打开的文件是0，第二个是1，依此类推。 进程的当前目录 信号处理器/信号处理函数：对收到的信号的处理方式 进程ID与进程组ID 线程独占哪些资源？ 线程ID 一组寄存器的值 线程自身的栈（堆是共享的） 错误返回码：线程可能会产生不同的错误返回码，一个线程的错误返回码不应该被其它线程修改； 信号掩码/信号屏蔽字(Signal mask)：表示是否屏蔽/阻塞相应的信号（SIGKILL,SIGSTOP除外） 进程间通信有哪些方式？ 管道(Pipe) 管道是半双工[1]的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道；一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据；只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程) 命名管道 有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，以有名管道的文件形式存在于文件系统中，这样，即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信， 消息队列 消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺。 信号(Signal) 信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。Linux系统中常用信号： SIGHUP：用户从终端注销，所有已启动进程都将收到该进程。系统缺省状态下对该信号的处理是终止进程。 SIGINT：程序终止信号。 SIGQUIT：程序退出信号。 SIGBUS：进程访问非法地址。 SIGFPE：运算中出现致命错误，如除零操作、数据溢出等。 SIGKILL：用户终止进程执行信号。shell下执行kill -9发送该信号。 SIGTERM：结束进程信号。shell下执行kill 进程pid发送该信号。 SIGALRM：定时器信号。 共享内存 使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。 信号量(Semaphore)：初始化操作、P操作、V操作；P操作：信号量-1，检测是否小于0，小于则进程进入阻塞状态；V操作：信号量+1，若小于等于0，则从队列中唤醒一个等待的进程进入就绪态 信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。 为了获得共享资源，进程需要执行下列操作：（1）创建一个信号量：这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0。（2）等待一个信号量：该操作会测试这个信号量的值，如果小于0，就阻塞。也称为P操作。（3）挂出一个信号量：该操作将信号量的值加1，也称为V操作。 套接字(Socket) 套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。 进程同步问题 进程的同步[2]是目的，而进程间通信是实现进程同步的手段 管程 Monitor管程将共享变量以及对这些共享变量的操作封装起来，形成一个具有一定接口的功能模块，这样只能通过管程提供的某个过程才能访问管程中的资源。进程只能互斥地使用管程，使用完之后必须释放管程并唤醒入口等待队列中的进程。 当一个进程试图进入管程时，在入口等待队列等待。若P进程唤醒了Q进程，则Q进程先执行，P在紧急等待队列中等待。（HOARE管程） wait操作：执行wait操作的进程进入条件变量链末尾，唤醒紧急等待队列或者入口队列中的进程；signal操作：唤醒条件变量链中的进程，自己进入紧急等待队列，若条件变量链为空，则继续执行。（HOARE管程） MESA管程：将HOARE中的signal换成了notify（或者broadcast通知所有满足条件的），进行通知而不是立马交换管程的使用权，在合适的时候，条件队列首位的进程可以进入，进入之前必须用while检查条件是否合适。优点：没有额外的进程切换 生产者-消费者问题 问题描述：使用一个缓冲区来存放数据，只有缓冲区没有满，生产者才可以写入数据；只有缓冲区不为空，消费者才可以读出数据代码实现：12345678910111213141516171819202122232425262728// 伪代码描述 // 定义信号量 full记录缓冲区物品数量 empty代表缓冲区空位数量 mutex为互斥量semaphore full = 0, empty = n, mutex = 1;// 生产者进程void producer()&#123; do&#123; P(empty); P(mutex); // 生产者进行生产 V(mutex); V(full); &#125; while(1);&#125;void consumer()&#123; do&#123; P(full); P(mutex); // 消费者进行消费 V(mutex); V(empty); &#125; while(1);&#125; 临界区的概念？各个进程中对临界资源（互斥资源/共享变量，一次只能给一个进程使用）进行操作的程序片段 同步与互斥的概念？同步：多个进程因为合作而使得进程的执行有一定的先后顺序。比如某个进程需要另一个进程提供的消息，获得消息之前进入阻塞态；互斥：多个进程在同一时刻只有一个进程能进入临界区 并发、并行、异步的区别？并发：在一个时间段中同时有多个程序在运行，但其实任一时刻，只有一个程序在CPU上运行，宏观上的并发是通过不断的切换实现的；多线程：并发运行的一段代码。是实现异步的手段并行（和串行相比）：在多CPU系统中，多个程序无论宏观还是微观上都是同时执行的异步（和同步相比）：同步是顺序执行，异步是在等待某个资源的时候继续做自己的事 进程有哪几种状态？ 就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源 运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数 阻塞状态： 进程等待某种条件，在条件满足之前无法执行 进程调度策略有哪些？ 批处理系统： 先来先服务 first-come first-serverd（FCFS） 按照请求的顺序进行调度。 非抢占式，开销小，无饥饿问题[3]，响应时间不确定（可能很慢）； 对短进程不利，对IO密集型进程不利。 最短作业优先 shortest job first（SJF） 按估计运行时间最短的顺序进行调度。 非抢占式，吞吐量高，开销可能较大，可能导致饥饿问题； 对短进程提供好的响应时间，对长进程不利。 最短剩余时间优先 shortest remaining time next（SRTN） 按剩余运行时间的顺序进行调度。 (最短作业优先的抢占式版本)。吞吐量高，开销可能较大，提供好的响应时间； 可能导致饥饿问题，对长进程不利。 最高响应比优先 Highest Response Ratio Next（HRRN） 按照队列中响应比的顺序进行调度。 响应比=（等待时间+要求服务时间）/要求服务时间。 既考虑作业的执行时间也考虑作业的等待时间，综合了先来先服务和最短作业优先两种算法的特点。 交互式系统： 交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。 时间片轮转 Round Robin 将所有就绪进程按 FCFS 的原则排成一个队列，用完时间片的进程排到队列最后。 抢占式（时间片用完时），开销小，无饥饿问题，为短进程提供好的响应时间； 若时间片小，进程切换频繁，吞吐量低；若时间片太长，实时性得不到保证 优先级调度算法 为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。 多级反馈队列调度算法 Multilevel Feedback Queue 设置多个就绪队列1、2、3…，优先级递减，时间片递增。只有等到优先级更高的队列为空时才会调度当前队列中的进程。如果进程用完了当前队列的时间片还未执行完，则会被移到下一队列。 抢占式（时间片用完时），开销可能较大，对IO型进程有利，可能会出现饥饿问题。 什么叫优先级反转？如何解决？高优先级的进程等待被一个低优先级进程占用的资源时，就会出现优先级反转，即优先级较低的进程比优先级较高的进程先执行。此处详细解释优先级反转带来的问题：如果有一个中等优先级的进程将低优先级的进程抢占，那么此时低优先级的进程无法正常进行并在后续释放被占用的资源，导致高优先级的任务一直被挂起，直到中等优先级的进程完成后，低优先级的进程才可以继续并在后续释放占用的资源，最后高优先级的进程才可以执行。导致的问题就是高优先级的进程在中等优先级的进程调度之后。 解决方法： 优先级天花板(priority ceiling)：当任务申请某资源时，把该任务的优先级提升到可访问这个资源的所有任务中的最高优先级，这个优先级称为该资源的优先级天花板。简单易行。 优先级继承(priority inheritance)：当任务A申请共享资源S时，如果S正在被任务C使用，通过比较任务C与自身的优先级，如发现任务C的优先级小于自身的优先级，则将任务C的优先级提升到自身的优先级，任务C释放资源S后，再恢复任务C的原优先级。 什么是僵尸进程？一个子进程结束后，它的父进程并没有等待它（调用wait或者waitpid），那么这个子进程将成为一个僵尸进程。僵尸进程是一个已经死亡的进程，但是并没有真正被销毁。它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程表中保留一个位置，记载该进程的进程ID、终止状态以及资源利用信息(CPU时间，内存使用量等等)供父进程收集，除此之外，僵尸进程不再占有任何内存空间。这个僵尸进程可能会一直留在系统中直到系统重启。 危害：占用进程号，而系统所能使用的进程号是有限的；占用内存。 以下情况不会产生僵尸进程： 该进程的父进程先结束了。每个进程结束的时候，系统都会扫描是否存在子进程，如果有则用Init进程接管，成为该进程的父进程，并且会调用wait等待其结束。 父进程调用wait或者waitpid等待子进程结束（需要每隔一段时间查询子进程是否结束）。wait系统调用会使父进程暂停执行，直到它的一个子进程结束为止。waitpid则可以加入WNOHANG(wait-no-hang)选项，如果没有发现结束的子进程，就会立即返回，不会将调用waitpid的进程阻塞。同时，waitpid还可以选择是等待任一子进程（同wait），还是等待指定pid的子进程，还是等待同一进程组下的任一子进程，还是等待组ID等于pid的任一子进程； 子进程结束时，系统会产生SIGCHLD(signal-child)信号，可以注册一个信号处理函数，在该函数中调用waitpid，等待所有结束的子进程（注意：一般都需要循环调用waitpid，因为在信号处理函数开始执行之前，可能已经有多个子进程结束了，而信号处理函数只执行一次，所以要循环调用将所有结束的子进程回收）； 也可以用signal(SIGCLD, SIG_IGN)(signal-ignore)通知内核，表示忽略SIGCHLD信号，那么子进程结束后，内核会进行回收。 什么是孤儿进程？一个父进程已经结束了，但是它的子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程会被Init（进程ID为1）接管，当这些孤儿进程结束时由Init完成状态收集工作。 线程同步有哪些方式？为什么需要线程同步：线程有时候会和其他线程共享一些资源，比如内存、数据库等。当多个线程同时读写同一份共享资源的时候，可能会发生冲突。因此需要线程的同步，多个线程按顺序访问资源。 互斥量 Mutex：互斥量是内核对象，只有拥有互斥对象的线程才有访问互斥资源的权限。因为互斥对象只有一个，所以可以保证互斥资源不会被多个线程同时访问；当前拥有互斥对象的线程处理完任务后必须将互斥对象交出，以便其他线程访问该资源； 信号量 Semaphore：信号量是内核对象，它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。信号量对象保存了最大资源计数和当前可用资源计数，每增加一个线程对共享资源的访问，当前可用资源计数就减1，只要当前可用资源计数大于0，就可以发出信号量信号，如果为0，则将线程放入一个队列中等待。线程处理完共享资源后，应在离开的同时通过ReleaseSemaphore函数将当前可用资源数加1。如果信号量的取值只能为0或1，那么信号量就成为了互斥量； 事件 Event：允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。事件分为手动重置事件和自动重置事件。手动重置事件被设置为激发状态后，会唤醒所有等待的线程，而且一直保持为激发状态，直到程序重新把它设置为未激发状态。自动重置事件被设置为激发状态后，会唤醒一个等待中的线程，然后自动恢复为未激发状态。 临界区 Critical Section：任意时刻只允许一个线程对临界资源进行访问。拥有临界区对象的线程可以访问该临界资源，其它试图访问该资源的线程将被挂起，直到临界区对象被释放。 互斥量和临界区有什么区别？互斥量是可以命名的，可以用于不同进程之间的同步；而临界区只能用于同一进程中线程的同步。创建互斥量需要的资源更多，因此临界区的优势是速度快，节省资源。 什么是用户态和内核态？为了限制不同程序的访问能力，防止一些程序访问其它程序的内存数据，CPU划分了用户态和内核态两个权限等级。 用户态只能受限地访问内存，且不允许访问外围设备，没有占用CPU的能力，CPU资源可以被其它程序获取； 内核态可以访问内存所有数据以及外围设备，也可以进行程序的切换。 所有用户程序都运行在用户态，但有时需要进行一些内核态的操作，比如从硬盘或者键盘读数据，这时就需要进行系统调用，使用陷阱指令，CPU&gt;切换到内核态，执行相应的服务，再切换为用户态并返回系统调用的结果。 为什么要分用户态和内核态？ 安全性：防止用户程序恶意或者不小心破坏系统/内存/硬件资源； 封装性：用户程序不需要实现更加底层的代码； 利于调度：如果多个用户程序都在等待键盘输入，这时就需要进行调度；统一交给操作系统调度更加方便。 如何从用户态切换到内核态？ 系统调用：比如读取命令行输入。本质上还是通过中断实现 用户程序发生异常时：比如缺页异常 外围设备的中断：外围设备完成用户请求的操作之后，会向CPU发出中断信号，这时CPU会转去处理对应的中断处理程序 什么是协程？协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。协程多与线程进行比较 一个线程可以拥有多个协程，一个进程也可以单独拥有多个协程 线程进程都是同步机制，而协程则是异步 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态 进程的异常控制流：陷阱、中断、异常和信号陷阱是有意造成的“异常”，是执行一条指令的结果。陷阱是同步的。陷阱的主要作用是实现系统调用。比如，进程可以执行syscall n指令向内核请求服务。当进程执行这条指令后，会中断当前的控制流，陷入到内核态，执行相应的系统调用。内核的处理程序在执行结束后，会将结果返回给进程，同时退回到用户态。进程此时继续执行下一条指令。 中断由处理器外部的硬件产生，不是执行某条指令的结果，也无法预测发生时机。由于中断独立于当前执行的程序，因此中断是异步事件。中断包括 I/O 设备发出的 I/O 中断、各种定时器引起的时钟中断、调试程序中设置的断点等引起的调试中断等。 异常是一种错误情况，是执行当前指令的结果，可能被错误处理程序修正，也可能直接终止应用程序。异常是同步的。这里特指因为执行当前指令而产生的错误情况，比如除法异常、缺页异常等。有些书上为了区分，也将这类“异常”称为“故障”。 信号是一种更高层的软件形式的异常，同样会中断进程的控制流，可以由进程进行处理。一个信号代表了一个消息。信号的作用是用来通知进程发生了某种系统事件。 什么是IO多路复用？怎么实现？IO多路复用（IO Multiplexing）是指单个进程/线程就可以同时处理多个IO请求。 实现原理：用户将想要监视的文件描述符（File Descriptor）添加到select/poll/epoll函数中，由内核监视，函数阻塞。一旦有文件描述符就绪（读就绪或写就绪），或者超时（设置timeout），函数就会返回，然后该进程可以进行相应的读/写操作。 操作系统为每一个进程维护了一个文件描述符表，该表的索引值都从从0开始的 select poll epoll 操作方式 遍历 遍历 回调 底层实现 数组 链表 红黑树 IO效率 每次调用都进行线性遍历，时间复杂度为O(n) 每次调用都进行线性遍历，时间复杂度为O(n) 事件通知方式，每当fd就绪，系统注册的回调函数就会被调用，将就绪fd放到readyList里面，时间复杂度为O(1) 最大连接数 1024(x86)或2048(x64) 无上限 无上限 fd拷贝 每次调用select，都需要把fd集合从用户态拷贝到内核态 每次调用poll，都需要把fd集合从用户态拷贝到内核态 调用epoll_ctl时拷贝进内核并保存，之后每次epoll_wait不拷贝 回调[4] select/poll/epoll三者的区别？ select：将文件描述符放入一个集合中，调用select时，将这个集合从用户空间拷贝到内核空间（缺点1：每次都要复制，开销大），由内核根据就绪状态修改该集合的内容。（缺点2）集合大小有限制，32位机默认是1024（64位：2048）；采用水平触发机制。select函数返回后，需要通过遍历这个集合，找到就绪的文件描述符（缺点3：轮询的方式效率较低），当文件描述符的数量增加时，效率会线性下降； poll：和select几乎没有区别，区别在于文件描述符的存储方式不同，poll采用链表的方式存储，没有最大存储数量的限制； epoll：通过内核和用户空间共享内存，避免了不断复制的问题；支持的同时连接数上限很高（1G左右的内存支持10W左右的连接数）；文件描述符就绪时，采用回调机制，避免了轮询（回调函数将就绪的描述符添加到一个链表中，执行epoll_wait时，返回这个链表）；支持水平触发和边缘触发，采用边缘触发机制时，只有活跃的描述符才会触发回调函数。 总结，区别主要在于： 一个线程/进程所能打开的最大连接数 文件描述符传递方式（是否复制） 水平触发 or 边缘触发 水平触发:就是只有高电平(1)或低电平(0)时才触发通知,只要在这两种状态就能得到通知.上面提到的只要有数据可读(描述符就绪)那么水平触发的epoll就立即返回.边缘触发:只有电平发生变化(高电平到低电平,或者低电平到高电平)的时候才触发通知.上面提到即使有数据可读,但是io状态没有变化epoll也不会立即返回. 查询就绪的描述符时的效率（是否轮询） 什么时候使用select/poll，什么时候使用epoll？当连接数较多并且有很多的不活跃连接时，epoll的效率比其它两者高很多； 但是当连接数较少并且都十分活跃的情况下，由于epoll需要很多回调，因此性能可能低于其它两者。 什么是文件描述符？文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。 内核通过文件描述符来访问文件。文件描述符指向一个文件。 什么是水平触发？什么是边缘触发？ 水平触发（LT，Level Trigger）模式下，只要一个文件描述符就绪，就会触发通知，如果用户程序没有一次性把数据读写完，下次还会通知； 边缘触发（ET，Edge Trigger）模式下，当描述符从未就绪变为就绪时通知一次，之后不会再通知，直到再次从未就绪变为就绪（缓冲区从不可读/写变为可读/写）。区别：边缘触发效率更高，减少了被重复触发的次数，函数不会返回大量用户程序可能不需要的文件描述符。 为什么边缘触发一定要用非阻塞（non-block）IO?避免由于一个描述符的阻塞读/阻塞写操作让处理其它描述符的任务出现饥饿状态。 有哪些常见的IO模型？ 同步阻塞IO（Blocking IO）：用户线程发起IO读/写操作之后，线程阻塞，直到可以开始处理数据；对CPU资源的利用率不够； 同步非阻塞IO（Non-blocking IO）：发起IO请求之后可以立即返回，如果没有就绪的数据，需要不断地发起IO请求直到数据就绪；不断重复请求消耗了大量的CPU资源； IO多路复用 异步IO（Asynchronous IO）：用户线程发出IO请求之后，继续执行，由内核进行数据的读取并放在用户指定的缓冲区内，在IO完成之后通知用户线程直接使用。 1.半双工(Half Duplex)数据传输指数据可以在一个信号载体的两个方向上传输，但是不能同时传输。 ↩2.同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才会继续执行下去； 异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。 当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。 ↩3.进程出现饥饿现象是指进程的优先级较低而长时间得不到调度。 ↩4.在计算机程序设计中，回调函数，或简称回调（Callback 即call then back 被主函数调用运算后会返回主函数），是指通过参数将函数传递到其它代码的，某一块可执行代码的引用。这一设计允许了底层代码调用在高层定义的子程序。 ↩","categories":[{"name":"八股文","slug":"八股文","permalink":"https://wangtianyang.com/categories/%E5%85%AB%E8%82%A1%E6%96%87/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://wangtianyang.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"【LeetCode刷题笔记】354.俄罗斯套娃信封问题","slug":"【LeetCode刷题笔记】354-俄罗斯套娃信封问题","date":"2022-02-21T04:41:03.000Z","updated":"2023-01-06T13:43:25.053Z","comments":true,"path":"2022/02/21/【LeetCode刷题笔记】354-俄罗斯套娃信封问题/","link":"","permalink":"https://wangtianyang.com/2022/02/21/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91354-%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83%E4%BF%A1%E5%B0%81%E9%97%AE%E9%A2%98/","excerpt":"题目354.俄罗斯套娃信封问题 给你一个二维整数数组envelopes，其中envelopes[i] = [wi, hi]，表示第i个信封的宽度和高度。 当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。 请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。 注意：不允许旋转信封。 示例 1：123输入：envelopes = [[5,4],[6,4],[6,7],[2,3]]输出：3解释：最多信封的个数为 3, 组合为: [2,3] =&gt; [5,4] =&gt; [6,7]。示例 2：12输入：envelopes = [[1,1],[1,1],[1,1]]输出：1 提示： 1 &lt;= envelopes.length &lt;= 105 envelopes[i].length == 2 1 &lt;= wi, hi &lt;= 105","text":"题目354.俄罗斯套娃信封问题 给你一个二维整数数组envelopes，其中envelopes[i] = [wi, hi]，表示第i个信封的宽度和高度。 当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。 请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。 注意：不允许旋转信封。 示例 1：123输入：envelopes = [[5,4],[6,4],[6,7],[2,3]]输出：3解释：最多信封的个数为 3, 组合为: [2,3] =&gt; [5,4] =&gt; [6,7]。示例 2：12输入：envelopes = [[1,1],[1,1],[1,1]]输出：1 提示： 1 &lt;= envelopes.length &lt;= 105 envelopes[i].length == 2 1 &lt;= wi, hi &lt;= 105 题解本质是个求二维的最长递增自序列核心在于如何将其降维，方法是排序：先对宽度w进行升序排序，如果w相同，则对高度h进行降序排序。之后对排序好的数组的h纬度进行最长递增子序列算法即可。前置知识点： sort用法：sort(vec.begin(),vec.end(),myfunc)，其中myfunc为自定义的排序方式，当然参数三也可以省略。 lambda函数用法：[捕获，可以为空](行参)&#123;函数体&#125; 代码注意！在用例更新后，单纯的最长递增子序列算法已经不可用，会超时，必须用二分法。(但我觉得二分法不是人能想出来的，脑筋急转弯没意思，所以这里还是贴上正常思路的代码。)12345678910111213141516171819class Solution &#123;public: int maxEnvelopes(vector&lt;vector&lt;int&gt;&gt;&amp; envelopes) &#123; sort(envelopes.begin(), envelopes.end(), [](const vector&lt;int&gt;&amp; x, const vector&lt;int&gt;&amp; y)&#123; return x[0]&lt;y[0] || (x[0]==y[0] &amp;&amp; x[1]&gt;y[1]); &#125;); int n = envelopes.size(); vector&lt;int&gt; dp(n, 1); for (int i = 1; i &lt; n; ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123; if (envelopes[i][1] &gt; envelopes[j][1]) &#123; dp[i] = max(dp[i], dp[j]+1); &#125; &#125; &#125; return *max_element(dp.begin(), dp.end()); &#125;&#125;;","categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://wangtianyang.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://wangtianyang.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【LeetCode刷题笔记】95.不同的二叉搜索树","slug":"【LeetCode刷题笔记】95-不同的二叉搜索树","date":"2022-02-20T13:43:08.000Z","updated":"2023-01-06T13:43:45.191Z","comments":true,"path":"2022/02/20/【LeetCode刷题笔记】95-不同的二叉搜索树/","link":"","permalink":"https://wangtianyang.com/2022/02/20/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%9195-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","excerpt":"题目95.不同程度的二叉搜索树 给你一个整数n，请你生成并返回所有由n个节点组成且节点值从1到n互不相同的不同二叉搜索树。可以按任意顺序返回答案。 示例 1：12输入：n = 3输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]示例 2：12输入：n = 1输出：[[1]] 提示： 1 &lt;= n &lt;= 8","text":"题目95.不同程度的二叉搜索树 给你一个整数n，请你生成并返回所有由n个节点组成且节点值从1到n互不相同的不同二叉搜索树。可以按任意顺序返回答案。 示例 1：12输入：n = 3输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]示例 2：12输入：n = 1输出：[[1]] 提示： 1 &lt;= n &lt;= 8 题解对于二叉搜索树，就应该想到用他的性质解题：左子树 &lt; 根节点 &lt; 右子树。比如对于递增区间[start, end]，若当前节点为i，则左子树范围是[start, i-1]，右子树范围是[i+1, end]。对于本题，我们也只需要输入start和end，并在start和end之间遍历当前节点并往下递归就好了。递归结束条件：start &gt; end，说明当前子树为空。 注意：当子数为空时，应该返回{nullptr}，而非{}，后者会导致输出始终为空。 代码123456789101112131415161718192021222324252627282930313233/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;TreeNode*&gt; generateTrees(int n) &#123; return generateTrees(1, n); &#125; vector&lt;TreeNode*&gt; generateTrees(int start, int end) &#123; if (start &gt; end) return &#123;nullptr&#125;; vector&lt;TreeNode*&gt; res; for (int i = start; i &lt;= end; ++i) &#123; vector&lt;TreeNode*&gt; left = generateTrees(start, i-1); vector&lt;TreeNode*&gt; right = generateTrees(i+1, end); for (int j = 0; j &lt; left.size(); ++j) &#123; for (int k = 0; k &lt; right.size(); ++ k) &#123; TreeNode *cur = new TreeNode(i, left[j], right[k]); res.push_back(cur); &#125; &#125; &#125; return res; &#125;&#125;;","categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://wangtianyang.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://wangtianyang.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【计算机网络】应用层：HTTP和HTTPS","slug":"【计算机网络】应用层：HTTP和HTTPS","date":"2022-02-20T07:57:17.000Z","updated":"2023-01-06T13:35:36.298Z","comments":true,"path":"2022/02/20/【计算机网络】应用层：HTTP和HTTPS/","link":"","permalink":"https://wangtianyang.com/2022/02/20/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%9AHTTP%E5%92%8CHTTPS/","excerpt":"HTTP协议的特点HTTP协议客户端请求request消息包括以下格式：请求行（request line）、请求头部（header）、空行、请求数据； 服务端响应response也由四个部分组成，分别是：响应行、响应头、空行、响应体。","text":"HTTP协议的特点HTTP协议客户端请求request消息包括以下格式：请求行（request line）、请求头部（header）、空行、请求数据； 服务端响应response也由四个部分组成，分别是：响应行、响应头、空行、响应体。 请求头部字段包括： Accept：能够接受的回应内容类型 Accept-Charset：能够接受的字符集 Accept-Encoding：能够接受的编码方式列表 Connection：该浏览器想要优先使用的连接类型 Date：发送该消息的日期和时间(按照 RFC 7231 中定义的”超文本传输协议日期”格式来发送) Host：服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号。如果所请求的端口是对应的服务的标准端口，则端口号可被省略 …… 响应头部字段包括： Age：这个对象在代理缓存中存在的时间，以秒为单位 Access-Control-Allow-Origin：指定哪些网站可参与到跨来源资源共享过程中 Accept-Patch：指定服务器支持的文件格式类型。 Date Allow：对于特定资源有效的动作。针对HTTP/405这一错误代码而使用 Connection …… HTTP请求方法HTTP协议定义了多种请求方式，具体如下：GET：获取资源，用来请求访问已被URI（统一资源标志符，和URL是包含和被包含的关系，URL是最常见的URI）识别的资源。POST：用来传输实体的主体，虽然GET也可以实现，但是一般不用。PUT：传输文件。但是鉴于PUT方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，因此一般网站都不采用该方法。HEAD：获得报文首部。和GET请求一样，只是不返回报文主体部分。DELETE：删除文件。同样不带验证机制，存在安全性问题。OPTIONS：询问指定的请求URI支持哪些方法。TRACE：追踪路径，让Web服务器将之前的请求通信环回给客户端的方法。CONNECT：要求在与代理服务器通信时建立隧道，实现隧道协议进行TCP通信。 HTTP和HTTPS有什么区别？ 端口不同：HTTP使用的是80端口，HTTPS使用443端口； HTTP（超文本传输协议）信息是明文传输，HTTPS运行在SSL(Secure Socket Layer)之上，添加了加密和认证机制，更加安全； HTTPS由于加密解密会带来更大的CPU和内存开销； HTTPS通信需要证书，一般需要向证书颁发机构（CA）购买 Https的连接过程（即SSL建立连接过程）？ 客户端向服务器发送请求，同时发送客户端支持的一套加密规则（包括对称加密、非对称加密、摘要算法）； 服务器从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥（用于非对称加密），以及证书的颁发机构等信息（证书中的私钥只能用于服务器端进行解密）； 客户端验证服务器的合法性，包括：证书是否过期，CA（证书颁发机构） 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配； 如果证书受信任，或者用户接收了不受信任的证书，浏览器会生成一个随机密钥（用于对称算法），并用服务器提供的公钥加密（采用非对称算法对密钥加密）；使用Hash算法对握手消息进行摘要计算，并对摘要使用之前产生的密钥加密（对称算法）；将加密后的随机密钥和摘要一起发送给服务器； 服务器使用自己的私钥解密，得到对称加密的密钥，用这个密钥解密出Hash摘要值，并验证握手消息是否一致；如果一致，服务器使用对称加密的密钥加密握手消息发给浏览器； 浏览器解密并验证摘要，若一致，则握手结束。之后的数据传送都使用对称加密的密钥进行加密。总结：非对称加密算法用于在握手过程中加密生成的密码；对称加密算法用于对真正传输的数据进行加密；HASH算法用于验证数据的完整性。 怎么确定用HTTP还是HTTPS？你访问的网站是如何自动切换到 HTTPS 的？一种是原始的302跳转，服务器把所有的HTTP流量跳转到HTTPS。但这样有一个漏洞，就是中间人可能在第一次访问站点的时候就劫持。解决方法是引入HSTS （HTTP 严格传输安全，HTTP Strict Transport Security）机制，用户浏览器在访问站点的时候强制使用HTTPS。 302重定向又称之为暂时性转移(Temporarily Moved )，英文名称：302 redirect。 也被认为是暂时重定向（temporary redirect） HTTPS连接的时候，怎么确定收到的包是服务器发来的（中间人攻击）？攻击者在传输过程中伪造服务器的证书，将服务器的公钥替换成自己的公钥，但是对于客户端来说，如果中间人伪造了证书，在校验证书过程中会提示证书错误。 HTTPS因为增加了CA证书，可以在会话前通过证书验证证明通信的彼此就是所声称的人，因此可以防范中间人攻击。这种防范中间人攻击的前提是在HTTPs协议的双向认证上。如果仅仅实现了HTTPs的单向认证，如不验证客户端，只验证服务器，这种情况下还是不能抵御中间人攻击的，这种情况下就会出现SSL剥离攻击（SSLTrip）和SSL劫持攻击。 SSL剥离攻击剥离SSL协议，表现为用户和攻击者之间使用HTTP，攻击者和服务器之间使用https协议。 如何防止SSL剥离攻击？可以（1）在服务器上开启HSTS，使服务器只接收使用HTTPS的连接。（2）将 HSTS 站点列表内置到浏览器中，这样只要浏览器离线判断该站点启用了 HSTS，就会跳过原先的 HTTP 重定向，直接发起 HTTPS 请求。 SSL劫持攻击表现为用户和攻击者之间使用攻击者伪造的CA证书使用其https协议进行通信，（其中重要的步骤是把burpsuit的CA根证书导入用户浏览器，这样用户浏览器就能信任假CA发给中间人的证书(即信任中间人burpsuit)，建立客户端和中间人之间的会话信道）。而攻击者和服务器之间使用真正的CA证书创建的对称秘钥进行加密，攻击者收到客户端信息先用前者会话秘钥解密，再使用后者之间的会话秘钥加密。这样使得客户端和服务器都以为是和真正的对方通信。 如何防止SSL劫持攻击？使用https双向认证 什么是对称加密、非对称加密？区别是什么？ 对称加密：加密和解密采用相同的密钥。如：DES、RC2、RC4 非对称加密：需要两个密钥：公钥和私钥。如果用公钥加密，需要用私钥才能解密。如：RSA区别：对称加密速度更快，通常用于大量数据的加密；非对称加密安全性更高（不需要传送私钥） 数字签名、报文摘要的原理 发送者A用私钥进行签名，接收者B用公钥验证签名。因为除A外没有人有私钥，所以B相信签名是来自A。A不可抵赖，B也不能伪造报文。 摘要算法:MD5、SHA MD5信息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致 GET与POST的区别？ GET是幂等的，即读取同一个资源，总是得到相同的数据，POST不是幂等的； 幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同 GET一般用于从服务器获取资源，而POST有可能改变服务器上的资源； 请求形式上：GET请求的数据附在URL之后，在HTTP请求头中；POST请求的数据在请求体中； 安全性：GET请求可被缓存、收藏、保留到历史记录，且其请求数据明文出现在URL中。POST的参数不会被保存，安全性相对较高； GET只允许ASCII字符，POST对数据类型没有要求，也允许二进制数据； GET的长度有限制（操作系统或者浏览器），而POST数据大小无限制 Get和Head的区别HEAD和GET本质是一样的，区别在于HEAD不含有呈现数据，而仅仅是HTTP头信息。有的人可能觉得这个方法没什么用，其实不是这样的。想象一个业务情景：欲判断某个资源是否存在，我们通常使用GET，但这里用HEAD则意义更加明确。 Session与Cookie的区别？Session是服务器端保持状态的方案，Cookie是客户端保持状态的方案 Cookie保存在客户端本地，客户端请求服务器时会将Cookie一起提交；Session保存在服务端，通过检索Sessionid查看状态。保存Sessionid的方式可以采用Cookie，如果禁用了Cookie，可以使用URL重写机制（把会话ID保存在URL中）。 由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session。第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。URL重写的技术来进行会话跟踪，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。Session是在服务端保存的一个数据结构，用来跟踪用户的状态；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。 从输入网址到获得页面的过程 (包括DNS如何解析成IP)？ 浏览器查询 DNS，获取域名对应的IP地址:具体过程包括浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存、读取本地的Host文件和向本地DNS服务器进行查询等。对于向本地DNS服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询； 浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手； TCP/IP链接建立起来后，浏览器向服务器发送HTTP请求； 服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器； 浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源； CSS 中的“样式”就是指外观；JavaScript 是一种脚本语言，它在网页中的作用是控制 HTML 中的每一个元素 浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。 全球一共有多少台根域名服务器？全球只有13台（这13台IPv4根域名服务器名字分别为“A”至“M”），1个为主根服务器在美国，由美国互联网机构Network Solutions运作。其余12个均为辅根服务器，其中9个在美国，2个在欧洲(位于英国和瑞典)，1个在亚洲(位于日本)。 HTTP请求有哪些常见状态码？HTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型。响应分为五类：信息响应(100–199)，成功响应(200–299)，重定向(300–399)，客户端错误(400–499)和服务器错误 (500–599)： 分类 分类描述 1xx 信息，服务器收到请求，需要请求者继续执行操作 2xx 成功，操作被成功接收并处理 3xx 重定向，需要进一步的操作以完成请求 4xx 客户端错误，请求包含语法错误或无法完成请求 5xx 服务器错误，服务器在处理请求的过程中发生了错误 HTTP状态码列表： 状态码 状态码英文名称 中文描述 100 Continue 继续。客户端应继续其请求 101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 200 OK 请求成功。一般用于GET与POST请求 201 Created 已创建。成功请求并创建了新的资源 202 Accepted 已接受。已经接受请求，但未处理完成 203 Non-Authoritative Information 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 204 No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 205 Reset Content 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 206 Partial Content 部分内容。服务器成功处理了部分GET请求 300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI 303 See Other 查看其它地址。与301类似。使用GET和POST请求查看 304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 305 Use Proxy 使用代理。所请求的资源必须通过代理访问 306 Unused 已经被废弃的HTTP状态码 307 Temporary Redirect 临时重定向。与302类似。使用GET请求重定向 400 Bad Request 客户端请求的语法错误，服务器无法理解 401 Unauthorized 请求要求用户的身份认证 402 Payment Required 保留，将来使用 403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求 404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面 405 Method Not Allowed 客户端请求中的方法被禁止 406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求 407 Proxy Authentication Required 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 408 Request Time-out 服务器等待客户端发送的请求时间过长，超时 409 Conflict 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突 410 Gone 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 411 Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息 412 Precondition Failed 客户端请求信息的先决条件错误 413 Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 414 Request-URI Too Large 请求的URI过长（URI通常为网址），服务器无法处理 415 Unsupported Media Type 服务器无法处理请求附带的媒体格式 416 Requested range not satisfiable 客户端请求的范围无效 417 Expectation Failed 服务器无法满足Expect的请求头信息 500 Internal Server Error 服务器内部错误，无法完成请求 501 Not Implemented 服务器不支持请求的功能，无法完成请求 502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 503 Service Unavailabe 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求 505 HTTP Version not supported 服务器不支持请求的HTTP协议的版本，无法完成处理 什么是RIP (Routing Information Protocol, 距离矢量路由协议)? 算法是什么？每个路由器维护一张表，记录该路由器到其它网络的”跳数“，路由器到与其直接连接的网络的跳数是1，每多经过一个路由器跳数就加1；更新该表时和相邻路由器交换路由信息；路由器允许一个路径最多包含15个路由器，如果跳数为16，则不可达。交付数据报时优先选取距离最短的路径。（PS：RIP是应用层协议：https://www.zhihu.com/question/19645407 ） 优缺点 实现简单，开销小 随着网络规模扩大开销也会增大； 最大距离为15，限制了网络的规模； 当网络出现故障时，要经过较长的时间才能将此信息传递到所有路由器","categories":[{"name":"八股文","slug":"八股文","permalink":"https://wangtianyang.com/categories/%E5%85%AB%E8%82%A1%E6%96%87/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://wangtianyang.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"【计算机网络】传输层：TCP和UDP","slug":"【计算机网络】传输层：TCP和UDP","date":"2022-02-20T01:45:55.000Z","updated":"2023-01-06T13:35:53.724Z","comments":true,"path":"2022/02/20/【计算机网络】传输层：TCP和UDP/","link":"","permalink":"https://wangtianyang.com/2022/02/20/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E4%BC%A0%E8%BE%93%E5%B1%82%EF%BC%9ATCP%E5%92%8CUDP/","excerpt":"三次握手","text":"三次握手 什么是三次握手？ 第一次握手：Client将SYN置1，随机产生一个初始序列号seq发送给Server，进入SYN_SENT状态； 第二次握手：Server收到Client的SYN=1之后，知道客户端请求建立连接，将自己的SYN置1，ACK置1，产生一个acknowledge number=seq+1，并随机产生一个自己的初始序列号，发送给Client，进入SYN_RCVD状态； 第三次握手：Client检查acknowledge number是否为序列号+1，ACK是否为1，检查正确之后将自己的ACK置为1，产生一个acknowledge number=Server序列号+1，发送给Server，进入ESRABLISHED状态；Server检查ACK为1和acknowledge number为序列号+1之后，也进入ESTABLISHED；完成三次握手，连接建立。 TCP建立连接可以两次握手吗？为什么？不可以。原因有二：首先，可能会出现已失效的连接请求报文段又传到了Server。 client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用 “三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用 “三次握手” 的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。 其次，两次握手无法保证Client正确接收第二次握手的报文，即Server无法确认Client是否收到，也无法保证Client和Server之间成功互换初始序列号。 可以采用四次握手吗？为什么？可以。但是会降低传输的效率。四次握手是指：第二次握手：Server只发送ACK和acknowledge number；而Server的SYN和初始序列号在第三次握手时发送；原来协议中的第三次握手变为第四次握手。出于优化目的，四次握手中的二、三可以合并。 第三次握手中，如果客户端的ACK未送达服务器，会怎样？ server端：由于server没有收到ACK确认，因此会重发之前的SYN+ACK（默认重发五次，之后自动关闭连接进入CLOSED状态），Client收到后会重新传ACK给Server。 client端，有两种情况： 在Server进行超时重发的过程中，如果Client向Server发送数据，数据头部的ACK为1，则Server收到数据之后会读取acknowledge number，进入ESTABLISHED状态； 在Server进入CLOSED状态之后，如果Client向Server发送数据，Server会以RST包应答。 如果已经建立了连接，但Client端出现了故障怎么办？Server每收到一次Client的请求后都会重新复位一个计时器，时间通常设置为两个小时，如果两小时内还没收到Client的任何数据，Server就会发送一个探测报文段，之后每隔75秒发送一次。若连续10个探测报文都没有回应，Server就会认为Client端出了故障，接着就关闭连接。 初始序列是什么？TCP连接的一方A，随机选择一个32位的序列号（Sequence Number）作为发送数据的初始序列号（Initial Sequence Number，ISN），比如为1000，以该序列号为原点，对要传送的数据进行编号：1001、1002…三次握手时，把这个初始序列号传送给另一方B，以便在传输数据时，B可以确认什么样的数据编号是合法的；同时在进行数据传输时，A还可以确认B收到的每一个字节，如果A收到了B的确认编号（acknowledge number）是2001，就说明编号为1001-2000的数据已经被B成功接受。 四次挥手 什么是四次挥手？ 第一次挥手：Client将FIN置为1，发送一个序列号seq给Server；进入FIN_WAIT_1状态； 第二次挥手：Server收到FIN之后，发送一个ACK=1，acknowledge number=收到的序列号+1；进入CLOSE_WAIT状态；此时Client已经没有要发送的数据了，但仍可以接受Server发来的数据。 第三次挥手：Server将FIN置1，发送一个序列号给Client；进入LAST_ACK状态； 第四次挥手：Client收到服务器的FIN后，进入TIME_WAIT状态；接着将ACK置1，发送一个acknowledge number=序列号+1给服务器；服务器收到后，确认acknowledge number，变为CLOSED状态，不再向客户端发送数据。客户端等待2*MSL[1]（报文最长寿命）事件后，也进入CLOSED状态。完成四次挥手。 为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE_WAIT状态意义是什么）？因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复ACK，表示接收到了断开连接的请求。等到数据发完之后再发FIN，断开服务器到客户端的数据传送。 如果第二次挥手时服务器的ACK没有送达客户端，会怎样？客户端没有收到ACK确认，会重新发送FIN请求。 客户端TIME_WAIT状态的意义是什么？第四次挥手时，客户端发送给服务器的ACK有可能丢失，TIME_WAIT状态就是用来重发可能丢失的ACK报文。如果Server没有收到ACK，就会重发FIN，如果Client在2*MSL的时间内收到了FIN，就会重新发送ACK并再次等待2MSL，防止Server没有收到ACK而不断重发FIN。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。 TCP如何实现流量控制？使用滑动窗口协议实现流量控制。防止发送方发送速率太快，接收方缓存区不够导致溢出。接收方会维护一个接收窗口 receiver window（窗口大小单位是字节），接受窗口的大小是根据自己的资源情况动态调整的，在返回ACK时将接受窗口大小放在TCP报文中的窗口字段告知发送方。发送窗口的大小不能超过接受窗口的大小，只有当发送方发送并收到确认之后，才能将发送窗口右移。发送窗口的上限为接受窗口和拥塞窗口中的较小值。接受窗口表明了接收方的接收能力，拥塞窗口表明了网络的传送能力。 什么是零窗口（接收窗口为0时会怎样）？如果接收方没有能力接收数据，就会将接收窗口设置为0，这时发送方必须暂停发送数据，但是会启动一个持续计时器(persistence timer)，到期后发送一个大小为1字节的探测数据包，以查看接收窗口状态。如果接收方能够接收数据，就会在返回的报文中更新接收窗口大小，恢复数据传送。 TCP的拥塞控制是怎么实现的？拥塞控制主要由四个算法组成：慢启动（Slow Start）、拥塞避免（Congestion voidance）、快重传 （Fast Retransmit）、快恢复（Fast Recovery） 慢启动：刚开始发送数据时，先把拥塞窗口（congestion window）设置为一个最大报文段MSS的数值，每收到一个新的确认报文之后，就把拥塞窗口加1个MSS。这样每经过一个传输轮次（或者说是每经过一个往返时间RTT），拥塞窗口的大小就会加倍 拥塞避免：当拥塞窗口的大小达到慢开始门限(slow start threshold)时，开始执行拥塞避免算法，拥塞窗口大小不再指数增加，而是线性增加，即每经过一个传输轮次只增加1MSS. 无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。（这是不使用快重传的情况） 快重传：快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。 快恢复：当发送方连续收到三个重复确认时，就把慢开始门限减半，然后执行拥塞避免算法。不执行慢开始算法的原因：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方认为现在网络可能没有出现拥塞。 TCP如何最大利用带宽？TCP速率受到三个因素影响 窗口：即滑动窗口大小，见TCP如何实现流量控制？ 带宽：这里带宽是指单位时间内从发送端到接收端所能通过的“最高数据率”，是一种硬件限制。TCP发送端和接收端的数据传输数不可能超过两点间的带宽限制。发送端和接收端之间带宽取所通过线路的带宽最小值（如通过互联网连接）。 RTT：即Round Trip Time，表示从发送端到接收端的一去一回需要的时间，TCP在数据传输过程中会对RTT进行采样（即对发送的数据包及其ACK的时间差进行测量，并根据测量值更新RTT值），TCP根据得到的RTT值更新RTO值，即Retransmission TimeOut，就是重传间隔，发送端对每个发出的数据包进行计时，如果在RTO时间内没有收到所发出的数据包的对应ACK，则认为数据包丢失，将重传数据。一般RTO值都比采样得到的RTT值要大。 带宽时延乘积设滑动窗口大小为$W$， 发送端和接收端的带宽为$B$， RTT为$T_r$。 前面已经说过了，TCP发送数据时受滑动窗口的限制，当TCP将滑动窗口中的数据都发出后，在收到第一个ACK之前，滑动窗口大小是0，不能再发送数据了，必须等待ACK包使滑动窗口移动。那么在理想情况下，ACK包应该在什么时候到达呢？显然，就是在数据发出后的RTT时间后，ACK包到达。这也就是说，现在在不考虑丢包和拥塞情况下，TCP在一个RTT时间内能发出的最大数据量为$W$，所以不考虑带宽限制下，TCP能一个时刻能达到的最大速度是$V=\\frac{W}{T_r}$。 现在再考虑带宽限制，前面说过当马路上摆满车的时候，就无法再往里放车了，同理，TCP发送端在$\\frac{T_r}{2}$时间内，能往通道上放的最大数据量为$\\frac{V \\ast T_r}{2}$，通过带宽时延乘积得到的容积限制为$\\frac{B \\ast T_r}{2}$。当$\\frac{B \\ast T_r}{2}\\geq\\frac{V \\ast T_r}{2}$时，单向通道容积不构成瓶颈，速率的限制主要来源于窗口大小限制。而当$\\frac{B\\ast T_r}{2}\\leq\\frac{V\\ast T_r}{2}$时，则就受到容积限制，即此时速率限制来源于带宽限制。 因此，TCP的最大速率为$V=min(\\frac{W}{T_r}, B)$。 在我们平时生活中使用的宽带网络，ADSL（非对称数字用户线路）等环境下，因为带宽都比较小，从而$B\\ast T_r$也比较小，再加上网络情况比较复杂，拥塞情况比较常见，所以这些网络环境下，TCP速率的主要限制因素在于带宽，丢包率等。在这些网络中速率的主要限制因素就是窗口大小了，这也是传统TCP在这些网络环境中不能充分利用带宽的原因所在（因为传统TCP的窗口大小是用2字节表示的，所以最大只有65535（不考虑窗口扩大选项）），除了专线网络外，随着网络硬件技术的发展，万兆交换机的出现，局域网中也可能会出现带宽时延乘积较大的情况。 TCP与UDP的区别 TCP是面向连接的，UDP是无连接的； 什么叫无连接？UDP发送数据之前不需要建立连接 TCP是可靠的，UDP不可靠； 什么叫不可靠？UDP接收方收到报文后，不需要给出任何确认 TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多； TCP是面向字节流的，UDP是面向报文的； 什么意思？面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。 TCP有拥塞控制机制，UDP没有。网络出现的拥塞不会使源主机的发送速率降低，这对某些实时应用是很重要的，比如媒体通信，游戏； TCP首部开销（20字节）比UDP首部开销（8字节）要大 UDP 的主机不需要维持复杂的连接状态表 什么时候选择TCP，什么时候选UDP？对某些实时性要求比较高的情况，选择UDP，比如游戏，媒体通信，实时视频流（直播），即使出现传输错误也可以容忍；其它大部分情况下，HTTP都是用TCP，因为要求传输的内容可靠，不出现丢失 HTTP可以使用UDP吗？HTTP不可以使用UDP，HTTP需要基于可靠的传输协议，而UDP不可靠注：http 3.0 使用udp实现 HTTP3维基百科 面向连接和无连接的区别无连接的网络服务（数据报服务）— 面向连接的网络服务（虚电路服务）数据报服务：每个数据包含目的地址，数据路由相互独立（路径可能变化）；网络尽最大努力交付数据，但不保证不丢失、不保证先后顺序、不保证在时限内交付；网络发生拥塞时，可能会将一些分组丢弃；虚电路（Virtual Circuit，VC）服务：首先建立连接，所有的数据包经过相同的路径，服务质量有较好的保证； TCP如何保证传输的可靠性 数据包校验 对失序数据包重新排序（TCP报文具有序列号） 丢弃重复数据 应答机制：接收方收到数据之后，会发送一个确认； 超时重传：发送方发出数据之后，启动一个定时器，超时未收到接收方的确认，则重新发送这个数据； 流量控制：确保接收端能够接收发送方的数据而不会缓冲区溢出1.MSL(Maximum Segment Lifetime)，指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。 ↩","categories":[{"name":"八股文","slug":"八股文","permalink":"https://wangtianyang.com/categories/%E5%85%AB%E8%82%A1%E6%96%87/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://wangtianyang.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"【计算机网络】网络层","slug":"【计算机网络】网络层","date":"2022-02-20T01:00:44.000Z","updated":"2023-01-06T13:36:38.761Z","comments":true,"path":"2022/02/20/【计算机网络】网络层/","link":"","permalink":"https://wangtianyang.com/2022/02/20/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E7%BD%91%E7%BB%9C%E5%B1%82/","excerpt":"IP地址的分类？路由器仅根据网络号net-id来转发分组，当分组到达目的网络的路由器之后，再按照主机号host-id将分组交付给主机；同一网络上的所有主机的网络号相同。 什么叫划分子网？从主机号host-id借用若干个比特作为子网号subnet-id；子网掩码：网络号和子网号都为1，主机号为0；数据报仍然先按照网络号找到目的网络，发送到路由器，路由器再按照网络号和子网号找到目的子网：将子网掩码与目标地址逐比特与操作，若结果为某个子网的网络地址，则送到该子网。","text":"IP地址的分类？路由器仅根据网络号net-id来转发分组，当分组到达目的网络的路由器之后，再按照主机号host-id将分组交付给主机；同一网络上的所有主机的网络号相同。 什么叫划分子网？从主机号host-id借用若干个比特作为子网号subnet-id；子网掩码：网络号和子网号都为1，主机号为0；数据报仍然先按照网络号找到目的网络，发送到路由器，路由器再按照网络号和子网号找到目的子网：将子网掩码与目标地址逐比特与操作，若结果为某个子网的网络地址，则送到该子网。 划分子网时，随着子网地址借用主机位数的增多，子网的数目随之增加，而每个子网中的可用主机数逐渐减少。以C类网络为例，原有8位主机位，2的8次方即256个主机地址，默认子网掩码255.255.255.0。借用1位主机位，产生2个子网，每个子网有126个主机地址；借用2位主机位（子网号），产生4个子网，每个子网有62个主机地址…… 每个子网中，第一个IP地址（即主机部分全部为0的IP）和最后一个IP（即主机部分全部为1的IP）不能分配给主机使用，所以每个子网的可用IP地址数为总IP地址数量减2；根据子网ID借用的主机位数，我们可以计算出划分的子网数、掩码、每个子网主机数，列表如下： 划分子网数 子网位数 子网掩码（二进制） 子网掩码（十进制） 每个子网主机数 1～2 1 11111111.11111111.11111111.10000000 255.255.255.128 126 3～4 2 11111111.11111111.11111111.11000000 255.255.255.192 62 5～8 3 11111111.11111111.11111111.11100000 255.255.255.224 30 9～16 4 11111111.11111111.11111111.11110000 255.255.255.240 14 17～32 5 11111111.11111111.11111111.11111000 255.255.255.248 6 33～64 6 11111111.11111111.11111111.11111100 255.255.255.252 2 如上表所示的C类网络中，若子网占用7位主机位时，主机位只剩一位，无论设为0还是1，都意味着主机位是全0或全1。由于主机位全0表示本网络，全1留作广播地址，这时子网实际没有可用主机地址，所以主机位至少应保留2位。 什么是ARP协议 (Address Resolution Protocol)？ARP协议完成了IP地址与物理地址的映射。每一个主机都设有一个 ARP 高速缓存，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。当源主机要发送数据包到目的主机时，会先检查自己的 ARP 高速缓存中有没有目的主机的 MAC 地址，如果有，就直接将数据包发到这个 MAC 地址，如果没有，就向所在的局域网发起一个 ARP 请求的广播包（在发送自己的 ARP 请求时，同时会带上自己的 IP 地址到硬件地址的映射），收到请求的主机检查自己的 IP 地址和目的主机的 IP 地址是否一致，如果一致，则先保存源主机的映射到自己的 ARP 缓存，然后给源主机发送一个 ARP 响应数据包。源主机收到响应数据包之后，先添加目的主机的 IP 地址与 MAC 地址的映射，再进行数据传送。如果源主机一直没有收到响应，表示 ARP 查询失败。 如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。 什么是NAT (Network Address Translation, 网络地址转换)？用于解决内网中的主机要和因特网上的主机通信。由NAT路由器将主机的本地IP地址转换为全球IP地址，分为静态转换（转换得到的全球IP地址固定不变）和动态NAT转换。","categories":[{"name":"八股文","slug":"八股文","permalink":"https://wangtianyang.com/categories/%E5%85%AB%E8%82%A1%E6%96%87/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://wangtianyang.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"【计算机网络】体系结构","slug":"【计算机网络】体系结构","date":"2022-02-20T00:00:34.000Z","updated":"2023-01-06T13:36:22.206Z","comments":true,"path":"2022/02/20/【计算机网络】体系结构/","link":"","permalink":"https://wangtianyang.com/2022/02/20/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/","excerpt":"计算机网络体系结构分为3种：OSI体系结构（七层），TCP/IP体系结构（四层），五层体系结构。 OSI体系结构: 概念清楚，理论也比较完整，但是它既复杂又不实用。 TCP/IP体系结构:TCP/IP是一个四层体系结构，得到了广泛的运用。 五层体系结构:为了方便学习，折中OSI体系结构和TCP/IP体系结构，综合二者的优点，这样既简洁，又能将概念讲清楚。TCP/IP与OSI最大的不同在于：OSI是一个理论上的网络通信模型，而TCP/IP则是实际运行的网络协议。","text":"计算机网络体系结构分为3种：OSI体系结构（七层），TCP/IP体系结构（四层），五层体系结构。 OSI体系结构: 概念清楚，理论也比较完整，但是它既复杂又不实用。 TCP/IP体系结构:TCP/IP是一个四层体系结构，得到了广泛的运用。 五层体系结构:为了方便学习，折中OSI体系结构和TCP/IP体系结构，综合二者的优点，这样既简洁，又能将概念讲清楚。TCP/IP与OSI最大的不同在于：OSI是一个理论上的网络通信模型，而TCP/IP则是实际运行的网络协议。 五层网络体系结构概述看一下五层网络体系结构各层的主要功能： 应用层：应用层是网络协议的最高层，主要任务通过进程间的交互完成特定网络应用。应用层协议定义的是应用程序（进程）间通信和交互的规则。应用层交互的数据单元称为报文。对于不同的网络应用需要有不同的应用层协议，在互联网中的应用层协议很多: FTP(21端口)：文件传输协议 SSH(22端口)：远程登录 更安全 TELNET(23端口)：远程登录 更高效 SMTP(25端口)：发送邮件 POP3(110端口)：接收邮件 HTTP(80端口)：超文本传输协议 DNS(53端口)：运行在UDP上，域名解析服务 运输层：有时也译为传输层，它负责为两台主机中的进程提供通信服务。该层主要有以下两种协议： 传输控制协议 (Transmission Control Protocol，TCP)：提供面向连接的、可靠的数据传输服务，数据传输的基本单位是报文段（segment）； 用户数据报协议 (User Datagram Protocol，UDP)：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性，数据传输的基本单位是用户数据报。 网络层：网络层负责为分组网络中的不同主机提供通信服务，并通过选择合适的路由将数据传递到目标主机。在发送数据时，网络层把运输层产生的报文段或用户数据封装成分组或包进行传送。 在TCP/IP体系中，由于网络层使用IP协议，因此分组也叫IP数据报。 数据链路层：数据链路层通常简称为链路层。数据链路层在两个相邻节点传输数据时，将网络层交下来的IP数据报组装成帧，在两个相邻节点之间的链路上传送帧。 物理层：保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境。","categories":[{"name":"八股文","slug":"八股文","permalink":"https://wangtianyang.com/categories/%E5%85%AB%E8%82%A1%E6%96%87/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://wangtianyang.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"【LeetCode刷题笔记】146.LRU缓存","slug":"【LeetCode刷题笔记】146-LRU缓存","date":"2022-02-19T03:54:24.000Z","updated":"2023-01-06T13:43:39.998Z","comments":true,"path":"2022/02/19/【LeetCode刷题笔记】146-LRU缓存/","link":"","permalink":"https://wangtianyang.com/2022/02/19/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91146-LRU%E7%BC%93%E5%AD%98/","excerpt":"题目146.LRU缓存 请你设计并实现一个满足LRU (最近最少使用) 缓存约束的数据结构。实现LRUCache类： LRUCache(int capacity)以正整数作为容量capacity初始化LRU 缓存 int get(int key)如果关键字key存在于缓存中，则返回关键字的值，否则返回-1。 void put(int key, int value)如果关键字key已经存在，则变更其数据值value；如果不存在，则向缓存中插入该组key-value。如果插入操作导致关键字数量超过capacity，则应该逐出最久未使用的关键字。函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。 示例：1234567891011121314151617输入[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;][[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]输出[null, null, null, 1, null, -1, null, -1, 3, 4]解释LRUCache lRUCache = new LRUCache(2);lRUCache.put(1, 1); // 缓存是 &#123;1=1&#125;lRUCache.put(2, 2); // 缓存是 &#123;1=1, 2=2&#125;lRUCache.get(1); // 返回 1lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;lRUCache.get(2); // 返回 -1 (未找到)lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;lRUCache.get(1); // 返回 -1 (未找到)lRUCache.get(3); // 返回 3lRUCache.get(4); // 返回 4 提示： 1 &lt;= capacity &lt;= 3000 0 &lt;= key &lt;= 10000 0 &lt;= value &lt;= 105 最多调用 2 * 105 次get和put","text":"题目146.LRU缓存 请你设计并实现一个满足LRU (最近最少使用) 缓存约束的数据结构。实现LRUCache类： LRUCache(int capacity)以正整数作为容量capacity初始化LRU 缓存 int get(int key)如果关键字key存在于缓存中，则返回关键字的值，否则返回-1。 void put(int key, int value)如果关键字key已经存在，则变更其数据值value；如果不存在，则向缓存中插入该组key-value。如果插入操作导致关键字数量超过capacity，则应该逐出最久未使用的关键字。函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。 示例：1234567891011121314151617输入[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;][[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]输出[null, null, null, 1, null, -1, null, -1, 3, 4]解释LRUCache lRUCache = new LRUCache(2);lRUCache.put(1, 1); // 缓存是 &#123;1=1&#125;lRUCache.put(2, 2); // 缓存是 &#123;1=1, 2=2&#125;lRUCache.get(1); // 返回 1lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;lRUCache.get(2); // 返回 -1 (未找到)lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;lRUCache.get(1); // 返回 -1 (未找到)lRUCache.get(3); // 返回 3lRUCache.get(4); // 返回 4 提示： 1 &lt;= capacity &lt;= 3000 0 &lt;= key &lt;= 10000 0 &lt;= value &lt;= 105 最多调用 2 * 105 次get和put 题解双向链表+map+虚拟头尾节点知识点： LRU，即最近最少使用，当内存满了的时候，自动删除最久没有访问的数据 list也是双向链表！但是搜索元素时需要遍历，时间复杂度太高，所以本题选择自定义双向链表 虚拟头尾可以省去很多边界条件的处理 注意事项： 调换节点顺序时，要注意处理好前后节点新的指向关系，不要遗漏 构建双向链表结构的时候，需要注意在构造函数内，将next和pre初始化为nullptr，否则在调用node-&gt;next时会出错 注意边界条件，比如将最后一个节点调换到最后一个时（原地tp），如果按照寻常逻辑处理，会导致节点的next指针指向自己（这地方我卡了一下午！！！） 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283struct LinkedNode &#123; int key; int value; LinkedNode *next; LinkedNode *prev; LinkedNode(int k, int v) &#123; key=k; value=v; next=nullptr; prev=nullptr; &#125; LinkedNode() &#123; key=-1; value=-1; next=nullptr; prev=nullptr; &#125;&#125;;class LRUCache &#123;private: LinkedNode *head; LinkedNode *tail; int cap; int size; unordered_map&lt;int, LinkedNode*&gt; des; void toTail(int key) &#123; LinkedNode *cur = des[key]; if (cur-&gt;next == tail) return; tail-&gt;prev-&gt;next = cur; cur-&gt;prev-&gt;next = cur-&gt;next; cur-&gt;next-&gt;prev = cur-&gt;prev; cur-&gt;prev = tail-&gt;prev; tail-&gt;prev = cur; cur-&gt;next = tail; &#125;public: LRUCache(int capacity) &#123; head=new LinkedNode(); tail=new LinkedNode(); head-&gt;next=tail; tail-&gt;prev=head; cap=capacity; size=0; &#125; int get(int key) &#123; if (des.find(key)!=des.end()) &#123; toTail(key); return des[key]-&gt;value; &#125; return -1; &#125; void put(int key, int value) &#123; if (des.find(key)!=des.end()) &#123; toTail(key); des[key]-&gt;value=value; return; &#125; LinkedNode *cur = new LinkedNode(key, value); tail-&gt;prev-&gt;next = cur; cur-&gt;prev = tail-&gt;prev; tail-&gt;prev = cur; cur-&gt;next = tail; des.insert(&#123;key, cur&#125;); ++size; if (size &gt; cap) &#123; head = head-&gt;next; des.erase(head-&gt;key); --size; &#125; &#125;&#125;;/** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj = new LRUCache(capacity); * int param_1 = obj-&gt;get(key); * obj-&gt;put(key,value); */","categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://wangtianyang.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://wangtianyang.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【LeetCode刷题笔记】剑指Offer43.1～n整数中1出现的次数","slug":"【LeetCode刷题笔记】剑指Offer43-1～n整数中1出现的次数","date":"2022-02-01T09:49:56.000Z","updated":"2023-01-06T13:40:14.286Z","comments":true,"path":"2022/02/01/【LeetCode刷题笔记】剑指Offer43-1～n整数中1出现的次数/","link":"","permalink":"https://wangtianyang.com/2022/02/01/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91%E5%89%91%E6%8C%87Offer43-1%EF%BD%9En%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/","excerpt":"题目剑指Offer 43. 1～n整数中1出现的次数 输入一个整数n，求1～n这n个整数的十进制表示中1出现的次数。 例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。 示例 1：12输入：n = 12输出：5示例 2：12输入：n = 13输出：6 限制： 1 &lt;= n &lt; 2^31","text":"题目剑指Offer 43. 1～n整数中1出现的次数 输入一个整数n，求1～n这n个整数的十进制表示中1出现的次数。 例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。 示例 1：12输入：n = 12输出：5示例 2：12输入：n = 13输出：6 限制： 1 &lt;= n &lt; 2^31 题解挨个计算每个位数上1出现的次数。举例：假设n=1234，我们枚举所有十位数上出现1的可能，分别是0010、0011、0012、…、1217、1218、1219，计算次数时去掉当前位，也就是000～124，一共125种情况。设计算法时，我们应该考虑如下三种情况：（仍然是以十位举例） 当前位是0: 例：12040010\\0011\\0012...\\1118\\1119 -&gt; 000~119 = 120所以计算公式为：高于当前位的数 * 位数 当前位是1: 例：12140010\\0011\\0012...\\1213\\1214 -&gt; 000~124 = 125所以计算公式为：高于当前位的数 * 位数 + 低于当前位的数 + 1 当前位是2～9: 例：12340010\\0011\\0012...\\1218\\1219 -&gt; 000~129 = 130所以计算公式为：(高于当前位的数 + 1) * 位数 代码1234567891011121314151617class Solution &#123;public: int countDigitOne(int n) &#123; int count = 0; long int digit = 1; while (n &gt;= digit) &#123; int i = (n / digit) % 10; int high = n / digit /10; int low = n % digit; if (i == 0) count += high * digit; else if (i == 1) count += high * digit + low + 1; else count += (high + 1) * digit; digit *= 10; &#125; return count; &#125;&#125;;","categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://wangtianyang.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://wangtianyang.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【LeetCode刷题笔记】剑指Offer41.数据流中的中位数","slug":"【LeetCode刷题笔记】剑指Offer41-数据流中的中位数","date":"2022-01-31T06:25:42.000Z","updated":"2023-01-06T13:40:27.618Z","comments":true,"path":"2022/01/31/【LeetCode刷题笔记】剑指Offer41-数据流中的中位数/","link":"","permalink":"https://wangtianyang.com/2022/01/31/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91%E5%89%91%E6%8C%87Offer41-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/","excerpt":"题目剑指Offer 41. 数据流中的中位数 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。 例如， [2,3,4] 的中位数是 3 [2,3] 的中位数是 (2 + 3) / 2 = 2.5 设计一个支持以下两种操作的数据结构： void addNum(int num) - 从数据流中添加一个整数到数据结构中。 double findMedian() - 返回目前所有元素的中位数。 示例 1：1234输入：[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;][[],[1],[2],[],[3],[]]输出：[null,null,null,1.50000,null,2.00000]示例 2：1234输入：[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;][[],[2],[],[3],[]]输出：[null,null,2.00000,null,2.50000] 限制： 最多会对 addNum、findMedian 进行 50000 次调用。","text":"题目剑指Offer 41. 数据流中的中位数 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。 例如， [2,3,4] 的中位数是 3 [2,3] 的中位数是 (2 + 3) / 2 = 2.5 设计一个支持以下两种操作的数据结构： void addNum(int num) - 从数据流中添加一个整数到数据结构中。 double findMedian() - 返回目前所有元素的中位数。 示例 1：1234输入：[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;][[],[1],[2],[],[3],[]]输出：[null,null,null,1.50000,null,2.00000]示例 2：1234输入：[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;][[],[2],[],[3],[]]输出：[null,null,2.00000,null,2.50000] 限制： 最多会对 addNum、findMedian 进行 50000 次调用。 题解本题是想考察堆的运用，而不是简单排序堆的定义：堆是一个完全二叉树，每个节点与其子节点位置相对。父节点总是大于或等于子节点，这种情况下被叫作大顶堆，或者父节点总是小于或等于子节点，这种情况下叫作小顶堆。注意，给定父节点的子节点不一定按顺序排列。make_heap和priority_queue的区别：（两者都是堆） priority_queue可以自动保持元素的顺序，但缺点是只能访问第一个元素，且不能打乱priority_queue的有序状态； make_heap可以访问堆中的任意元素，而不限于最大（或最小）的元素，因为元素被存储在一个容器中，就像是我们自己的vector。这也提供了偶然破坏元素顺序的可能，但是总可以调用make_heap()来还原堆。 make_heap可以在任何提供随机访问迭代器的序列容器中创建堆。这些序列容器包括普通数组、string 对象、自定义容器。这意味着无论什么时候需要，都可以用这些序列容器的元素创建堆，必要时，可以反复创建。甚至还可以为元素的子集创建堆。 对于本题，我们要维护一个大顶堆和一个小顶堆，大顶堆保存小于等于中位数的元素，小顶堆保存大于等于中位数的元素，那么中位数即为两个堆顶元素的组合，具体地：当数据流中有偶数个数时，中位数为 (大顶堆第一个元素的值 + 小顶堆第一个元素的值)/2；当数据流中有奇数个数时，中位数为大顶堆第一个元素的值。我们令m表示大顶堆的大小，n表示小顶堆的大小， m= \\begin{cases} n, &length为偶数 \\\\ n+1, &length为奇数 \\end{cases}每次添加一个新的数时：当m==n时，应该先将新元素添加到小顶堆，再把小顶堆顶部的值加到大顶堆；当m==n+1时，先将新元素添加到大顶堆，再把大顶堆顶部的值加到小顶堆。 代码1234567891011121314151617181920212223242526272829303132class MedianFinder &#123;public: /** initialize your data structure here. */ priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; left; // 大顶堆 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; right; // 小顶堆 MedianFinder() &#123; &#125; void addNum(int num) &#123; if (left.size() == right.size()) &#123; right.push(num); left.push(right.top()); right.pop(); &#125; else &#123; left.push(num); right.push(left.top()); left.pop(); &#125; &#125; double findMedian() &#123; if (left.size() == right.size()) return (left.top() + right.top()) / 2.0; else return (double)left.top(); &#125;&#125;;/** * Your MedianFinder object will be instantiated and called as such: * MedianFinder* obj = new MedianFinder(); * obj-&gt;addNum(num); * double param_2 = obj-&gt;findMedian(); */","categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://wangtianyang.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://wangtianyang.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【LeetCode刷题笔记】面试题19.正则表达式匹配","slug":"【LeetCode刷题笔记】面试题19-正则表达式匹配","date":"2022-01-31T02:50:57.000Z","updated":"2023-01-06T13:39:45.236Z","comments":true,"path":"2022/01/31/【LeetCode刷题笔记】面试题19-正则表达式匹配/","link":"","permalink":"https://wangtianyang.com/2022/01/31/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91%E9%9D%A2%E8%AF%95%E9%A2%9819-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/","excerpt":"题目面试题19. 正则表达式匹配 请实现一个函数用来匹配包含’. ‘和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但与”aa.a”和”ab*a”均不匹配。 示例 1:12345输入:s = &quot;aa&quot;p = &quot;a&quot;输出: false解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。示例 2:12345输入:s = &quot;aa&quot;p = &quot;a*&quot;输出: true解释: 因为 &#x27;*&#x27; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#x27;a&#x27;。因此，字符串 &quot;aa&quot; 可被视为 &#x27;a&#x27; 重复了一次。示例 3:12345输入:s = &quot;ab&quot;p = &quot;.*&quot;输出: true解释: &quot;.*&quot; 表示可匹配零个或多个（&#x27;*&#x27;）任意字符（&#x27;.&#x27;）。示例 4:12345输入:s = &quot;aab&quot;p = &quot;c*a*b&quot;输出: true解释: 因为 &#x27;*&#x27; 表示零个或多个，这里 &#x27;c&#x27; 为 0 个, &#x27;a&#x27; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。示例 5:1234输入:s = &quot;mississippi&quot;p = &quot;mis*is*p*.&quot;输出: false s可能为空，且只包含从a-z的小写字母。 p可能为空，且只包含从a-z的小写字母以及字符.和*，无连续的&#39;*&#39;。","text":"题目面试题19. 正则表达式匹配 请实现一个函数用来匹配包含’. ‘和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但与”aa.a”和”ab*a”均不匹配。 示例 1:12345输入:s = &quot;aa&quot;p = &quot;a&quot;输出: false解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。示例 2:12345输入:s = &quot;aa&quot;p = &quot;a*&quot;输出: true解释: 因为 &#x27;*&#x27; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#x27;a&#x27;。因此，字符串 &quot;aa&quot; 可被视为 &#x27;a&#x27; 重复了一次。示例 3:12345输入:s = &quot;ab&quot;p = &quot;.*&quot;输出: true解释: &quot;.*&quot; 表示可匹配零个或多个（&#x27;*&#x27;）任意字符（&#x27;.&#x27;）。示例 4:12345输入:s = &quot;aab&quot;p = &quot;c*a*b&quot;输出: true解释: 因为 &#x27;*&#x27; 表示零个或多个，这里 &#x27;c&#x27; 为 0 个, &#x27;a&#x27; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。示例 5:1234输入:s = &quot;mississippi&quot;p = &quot;mis*is*p*.&quot;输出: false s可能为空，且只包含从a-z的小写字母。 p可能为空，且只包含从a-z的小写字母以及字符.和*，无连续的&#39;*&#39;。 题解动态规划！我们用dp[i][j]记录s的前i个字符和p的前j个字符是否匹配，p的字符有三种情况： 当p的第j个字符为字母时，转移规则如下：dp[i][j]= \\begin{cases} dp[i-1][j-1],& p[j]\\neq s[i] \\\\ false,& p[j]=s[i] \\end{cases} 当p的第j个字符为’·’时，转移规则如下：dp[i][j]=dp[i-1][j-1] 当p的第j个字符为’*’时，转移规则如下：dp[i][j]= \\begin{cases} dp[i-1][j] or dp[i][j-2],& p[j-1]=s[i] or p[j-1]='·' \\\\ dp[i][j-2],& p[j-1]\\neq s[i] \\end{cases}注意！需要先处理dp第一行，因为a*与空字符串匹配。 代码123456789101112131415161718192021222324252627282930class Solution &#123;public: bool isMatch(string s, string p) &#123; int m = s.size(), n = p.size(); vector&lt;vector&lt;bool&gt;&gt; dp(m + 1, vector&lt;bool&gt;(n + 1, false)); dp[0][0] = true; for (int i = 2; i &lt; n + 1; i+=2) dp[0][i] = dp[0][i-2] &amp; (p[i-1] == &#x27;*&#x27;); for (int i = 0; i &lt; m; ++i) &#123; for (int j = 0; j &lt; n; ++ j) &#123; if (p[j] == &#x27;.&#x27;) &#123; dp[i+1][j+1] = dp[i][j]; &#125; else if (p[j] == &#x27;*&#x27;) &#123; if (p[j-1] == &#x27;.&#x27; || p[j-1] == s[i]) &#123; dp[i+1][j+1] = dp[i+1][j-1] | dp[i][j+1]; &#125; else &#123; dp[i+1][j+1] = dp[i+1][j-1]; &#125; &#125; else &#123; if (p[j] == s[i]) &#123; dp[i+1][j+1] = dp[i][j]; &#125; else &#123; dp[i+1][j+1] = false; &#125; &#125; &#125; &#125; return dp[m][n]; &#125;&#125;;","categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://wangtianyang.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://wangtianyang.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【LeetCode刷题笔记】剑指Offer36.二叉搜索树与双向链表","slug":"【LeetCode刷题笔记】剑指Offer36-二叉搜索树与双向链表","date":"2022-01-30T02:20:59.000Z","updated":"2023-01-06T13:40:45.811Z","comments":true,"path":"2022/01/30/【LeetCode刷题笔记】剑指Offer36-二叉搜索树与双向链表/","link":"","permalink":"https://wangtianyang.com/2022/01/30/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91%E5%89%91%E6%8C%87Offer36-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/","excerpt":"题目剑指Offer 36. 二叉搜索树与双向链表 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。","text":"题目剑指Offer 36. 二叉搜索树与双向链表 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。 题解中序遍历的二叉搜索树就是递增序列！！创建两个函数，一个是主函数，负责处理特殊情况，另一个是辅函数，用于递归。具体地，先创建head和tail，分别表示序列的头和尾。中序遍历到的首节点，也就是二叉搜索树最左边的节点，即为最小值，将它赋值给head，同理，末节点赋值给tail。cur指针指向当前遍历的节点，pre指针指向上一个遍历的节点，初始值为nullptr。由于遍历完成后，pre会指向最后一个节点，所以pre=tail。（省去创建tail）主函数： 如果head == nullptr，返回空； 初始化pre和cur； 链接head和tail。 辅函数： 如果cur == nullptr，返回； 链接pre和cur，若pre为空，则赋值head=cur。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*// Definition for a Node.class Node &#123;public: int val; Node* left; Node* right; Node() &#123;&#125; Node(int _val) &#123; val = _val; left = NULL; right = NULL; &#125; Node(int _val, Node* _left, Node* _right) &#123; val = _val; left = _left; right = _right; &#125;&#125;;*/class Solution &#123; Node *head=nullptr, *pre=nullptr;public: Node* treeToDoublyList(Node* root) &#123; if (root==nullptr) return nullptr; dfs(root); head-&gt;left=pre; pre-&gt;right=head; return head; &#125; void dfs(Node* cur) &#123; if (cur==nullptr) return; dfs(cur-&gt;left); if (pre == nullptr) head = cur; else &#123; cur-&gt;left=pre; pre-&gt;right=cur; &#125; pre = cur; dfs(cur-&gt;right); &#125;&#125;;","categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://wangtianyang.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://wangtianyang.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【LeetCode刷题笔记】剑指Offer35.复杂链表的复制","slug":"【LeetCode刷题笔记】剑指Offer35-复杂链表的复制","date":"2022-01-29T03:51:25.000Z","updated":"2023-01-06T13:40:52.093Z","comments":true,"path":"2022/01/29/【LeetCode刷题笔记】剑指Offer35-复杂链表的复制/","link":"","permalink":"https://wangtianyang.com/2022/01/29/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91%E5%89%91%E6%8C%87Offer35-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/","excerpt":"题目剑指Offer 35. 复杂链表的复制 请实现copyRandomList函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个next指针指向下一个节点，还有一个random指针指向链表中的任意节点或者null。 示例 1：12输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]示例 2：12输入：head = [[1,1],[2,1]]输出：[[1,1],[2,1]]示例 3：12输入：head = [[3,null],[3,0],[3,null]]输出：[[3,null],[3,0],[3,null]]示例 4：123输入：head = []输出：[]解释：给定的链表为空（空指针），因此返回 null。 提示： -10000 &lt;= Node.val &lt;= 10000 Node.random为空（null）或指向链表中的节点。 节点数目不超过1000。","text":"题目剑指Offer 35. 复杂链表的复制 请实现copyRandomList函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个next指针指向下一个节点，还有一个random指针指向链表中的任意节点或者null。 示例 1：12输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]示例 2：12输入：head = [[1,1],[2,1]]输出：[[1,1],[2,1]]示例 3：12输入：head = [[3,null],[3,0],[3,null]]输出：[[3,null],[3,0],[3,null]]示例 4：123输入：head = []输出：[]解释：给定的链表为空（空指针），因此返回 null。 提示： -10000 &lt;= Node.val &lt;= 10000 Node.random为空（null）或指向链表中的节点。 节点数目不超过1000。 题解一可以使用哈希表建立原链表与新链表的对照关系！循环两次，第一次循环建立创建哈希表和新链表各个节点的值，第二次循环根据哈希表建立各个节点之间的连接。 代码一12345678910111213141516171819202122232425262728293031323334/*// Definition for a Node.class Node &#123;public: int val; Node* next; Node* random; Node(int _val) &#123; val = _val; next = NULL; random = NULL; &#125;&#125;;*/class Solution &#123;public: Node* copyRandomList(Node* head) &#123; Node* cur = head; unordered_map&lt;Node*, Node*&gt; dic; while (cur != nullptr) &#123; Node* copyNode = new Node(cur-&gt;val); dic[cur] = copyNode; cur = cur-&gt;next; &#125; cur = head; while (cur != nullptr) &#123; dic[cur]-&gt;next = dic[cur-&gt;next]; dic[cur]-&gt;random = dic[cur-&gt;random]; cur = cur-&gt;next; &#125; return dic[head]; &#125;&#125;; 题解二拼接+拆分！！先按照原节点1-&gt;新节点1-&gt;原节点2-&gt;新节点2-&gt;…-&gt;原节点N-&gt;新节点N拼接，随后拆分即可。 代码二12345678910111213141516171819202122232425262728293031323334353637383940414243/*// Definition for a Node.class Node &#123;public: int val; Node* next; Node* random; Node(int _val) &#123; val = _val; next = NULL; random = NULL; &#125;&#125;;*/class Solution &#123;public: Node* copyRandomList(Node* head) &#123; if (head == nullptr) return nullptr; Node* cur = head; while (cur != nullptr) &#123; Node* copyNode = new Node(cur-&gt;val); copyNode-&gt;next = cur-&gt;next; cur-&gt;next = copyNode; cur = copyNode-&gt;next; &#125; cur = head; while (cur != nullptr) &#123; cur-&gt;next-&gt;random = cur-&gt;random == nullptr ? nullptr : cur-&gt;random-&gt;next; cur = cur-&gt;next-&gt;next; &#125; Node* newHead = head-&gt;next; cur = head; while (cur != nullptr) &#123; Node* temp = cur-&gt;next; cur-&gt;next = temp-&gt;next; if (temp-&gt;next != nullptr) temp-&gt;next = temp-&gt;next-&gt;next; cur = cur-&gt;next; &#125; return newHead; &#125;&#125;;","categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://wangtianyang.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://wangtianyang.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【LeetCode刷题笔记】剑指Offer33.二叉搜索树的后序遍历序列","slug":"【LeetCode刷题笔记】剑指Offer33-二叉搜索树的后序遍历序列","date":"2022-01-28T11:26:51.000Z","updated":"2023-01-06T13:40:57.708Z","comments":true,"path":"2022/01/28/【LeetCode刷题笔记】剑指Offer33-二叉搜索树的后序遍历序列/","link":"","permalink":"https://wangtianyang.com/2022/01/28/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91%E5%89%91%E6%8C%87Offer33-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/","excerpt":"题目剑指Offer 33. 二叉搜索树的后序遍历序列 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回true，否则返回false。假设输入的数组的任意两个数字都互不相同。 参考以下这颗二叉搜索树：12345 5 / \\ 2 6 / \\1 3示例 1：12输入: [1,6,3,2,5]输出: false示例 2：12输入: [1,3,2,6,5]输出: true 提示： 数组长度 &lt;= 1000","text":"题目剑指Offer 33. 二叉搜索树的后序遍历序列 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回true，否则返回false。假设输入的数组的任意两个数字都互不相同。 参考以下这颗二叉搜索树：12345 5 / \\ 2 6 / \\1 3示例 1：12输入: [1,6,3,2,5]输出: false示例 2：12输入: [1,3,2,6,5]输出: true 提示： 数组长度 &lt;= 1000 题解二叉搜索树的定义：左子树中所有节点的值 &lt; 根节点的值 &lt; 右子树中所有节点的值。后序遍历：左子树-&gt;右子树-&gt;根节点根据定义，只要所有左子树和右子树都满足二叉搜索树，则该树为二叉搜索树，所以我们应该想到使用递归&amp;分治判断所有子树的正确性。令[l, r]表示当前树的范围，用m来划分左右子树，m为第一个大于根节点的节点的索引。具体地： 遍历[l, r]，找到第一个大于tree[r]的节点tree[m]，将[l, m-1]、[m, r-1]分别作为下一次递归的参数； 步骤1已经保证了左子树都小于根节点，所以我们只需要再遍历判断右子树是不是都大于根节点，如果不是则返回false； 如果l &gt;= r，表明当前树小于等于一个节点，则返回true。 代码123456789101112131415161718class Solution &#123;public: bool verifyPostorder(vector&lt;int&gt;&amp; postorder) &#123; return recur(postorder, 0, postorder.size()-1); &#125; bool recur(vector&lt;int&gt;&amp; postorder, int l, int r) &#123; if (l &gt;= r) return true; int m = l; for (; m &lt; r; ++m)&#123; if (postorder[m] &gt; postorder[r]) break; &#125; for (int i = m+1; i&lt;r; ++i) &#123; if (postorder[i] &lt; postorder[r]) return false; &#125; return recur(postorder, l, m-1) &amp;&amp; recur(postorder, m, r-1); &#125;&#125;;","categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://wangtianyang.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://wangtianyang.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【LeetCode刷题笔记】剑指Offer31.栈的压入弹出序列","slug":"【LeetCode刷题笔记】剑指Offer31-栈的压入弹出序列","date":"2022-01-28T09:15:13.000Z","updated":"2023-01-06T13:41:04.017Z","comments":true,"path":"2022/01/28/【LeetCode刷题笔记】剑指Offer31-栈的压入弹出序列/","link":"","permalink":"https://wangtianyang.com/2022/01/28/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91%E5%89%91%E6%8C%87Offer31-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/","excerpt":"题目剑指Offer 31. 栈的压入弹出序列 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。 示例 1：12345输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]输出：true解释：我们可以按以下顺序执行：push(1), push(2), push(3), push(4), pop() -&gt; 4,push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1示例 2：123输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]输出：false解释：1 不能在 2 之前弹出。 提示： 0 &lt;= pushed.length == popped.length &lt;= 1000 0 &lt;= pushed[i], popped[i] &lt; 1000 pushed是popped的排列。","text":"题目剑指Offer 31. 栈的压入弹出序列 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。 示例 1：12345输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]输出：true解释：我们可以按以下顺序执行：push(1), push(2), push(3), push(4), pop() -&gt; 4,push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1示例 2：123输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]输出：false解释：1 不能在 2 之前弹出。 提示： 0 &lt;= pushed.length == popped.length &lt;= 1000 0 &lt;= pushed[i], popped[i] &lt; 1000 pushed是popped的排列。 题解使用一个辅助栈来模拟压入弹出过程！如果匹配，那么辅助栈最后应该为空，否则返回false。 代码123456789101112131415class Solution &#123;public: bool validateStackSequences(vector&lt;int&gt;&amp; pushed, vector&lt;int&gt;&amp; popped) &#123; stack&lt;int&gt; simulate; int i = 0; for (int num : pushed) &#123; simulate.push(num); while (!simulate.empty() &amp;&amp; simulate.top() == popped[i]) &#123; ++i; simulate.pop(); &#125; &#125; return i == popped.size(); &#125;&#125;;","categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://wangtianyang.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://wangtianyang.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【LeetCode刷题笔记】剑指Offer30.包含min函数的栈","slug":"【LeetCode刷题笔记】剑指Offer30-包含min函数的栈","date":"2022-01-28T04:18:36.000Z","updated":"2023-01-06T13:41:11.713Z","comments":true,"path":"2022/01/28/【LeetCode刷题笔记】剑指Offer30-包含min函数的栈/","link":"","permalink":"https://wangtianyang.com/2022/01/28/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91%E5%89%91%E6%8C%87Offer30-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/","excerpt":"题目剑指Offer 30. 包含min函数的栈 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数在该栈中，调用min、push及pop的时间复杂度都是O(1)。 示例:12345678MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.min(); --&gt; 返回 -3.minStack.pop();minStack.top(); --&gt; 返回 0.minStack.min(); --&gt; 返回 -2. 提示： 各函数的调用总次数不超过20000次","text":"题目剑指Offer 30. 包含min函数的栈 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的min函数在该栈中，调用min、push及pop的时间复杂度都是O(1)。 示例:12345678MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.min(); --&gt; 返回 -3.minStack.pop();minStack.top(); --&gt; 返回 0.minStack.min(); --&gt; 返回 -2. 提示： 各函数的调用总次数不超过20000次 题解如果只是维护一个min变量，不能确定pop()以后是否会改变，因此得想办法将min与每次push的数结合，组成pair！ 代码12345678910111213141516171819202122232425262728293031323334353637class MinStack &#123;public: /** initialize your data structure here. */ int minN = INT_MAX; stack&lt;pair&lt;int, int&gt;&gt; res; MinStack() &#123; &#125; void push(int x) &#123; if (x &lt; minN) minN = x; res.push(make_pair(x, minN)); &#125; void pop() &#123; res.pop(); if (!res.empty()) minN = res.top().second; else minN = INT_MAX; &#125; int top() &#123; return res.top().first; &#125; int min() &#123; return minN; &#125;&#125;;/** * Your MinStack object will be instantiated and called as such: * MinStack* obj = new MinStack(); * obj-&gt;push(x); * obj-&gt;pop(); * int param_3 = obj-&gt;top(); * int param_4 = obj-&gt;min(); */","categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://wangtianyang.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://wangtianyang.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【LeetCode刷题笔记】剑指Offer26.树的子结构","slug":"【LeetCode刷题笔记】剑指Offer26-树的子结构","date":"2022-01-28T02:36:20.000Z","updated":"2023-01-06T13:41:30.276Z","comments":true,"path":"2022/01/28/【LeetCode刷题笔记】剑指Offer26-树的子结构/","link":"","permalink":"https://wangtianyang.com/2022/01/28/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91%E5%89%91%E6%8C%87Offer26-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/","excerpt":"题目剑指Offer 26. 树的子结构 输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构) B是A的子结构， 即 A中有出现和B相同的结构和节点值。 例如:给定的树 A:12345 3 / \\ 4 5 / \\ 1 2给定的树 B：123 4 / 1返回 true，因为B与A的一个子树拥有相同的结构和节点值。 示例 1：12输入：A = [1,2,3], B = [3,1]输出：false示例 2：12输入：A = [3,4,5,1,2], B = [4,1]输出：true 限制： 0 &lt;= 节点个数 &lt;= 10000","text":"题目剑指Offer 26. 树的子结构 输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构) B是A的子结构， 即 A中有出现和B相同的结构和节点值。 例如:给定的树 A:12345 3 / \\ 4 5 / \\ 1 2给定的树 B：123 4 / 1返回 true，因为B与A的一个子树拥有相同的结构和节点值。 示例 1：12输入：A = [1,2,3], B = [3,1]输出：false示例 2：12输入：A = [3,4,5,1,2], B = [4,1]输出：true 限制： 0 &lt;= 节点个数 &lt;= 10000 题解需要两个函数，第一个函数用来遍历A的节点，第二个函数用来判断B是否是A的子树。第二个函数需要进行递归操作，判断A和B当前的节点相不相同：如果相同，则继续递归，对比左右字节点；如果不同，则返回false。为什么不能只用一个函数囊括遍历和递归？因为只有一个函数的话无法判断B的当前节点是不是头节点，就无法确定是继续遍历还是返回false。 代码12345678910111213141516171819202122/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSubStructure(TreeNode* A, TreeNode* B) &#123; if (A == nullptr || B == nullptr) return false; return (recur(A, B) || isSubStructure(A-&gt;left, B) || isSubStructure(A-&gt;right, B)); &#125; bool recur(TreeNode* A, TreeNode* B) &#123; if (B == nullptr) return true; if (A == nullptr || A-&gt;val!=B-&gt;val) return false; return recur(A-&gt;left, B-&gt;left) &amp;&amp; recur(A-&gt;right, B-&gt;right); &#125;&#125;;","categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://wangtianyang.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://wangtianyang.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【LeetCode刷题笔记】剑指Offer20.表示数值的字符串","slug":"【LeetCode刷题笔记】剑指Offer20-表示数值的字符串","date":"2022-01-26T03:09:43.000Z","updated":"2023-01-06T13:41:37.681Z","comments":true,"path":"2022/01/26/【LeetCode刷题笔记】剑指Offer20-表示数值的字符串/","link":"","permalink":"https://wangtianyang.com/2022/01/26/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91%E5%89%91%E6%8C%87Offer20-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"题目剑指Offer 20. 表示数值的字符串 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。 数值（按顺序）可以分成以下几个部分： 若干空格 一个小数或者整数 （可选）一个&#39;e&#39;或&#39;E&#39;，后面跟着一个整数 若干空格 小数（按顺序）可以分成以下几个部分： （可选）一个符号字符（’+’ 或 ‘-‘） 下述格式之一： 至少一位数字，后面跟着一个点 ‘.’ 至少一位数字，后面跟着一个点 ‘.’ ，后面再跟着至少一位数字 一个点 ‘.’ ，后面跟着至少一位数字 整数（按顺序）可以分成以下几个部分： （可选）一个符号字符（’+’ 或 ‘-‘） 至少一位数字 部分数值列举如下： [&quot;+100&quot;, &quot;5e2&quot;, &quot;-123&quot;, &quot;3.1416&quot;, &quot;-1E-16&quot;, &quot;0123&quot;] 部分非数值列举如下： [&quot;12e&quot;, &quot;1a3.14&quot;, &quot;1.2.3&quot;, &quot;+-5&quot;, &quot;12e+5.4&quot;] 示例 1：12输入：s = &quot;0&quot;输出：true示例 2：12输入：s = &quot;e&quot;输出：false示例 3：12输入：s = &quot;.&quot;输出：false示例 4：12输入：s = &quot; .1 &quot;输出：true 提示： 1 &lt;= s.length &lt;= 20 s仅含英文字母（大写和小写），数字（0-9），加号&#39;+&#39;，减号&#39;-&#39;，空格&#39; &#39;或者点&#39;.&#39;。","text":"题目剑指Offer 20. 表示数值的字符串 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。 数值（按顺序）可以分成以下几个部分： 若干空格 一个小数或者整数 （可选）一个&#39;e&#39;或&#39;E&#39;，后面跟着一个整数 若干空格 小数（按顺序）可以分成以下几个部分： （可选）一个符号字符（’+’ 或 ‘-‘） 下述格式之一： 至少一位数字，后面跟着一个点 ‘.’ 至少一位数字，后面跟着一个点 ‘.’ ，后面再跟着至少一位数字 一个点 ‘.’ ，后面跟着至少一位数字 整数（按顺序）可以分成以下几个部分： （可选）一个符号字符（’+’ 或 ‘-‘） 至少一位数字 部分数值列举如下： [&quot;+100&quot;, &quot;5e2&quot;, &quot;-123&quot;, &quot;3.1416&quot;, &quot;-1E-16&quot;, &quot;0123&quot;] 部分非数值列举如下： [&quot;12e&quot;, &quot;1a3.14&quot;, &quot;1.2.3&quot;, &quot;+-5&quot;, &quot;12e+5.4&quot;] 示例 1：12输入：s = &quot;0&quot;输出：true示例 2：12输入：s = &quot;e&quot;输出：false示例 3：12输入：s = &quot;.&quot;输出：false示例 4：12输入：s = &quot; .1 &quot;输出：true 提示： 1 &lt;= s.length &lt;= 20 s仅含英文字母（大写和小写），数字（0-9），加号&#39;+&#39;，减号&#39;-&#39;，空格&#39; &#39;或者点&#39;.&#39;。 题解对于任何“给定字符串s，判断是否满足条件p”的命题都可以用确定有限状态自动机求解。 确定有限状态自动机${\\displaystyle {\\mathcal {A}}}$是由 一个非空有限的状态集合${\\displaystyle Q}$ 一个输入字母表${\\displaystyle \\Sigma }$ （非空有限的字符集合） 一个转移函数${\\displaystyle \\delta :Q\\times \\Sigma \\rightarrow Q}$ （例如：${\\displaystyle \\delta \\left(q,\\sigma \\right)=p,\\left(p,q\\in Q,\\sigma \\in \\Sigma \\right)}$） 一个开始状态${\\displaystyle s\\in Q}$ 一个接受状态的集合${\\displaystyle F\\subseteq Q}$ 所组成的5-元组。因此一个DFA可以写成这样的形式：${\\displaystyle {\\mathcal {A}}=\\left(Q,\\Sigma ,\\delta ,s,F\\right)}$。 首先确定状态集合： 起始空格 符号位 整数部分 左边无整数的小数点 左边有整数的小数点 小数部分 幂符号 指数部分的符号位 指数部分的整数 结尾空格 其中，1为开始状态，[3, 5, 6, 9, 10]为接受状态的集合，输入字母表为字符串中的字符，转移函数如下： 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112class Solution &#123;public: // 状态集合 enum State &#123; STATE_INITIAL, STATE_SIGN_INT, STATE_INTEGER, STATE_POINT_WITH_INTEGER, STATE_POINT_WITHOUT_INTEGER, STATE_FRACTION, STATE_EXP, STATE_SIGN_EXP, STATE_INTEGER_EXP, STATE_END &#125;; // 接受状态集合 set&lt;State&gt; endState&#123; STATE_INTEGER, STATE_POINT_WITH_INTEGER, STATE_FRACTION, STATE_INTEGER_EXP, STATE_END &#125;; // 输入字母表 enum CharType &#123; CHAR_SPACE, CHAR_INT, CHAR_SIGN, CHAR_EXP, CHAR_POINT, CHAR_WRONG &#125;; // 将字符转换为字母表 CharType toCharType(char c) &#123; if (c == &#x27; &#x27;) return CHAR_SPACE; if (c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) return CHAR_INT; if (c == &#x27;+&#x27; || c == &#x27;-&#x27;) return CHAR_SIGN; if (c == &#x27;e&#x27; || c == &#x27;E&#x27;) return CHAR_EXP; if (c == &#x27;.&#x27;) return CHAR_POINT; return CHAR_WRONG; &#125; // 状态转移函数 unordered_map&lt;State, unordered_map&lt;CharType, State&gt;&gt; transfer&#123; &#123;STATE_INITIAL, &#123; &#123;CHAR_SPACE, STATE_INITIAL&#125;, &#123;CHAR_SIGN, STATE_SIGN_INT&#125;, &#123;CHAR_POINT, STATE_POINT_WITHOUT_INTEGER&#125;, &#123;CHAR_INT, STATE_INTEGER&#125; &#125; &#125;, &#123;STATE_SIGN_INT, &#123; &#123;CHAR_INT, STATE_INTEGER&#125;, &#123;CHAR_POINT, STATE_POINT_WITHOUT_INTEGER&#125; &#125; &#125;, &#123;STATE_INTEGER, &#123; &#123;CHAR_POINT, STATE_POINT_WITH_INTEGER&#125;, &#123;CHAR_SPACE, STATE_END&#125;, &#123;CHAR_EXP, STATE_EXP&#125;, &#123;CHAR_INT, STATE_INTEGER&#125; &#125; &#125;, &#123;STATE_POINT_WITH_INTEGER, &#123; &#123;CHAR_SPACE, STATE_END&#125;, &#123;CHAR_INT, STATE_FRACTION&#125;, &#123;CHAR_EXP, STATE_EXP&#125; &#125; &#125;, &#123;STATE_POINT_WITHOUT_INTEGER, &#123; &#123;CHAR_INT, STATE_FRACTION&#125; &#125; &#125;, &#123;STATE_FRACTION, &#123; &#123;CHAR_INT, STATE_FRACTION&#125;, &#123;CHAR_SPACE, STATE_END&#125;, &#123;CHAR_EXP, STATE_EXP&#125; &#125; &#125;, &#123;STATE_EXP, &#123; &#123;CHAR_SIGN, STATE_SIGN_EXP&#125;, &#123;CHAR_INT, STATE_INTEGER_EXP&#125; &#125; &#125;, &#123;STATE_SIGN_EXP, &#123; &#123;CHAR_INT, STATE_INTEGER_EXP&#125; &#125; &#125;, &#123;STATE_INTEGER_EXP, &#123; &#123;CHAR_INT, STATE_INTEGER_EXP&#125;, &#123;CHAR_SPACE, STATE_END&#125; &#125; &#125;, &#123;STATE_END, &#123; &#123;CHAR_SPACE, STATE_END&#125; &#125; &#125; &#125;; bool isNumber(string s) &#123; State cur = STATE_INITIAL; for (char c : s) &#123; CharType ct = toCharType(c); if (transfer[cur].find(ct) == transfer[cur].end()) return false; cur = transfer[cur][ct]; &#125; return endState.find(cur) != endState.end(); &#125;&#125;;","categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://wangtianyang.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://wangtianyang.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【LeetCode刷题笔记】剑指Offer16.数值的整次方数","slug":"【LeetCode刷题笔记】剑指Offer16-数值的整次方数","date":"2022-01-25T12:54:56.000Z","updated":"2023-01-06T13:41:43.409Z","comments":true,"path":"2022/01/25/【LeetCode刷题笔记】剑指Offer16-数值的整次方数/","link":"","permalink":"https://wangtianyang.com/2022/01/25/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91%E5%89%91%E6%8C%87Offer16-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%AC%A1%E6%96%B9%E6%95%B0/","excerpt":"题目剑指Offer 16. 数值的整次方数 实现pow(x, n)，即计算x的n次幂函数。不得使用库函数，同时不需要考虑大数问题。 示例 1：12输入：x = 2.00000, n = 10输出：1024.00000示例 2：12输入：x = 2.10000, n = 3输出：9.26100示例 3：123输入：x = 2.00000, n = -2输出：0.25000解释：2-2 = 1/22 = 1/4 = 0.25 提示： -100.0 &lt; x &lt; 100.0 -231 &lt;= n &lt;= 231-1 -104 &lt;= xn &lt;= 104","text":"题目剑指Offer 16. 数值的整次方数 实现pow(x, n)，即计算x的n次幂函数。不得使用库函数，同时不需要考虑大数问题。 示例 1：12输入：x = 2.00000, n = 10输出：1024.00000示例 2：12输入：x = 2.10000, n = 3输出：9.26100示例 3：123输入：x = 2.00000, n = -2输出：0.25000解释：2-2 = 1/22 = 1/4 = 0.25 提示： -100.0 &lt; x &lt; 100.0 -231 &lt;= n &lt;= 231-1 -104 &lt;= xn &lt;= 104 题解快速幂法！！！快速幂法有两种解析角度：二进制角度对于任意十进制数n，有对应二进制$b_m…b_2b_1b_0$…，则： $n=1b_0+2b_1+4b_2+…+2^mb_m$; $x^n=x^{(1b_0+2b_1+4b_2+…+2^mb_m)}$; 因此，对于计算$x^n$，我们可以将其转换为两个子问题： 计算$x^1$，$x^2$，$x^4$，…，$x^{2^m}$的值； 计算二进制数$b_0$，$b_1$，$b_2$，…，$b_m$的值。 具体地，步骤如下： 首先，初始化res=1； 接着，判断当前位二进制$b_k$是否为一，即if (n&amp;1)，若为1，则res乘上$x^{2^k}$，即res *= x； 然后，将n右移一位（除以2），即n &gt;&gt; 1，并将x *= x。循环2、3步，最后输出res。 二分法角度$x^n=x^{n/2}+x^{n/2}=(x^2)^{n/2}$，如果想要保持整数幂，则分奇偶两种情况，我们假设向下取整为//： 若n为奇数，则$x^n=x*(x^2)^{n//2}$； 若n为偶数，则$x^n=(x^2)^{n//2}$。具体步骤同上。 代码1234567891011121314151617class Solution &#123;public: double myPow(double x, int n) &#123; long int m = n; if (n &lt; 0) &#123; x = 1/x; m = -m; // 这里要注意溢出 &#125; double res = 1; while (m &gt; 0) &#123; if (m &amp; 1) res *= x; x *= x; m /= 2; &#125; return res; &#125;&#125;;","categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://wangtianyang.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://wangtianyang.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【LeetCode刷题笔记】剑指Offer13.机器人的运动范围","slug":"【LeetCode刷题笔记】剑指Offer13-机器人的运动范围","date":"2022-01-25T04:18:06.000Z","updated":"2023-01-06T13:41:53.550Z","comments":true,"path":"2022/01/25/【LeetCode刷题笔记】剑指Offer13-机器人的运动范围/","link":"","permalink":"https://wangtianyang.com/2022/01/25/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91%E5%89%91%E6%8C%87Offer13-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/","excerpt":"题目剑指Offer 13. 机器人的运动范围 地上有一个m行n列的方格，从坐标[0,0]到坐标[m-1,n-1]。一个机器人从坐标[0, 0]的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格[35, 37]，因为3+5+3+7=18。但它不能进入方格[35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？ 示例 1：12输入：m = 2, n = 3, k = 1输出：3示例 2：12输入：m = 3, n = 1, k = 0输出：1 提示： 1 &lt;= n,m &lt;= 100 0 &lt;= k &lt;= 20","text":"题目剑指Offer 13. 机器人的运动范围 地上有一个m行n列的方格，从坐标[0,0]到坐标[m-1,n-1]。一个机器人从坐标[0, 0]的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格[35, 37]，因为3+5+3+7=18。但它不能进入方格[35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？ 示例 1：12输入：m = 2, n = 3, k = 1输出：3示例 2：12输入：m = 3, n = 1, k = 0输出：1 提示： 1 &lt;= n,m &lt;= 100 0 &lt;= k &lt;= 20 题解dfs+剪枝，用set记录节点，避免重复剪枝条件：1.当前节点已经经历过了 2.索引溢出 3.当前i/10 + i%10+ j/10 + j%10 &gt; k，则不用再向左或向右遍历 代码123456789101112131415161718class Solution &#123; set&lt;pair&lt;int, int&gt;&gt; visited;public: int movingCount(int m, int n, int k) &#123; dfs(0, 0, m, n, k); set&lt;pair&lt;int, int&gt;&gt; temp = visited; return visited.size(); &#125;private: void dfs(int i, int j, int m, int n, int k) &#123; if (visited.find(make_pair(i, j)) != visited.end() || i &lt; 0 || j &lt; 0 || i == m || j == n || i/10 + i%10+ j/10 + j%10 &gt; k) return; visited.insert(make_pair(i, j)); dfs(i+1, j, m, n, k); dfs(i, j+1, m, n, k); &#125;&#125;;","categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://wangtianyang.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://wangtianyang.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【LeetCode刷题笔记】剑指Offer12.矩阵中的路径","slug":"【LeetCode刷题笔记】剑指Offer12-矩阵中的路径","date":"2022-01-25T02:11:51.000Z","updated":"2023-01-06T13:41:59.283Z","comments":true,"path":"2022/01/25/【LeetCode刷题笔记】剑指Offer12-矩阵中的路径/","link":"","permalink":"https://wangtianyang.com/2022/01/25/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91%E5%89%91%E6%8C%87Offer12-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/","excerpt":"题目剑指Offer 12. 矩阵中的路径 给定一个m x n二维字符网格board和一个字符串单词word。如果word存在于网格中，返回true；否则，返回false。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 示例 1：12输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;输出：true示例 2：12输入：board = [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word = &quot;abcd&quot;输出：false 提示： 1 &lt;= board.length &lt;= 200 1 &lt;= board[i].length &lt;= 200 board和word仅由大小写英文字母组成","text":"题目剑指Offer 12. 矩阵中的路径 给定一个m x n二维字符网格board和一个字符串单词word。如果word存在于网格中，返回true；否则，返回false。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 示例 1：12输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;输出：true示例 2：12输入：board = [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word = &quot;abcd&quot;输出：false 提示： 1 &lt;= board.length &lt;= 200 1 &lt;= board[i].length &lt;= 200 board和word仅由大小写英文字母组成 题解深度优先搜索+剪枝 深度优先搜索(depth-first seach，DFS)在搜索到一个新的节点时，立即对该新节点进行遍历;因此遍历需要用先入后出的栈来实现，也可以通过与栈等价的递归来实现。对于树结构而言，由于总是对新节点调用遍历，因此看起来是向着“深”的方向前进。 剪枝顾名思义，就是删去一些不重要的节点，来减小计算或搜索的复杂度。 令i,j表示二维数组board的索引，k表示字符串word的索引，对于已经在路径中的元素，将其置空，即borad[i][j]=&#39;\\0&#39;； 设定初始值：遍历二维数组，并将i、j、k=0传入dfs()函数； 回溯：如果k==word.size()，即字符串全部匹配完，则return true；如果board[i][j]!=word[k]，即字符不匹配，则return false；如果board[i][j]==&#39;\\0&#39;，即当前位置已经在路径中，则return false；如果索引溢出，则return false；如果是其他情况，则进入第三步； 递归：进入这一步，代表board[i][j]==word[k]，那么令borad[i][j]=&#39;\\0&#39;，++k，board向上、下、左、右改变索引，将改变后的board、i、j、k传入dfs()函数进行下一次递归。 之后循环2、3步即可。 代码123456789101112131415161718192021class Solution &#123;public: bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; for (int i = 0; i &lt; board.size(); ++i) &#123; for (int j = 0; j &lt; board[0].size(); ++j) &#123; if (board[i][j] == word[0] &amp;&amp; dfs(board, word, i, j, 0)) return true; &#125; &#125; return false; &#125;private: bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word, int i, int j, int k) &#123; if (k == word.size()) return true; if (i &lt; 0 || i == board.size() || j &lt; 0 || j == board[0].size() || board[i][j] != word[k]) return false; board[i][j] = &#x27;\\0&#x27;; bool res = dfs(board, word, i+1, j, k+1) || dfs(board, word, i-1, j, k+1) || dfs(board, word, i, j+1, k+1) || dfs(board, word, i, j-1, k+1); board[i][j] = word[k]; return res; &#125;&#125;; 注意：dfs()参数设置要设定为引用，不然每次递归都要新建数组副本会超时。","categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://wangtianyang.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://wangtianyang.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【LeetCode刷题笔记】剑指Offer07.重建二叉树","slug":"【LeetCode刷题笔记】剑指Offer07-重建二叉树","date":"2022-01-24T09:02:55.000Z","updated":"2023-01-06T13:42:04.327Z","comments":true,"path":"2022/01/24/【LeetCode刷题笔记】剑指Offer07-重建二叉树/","link":"","permalink":"https://wangtianyang.com/2022/01/24/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91%E5%89%91%E6%8C%87Offer07-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"题目剑指Offer 07. 重建二叉树 输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。 假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 示例 1:12Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]Output: [3,9,20,null,null,15,7]示例 2:12Input: preorder = [-1], inorder = [-1]Output: [-1] 限制： 0 &lt;= 节点个数 &lt;= 5000","text":"题目剑指Offer 07. 重建二叉树 输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。 假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 示例 1:12Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]Output: [3,9,20,null,null,15,7]示例 2:12Input: preorder = [-1], inorder = [-1]Output: [-1] 限制： 0 &lt;= 节点个数 &lt;= 5000 题解 前序遍历：根结点 —-&gt; 左子树 —-&gt; 右子树 中序遍历：左子树—-&gt; 根结点 —-&gt; 右子树 后序遍历：左子树 —-&gt; 右子树 —-&gt; 根结点 层次遍历：只需按层次遍历即可 找到前序遍历数组preorder和中序遍历数组inorder的对应关系，就可以迭代。易见preorder[0]代表着树顶，那么inorder中对应的preorder[0]的左边所有元素都是左子树，右边的所有元素都是右子树。记inorder中preorder[0]对应的左边有 N 个元素，那么inorder[1]~inorder[N]之间的元素也是左子树，inorder[N]之后的元素为右子树。将对应的子序列作为新的参数进行迭代，即可得到完整二叉树。 代码1234567891011121314151617181920212223242526272829/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; if (!preorder.size()) return NULL; int head = preorder[0]; TreeNode* x = new TreeNode(head); int count = 0; for (int num : inorder) &#123; if (num == head) break; ++count; &#125; vector&lt;int&gt; new_left_preorder(preorder.begin()+1, preorder.begin()+count+1); vector&lt;int&gt; new_right_preorder(preorder.begin()+count+1, preorder.end()); vector&lt;int&gt; new_left_inorder(inorder.begin(), inorder.begin()+count); vector&lt;int&gt; new_right_inorder(inorder.begin()+count+1, inorder.end()); x -&gt; left = buildTree(new_left_preorder, new_left_inorder); x -&gt; right = buildTree(new_right_preorder, new_right_inorder); return x; &#125;&#125;;","categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://wangtianyang.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://wangtianyang.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【LeetCode刷题笔记】剑指Offer04.二维数组中的查找","slug":"【LeetCode刷题笔记】剑指Offer04-二维数组中的查找","date":"2022-01-24T07:53:08.000Z","updated":"2023-01-06T13:42:17.143Z","comments":true,"path":"2022/01/24/【LeetCode刷题笔记】剑指Offer04-二维数组中的查找/","link":"","permalink":"https://wangtianyang.com/2022/01/24/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%91%E5%89%91%E6%8C%87Offer04-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/","excerpt":"题目剑指Offer 04. 二维数组中的查找 在一个n * m的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例:123456789101112现有矩阵 matrix 如下：[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]]给定 target = 5，返回 true。给定 target = 20，返回 false。 限制： 0 &lt;= n &lt;= 1000 0 &lt;= m &lt;= 1000","text":"题目剑指Offer 04. 二维数组中的查找 在一个n * m的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例:123456789101112现有矩阵 matrix 如下：[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]]给定 target = 5，返回 true。给定 target = 20，返回 false。 限制： 0 &lt;= n &lt;= 1000 0 &lt;= m &lt;= 1000 题解选对查找的起点很重要！！！因为数组从左往右递增、从上往下递增的特性，每当访问一个元素，我们可以排除数组中的部分元素。我们选定右上角作为起点，有以下三种情况： 如果当前元素等于目标值，返回true； 如果当前元素大于目标值，那么它下面的元素都大于目标值，索引往左移一位； 如果当前元素小于目标值，那么它左边的元素都小于目标值，索引往下移一位。 代码1234567891011121314class Solution &#123;public: bool findNumberIn2DArray(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; if (!matrix.size()) return 0; int n = matrix.size(), m = matrix[0].size(); int i = 0, j = m - 1; while (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; n &amp;&amp; j &lt; m) &#123; if (matrix[i][j] == target) return true; if (matrix[i][j] &lt; target) i++; else j--; &#125; return false; &#125;&#125;;","categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://wangtianyang.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://wangtianyang.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【LeetCode刷题笔记】1332.删除回文子序列","slug":"【LeetCode刷题笔记】1332-删除回文子序列","date":"2022-01-22T02:18:08.000Z","updated":"2023-01-06T13:42:29.473Z","comments":true,"path":"2022/01/22/【LeetCode刷题笔记】1332-删除回文子序列/","link":"","permalink":"https://wangtianyang.com/2022/01/22/%E3%80%90LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E3%80%911332-%E5%88%A0%E9%99%A4%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/","excerpt":"题目1332.删除回文子序列 给你一个字符串s，它仅由字母&#39;a&#39;和&#39;b&#39;组成。每一次删除操作都可以从s中删除一个回文子序列。 返回删除给定字符串中所有字符（字符串为空）的最小删除次数。 「子序列」定义：如果一个字符串可以通过删除原字符串某些字符而不改变原字符顺序得到，那么这个字符串就是原字符串的一个子序列。 「回文」定义：如果一个字符串向后和向前读是一致的，那么这个字符串就是一个回文。 示例 1：123输入：s = &quot;ababa&quot;输出：1解释：字符串本身就是回文序列，只需要删除一次。示例 2：1234输入：s = &quot;abb&quot;输出：2解释：&quot;abb&quot; -&gt; &quot;bb&quot; -&gt; &quot;&quot;. 先删除回文子序列 &quot;a&quot;，然后再删除 &quot;bb&quot;。示例 3：1234输入：s = &quot;baabb&quot;输出：2解释：&quot;baabb&quot; -&gt; &quot;b&quot; -&gt; &quot;&quot;. 先删除回文子序列 &quot;baab&quot;，然后再删除 &quot;b&quot;。 提示： 1 &lt;= s.length &lt;= 1000 s仅包含字母&#39;a&#39;和&#39;b&#39;","text":"题目1332.删除回文子序列 给你一个字符串s，它仅由字母&#39;a&#39;和&#39;b&#39;组成。每一次删除操作都可以从s中删除一个回文子序列。 返回删除给定字符串中所有字符（字符串为空）的最小删除次数。 「子序列」定义：如果一个字符串可以通过删除原字符串某些字符而不改变原字符顺序得到，那么这个字符串就是原字符串的一个子序列。 「回文」定义：如果一个字符串向后和向前读是一致的，那么这个字符串就是一个回文。 示例 1：123输入：s = &quot;ababa&quot;输出：1解释：字符串本身就是回文序列，只需要删除一次。示例 2：1234输入：s = &quot;abb&quot;输出：2解释：&quot;abb&quot; -&gt; &quot;bb&quot; -&gt; &quot;&quot;. 先删除回文子序列 &quot;a&quot;，然后再删除 &quot;bb&quot;。示例 3：1234输入：s = &quot;baabb&quot;输出：2解释：&quot;baabb&quot; -&gt; &quot;b&quot; -&gt; &quot;&quot;. 先删除回文子序列 &quot;baab&quot;，然后再删除 &quot;b&quot;。 提示： 1 &lt;= s.length &lt;= 1000 s仅包含字母&#39;a&#39;和&#39;b&#39; 题解子序列和子串并不相同！！！ 例：对于字符串“1234567890”，它的子串为: [“123”, “123456”, “78”, …]，子串为字符串中连续字符组成的串；它的子序列为: [“123”, “136”, “125”]，子序列不要求连续！所以对于本题，在只包含’a’、’b’两种字符的情况下，最多只需要删除两次：即先把’a’删完，再删’b’。因此分为下面两种情况： 如果字符串本身是回文串，则仅需删除一次； 否则，return 2; 代码12345678910111213141516171819class Solution &#123;public: int removePalindromeSub(string s) &#123; string::iterator left = s.begin() + s.size()/2 - 1, right = left; if (s.size() % 2) &#123; right += 2; &#125; else &#123; right += 1; &#125; while (left != s.begin() - 1) &#123; if (*left != *right) &#123; return 2; &#125; --left; ++right; &#125; return 1; &#125;&#125;;","categories":[{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://wangtianyang.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://wangtianyang.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【C++】STL容器总结","slug":"【C-】STL容器总结","date":"2022-01-19T05:34:04.000Z","updated":"2023-01-06T13:44:40.576Z","comments":true,"path":"2022/01/19/【C-】STL容器总结/","link":"","permalink":"https://wangtianyang.com/2022/01/19/%E3%80%90C-%E3%80%91STL%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93/","excerpt":"STL简介 STL（Standard Template Library），即标准模板库，是一个高效的C++程序库，包含了诸多常用的基本数据结构和基本算法。为广大C++程序员们提供了一个可扩展的应用框架，高度体现了软件的可复用性。 从逻辑层次来看，在STL中体现了泛型化程序设计的思想（generic programming）。在这种思想里，大部分基本算法被抽象，被泛化，独立于与之对应的数据结构，用于以相同或相近的方式处理各种不同情形。 从实现层次看，整个STL是以一种类型参数化（type parameterized）的方式实现的，基于模板（template）。","text":"STL简介 STL（Standard Template Library），即标准模板库，是一个高效的C++程序库，包含了诸多常用的基本数据结构和基本算法。为广大C++程序员们提供了一个可扩展的应用框架，高度体现了软件的可复用性。 从逻辑层次来看，在STL中体现了泛型化程序设计的思想（generic programming）。在这种思想里，大部分基本算法被抽象，被泛化，独立于与之对应的数据结构，用于以相同或相近的方式处理各种不同情形。 从实现层次看，整个STL是以一种类型参数化（type parameterized）的方式实现的，基于模板（template）。 STL有六大组件，但主要包含容器、迭代器和算法三个部分。 容器（Containers）：用来管理某类对象的集合。每一种容器都有其优点和缺点，所以为了应付程序中的不同需求，STL 准备了七种基本容器类型。 迭代器（Iterators）：用来在一个对象集合的元素上进行遍历动作。这个对象集合或许是个容器，或许是容器的一部分。每一种容器都提供了自己的迭代器，而这些迭代器了解该种容器的内部结构。 算法（Algorithms）：用来处理对象集合中的元素，比如 Sort，Search，Copy，Erase 那些元素。通过迭代器的协助，我们只需撰写一次算法，就可以将它应用于任意容器之上，这是因为所有容器的迭代器都提供一致的接口。STL 的基本观念就是将数据和操作分离。数据由容器进行管理，操作则由算法进行，而迭代器在两者之间充当粘合剂，使任何算法都可以和任何容器交互运作。 容器（Containers）容器用来管理某类对象。为了应付程序中的不同需求，STL 准备了两类共七种基本容器类型： 序列式容器（Sequence containers），此为可序群集，其中每个元素均有固定位置—取决于插入时机和地点，和元素值无关。如果你以追加方式对一个群集插入六个元素，它们的排列次序将和插入次序一致。STL提供了三个序列式容器：向量（vector）、双端队列（deque）、列表（list），此外你也可以把 string 和 array 当做一种序列式容器。 关联式容器（Associative containers），此为已序群集，元素位置取决于特定的排序准则以及元素值，和插入次序无关。如果你将六个元素置入这样的群集中，它们的位置取决于元素值，和插入次序无关。STL提供了四个关联式容器：集合（set）、多重集合（multiset）、映射（map）和多重映射（multimap）。示意图如下：vector（向量）vector（向量）: 是一种序列式容器，事实上和数组差不多，但它比数组更优越。一般来说数组不能动态拓展，因此在程序运行的时候不是浪费内存，就是造成越界。而 vector 正好弥补了这个缺陷，当内存空间不够时，需要重新申请一块足够大的内存并进行内存的拷贝。特点 拥有一段连续的内存空间，因此它能非常好的支持随机访问，即[]操作符和.at()，随机访问快。（优点） 当向其头部或中间插入或删除元素时，为了保持原本的相对次序，插入或删除点之后的所有元素都必须移动，所以插入或删除的效率比较低。（缺点） 在后面插入删除元素最快，此时一般不需要移动内存。（优点）总结：相当于可拓展的数组（动态数组），随机访问快，在头部和中间插入或删除效率低，但在尾部插入或删除效率高。适用场景适用于对象简单，变化较小，并且频繁随机访问的场景。迭代器 开始指针：vec.begin(); 末尾指针：vec.end(); // 指向最后一个元素的下一个位置 指向常量的开始指针：vec.cbegin(); // 意思就是不能通过这个指针来修改所指的内容，但还是可以通过其他方式修改的，而且指针也是可以移动的。 指向常量的末尾指针：vec.cend();1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main(int argc, char* argv[])&#123; // Create and populate the vector vector&lt;int&gt; vecTemp; for (int i = 0; i&lt;6; i++) &#123; vecTemp.push_back(i); &#125; // Display contents of vector cout &lt;&lt;&quot;Original deque: &quot;; vector&lt;int&gt;::iterator it; for (it = vecTemp.begin(); it!=vecTemp.end(); it++) &#123; cout &lt;&lt;*it &lt;&lt;&quot; &quot;; &#125; return 0;&#125;/*输出结果：Original deque: 0 1 2 3 4 5*/ 初始化使用之前必须加相应容器的头文件：1#include &lt;vector&gt; // vector属于std命名域的，因此需要通过命名限定，例如using std::vector; 定义的实现代码如下：12345vector&lt;int&gt; a; // 定义一个int类型的向量avector&lt;int&gt; a(10); // 定义一个int类型的向量a，并设置初始大小为10vector&lt;int&gt; a(10, 1); // 定义一个int类型的向量a，并设置初始大小为10且初始值都为1vector&lt;int&gt; b(a); // 定义并用向量a初始化向量bvector&lt;int&gt; b(a.begin(), a.begin()+3); // 将a向量中从第0个到第2个(共3个)作为向量b的初始值 除此之外，还可以直接使用数组来初始化向量：123456int n[] = &#123;1, 2, 3, 4, 5&#125; ;// 将数组n的前5个元素作为向量a的初值// 说明：当然不包括arr[4]元素，末尾指针都是指结束元素的下一个元素，// 这个主要是为了和vec.end()指针统一。vector&lt;int&gt; a(n, n+5) ; vector&lt;int&gt; a(&amp;n[1], &amp;n[4]) ; // 将n[1]、n[2]、n[3]作为向量a的初值 函数 容器容量：vec.capacity(); // 指在不分配更多内存的情况下，容器可以保存的最多元素个数，即预分配的内存空间，与 size() 不同 容器大小：vec.size(); // 指它实际包含的元素个数 容器最大容量：vec.max_size(); 更改容器大小：vec.resize(); 容器判空：vec.empty(); 末尾添加元素：vec.push_back(const T&amp; x); 任意位置插入一个元素：vec.insert(iterator it, const T&amp; x); 任意位置插入 n 个相同元素：vec.insert(iterator it, int n, const T&amp; x); 插入另一个向量的 [forst,last] 间的数据：vec.insert(iterator it, iterator first, iterator last); 末尾删除元素：vec.pop_back(); 任意位置删除一个元素：vec.erase(iterator it); 删除 [first,last] 之间的元素：vec.erase(iterator first, iterator last); 清空所有元素：vec.clear(); 下标访问：vec[1]; // 并不会检查是否越界 at 方法访问：vec.at(1); // 以上两者的区别就是 at 会检查是否越界，是则抛出 out of range 异常 访问第一个元素：vec.front(); 访问最后一个元素：vec.back(); 返回一个指针：int* p = vec.data(); // 可行的原因在于 vector 在内存中就是一个连续存储的数组，所以可以返回一个指针指向这个数组。这是是 C++11 的特性。 多个元素赋值：vec.assign(int nSize, const T&amp; x); // 类似于初始化时用数组进行赋值12vector&lt;int&gt; vec;vec.assign(3, 1); // vec:[1 1 1] 交换两个同类型容器的元素：swap(vector&amp;);1vec1.swap(vec2); // 交换vec1和vec2的元素 算法 遍历元素1234567vector&lt;int&gt;::iterator it;for (it = vec.begin(); it != vec.end(); it++) cout &lt;&lt; *it &lt;&lt; endl;// 或者for (int i = 0; i &lt; vec.size(); i++) &#123; cout &lt;&lt; vec.at(i) &lt;&lt; endl;&#125; 元素翻转12#include &lt;algorithm&gt;reverse(vec.begin(), vec.end()); 元素排序1234567891011#include &lt;algorithm&gt;sort(vec.begin(), vec.end()); // 采用的是从小到大的排序// 如果想从大到小排序，可以采用先排序后反转的方式，也可以采用下面方法:// 自定义从大到小的比较器，用来改变排序方式bool Comp(const int&amp; a, const int&amp; b) &#123; return a &gt; b;&#125;sort(vec.begin(), vec.end(), Comp); 例子以下例子针对整型定义了一个 vector，插入 6 个元素，然后打印所有元素：1234567891011121314151617#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main(int argc, char* argv[])&#123; vector&lt;int&gt; vecTemp; for (int i = 0; i&lt;6; i++) vecTemp.push_back(i); for (int i = 0; i&lt;vecTemp.size(); i++) cout &lt;&lt; vecTemp[i] &lt;&lt;&quot; &quot;; // 输出：0 1 2 3 4 5 return 0;&#125; deque（双端队列）deque（double-ended queue）是双向开口的连续内存空间（动态将多个连续空间通过指针数组接合在一起），随时可以增加一段新的空间。deque的最大任务就是在这些分段的连续空间上，维护其整体连续的假象，并提供随机存取的接口。 特点 一旦要在 deque 的头部和尾部增加新空间，便配置一段定量连续空间，串在整个 deque 的头部或尾部，因此不论在头部或尾部插入元素都十分迅速。 (优点） 在中间部分安插元素则比较费时，因为必须移动其它元素。（缺点） deque 是 list 和 vector 的折中方案。兼有 list 的优点，也有 vector 随机访问效率高的优点。总结：支持随机访问，但效率没有 vector 高，在头部和尾部插入或删除效率高，但在中间插入或删除效率低。适用场景适用于既要频繁随机访问，又要关心两端数据的插入与删除的场景。迭代器 开始迭代器指针：deq.begin(); 末尾迭代器指针：deq.end(); // 指向最后一个元素的下一个位置 指向常量的开始迭代器指针：deq.cbegin(); // 意思就是不能通过这个指针来修改所指的内容，但还是可以通过其他方式修改的，而且指针也是可以移动的。 指向常量的末尾迭代器指针：deq.cend(); 反向迭代器指针，指向最后一个元素：deq.rbegin(); 反向迭代器指针，指向第一个元素的前一个元素：deq.rend();1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;deque&gt;using namespace std；int main(int argc, char* argv[])&#123; // Create and populate the deque deque&lt;int&gt; dequeTemp; for (int i = 0; i&lt;6; i++) &#123; dequeTemp.push_back(i); &#125; // Display contents of deque cout &lt;&lt;&quot;Original deque: &quot;; deque&lt;int&gt;::iterator it; for (it = dequeTemp.begin(); it != dequeTemp.end(); it++) &#123; cout &lt;&lt;*it &lt;&lt;&quot; &quot;; &#125; cout &lt;&lt;endl; return 0;&#125;/*输出结果：Original deque: 0 1 2 3 4 5*/ 初始化使用之前必须加相应容器的头文件：1#include &lt;deque&gt; // deque属于std命名域的，因此需要通过命名限定，例如using std::deque; 定义的实现代码如下：12345deque&lt;int&gt; a; // 定义一个int类型的双端队列adeque&lt;int&gt; a(10); // 定义一个int类型的双端队列a，并设置初始大小为10deque&lt;int&gt; a(10, 1); // 定义一个int类型的双端队列a，并设置初始大小为10且初始值都为1deque&lt;int&gt; b(a); // 定义并用双端队列a初始化双端队列bdeque&lt;int&gt; b(a.begin(), a.begin()+3); // 将双端队列a中从第0个到第2个(共3个)作为双端队列b的初始值 除此之外，还可以直接使用数组来初始化向量：123456int n[] = &#123; 1, 2, 3, 4, 5 &#125;;// 将数组n的前5个元素作为双端队列a的初值// 说明：当然不包括arr[4]元素，末尾指针都是指结束元素的下一个元素，// 这个主要是为了和deque.end()指针统一。deque&lt;int&gt; a(n, n + 5); deque&lt;int&gt; a(&amp;n[1], &amp;n[4]); // 将n[1]、n[2]、n[3]作为双端队列a的初值 函数 容器大小：deq.size(); 容器最大容量：deq.max_size(); 更改容器大小：deq.resize(); 容器判空：deq.empty(); 减少容器大小到满足元素所占存储空间的大小：deq.shrink_to_fit(); 头部添加元素：deq.push_front(const T&amp; x); 末尾添加元素：deq.push_back(const T&amp; x); 任意位置插入一个元素：deq.insert(iterator it, const T&amp; x); 任意位置插入 n 个相同元素：deq.insert(iterator it, int n, const T&amp; x); 插入另一个向量的 [forst,last] 间的数据：deq.insert(iterator it, iterator first, iterator last); 头部删除元素：deq.pop_front(); 末尾删除元素：deq.pop_back(); 任意位置删除一个元素：deq.erase(iterator it); 删除 [first,last] 之间的元素：deq.erase(iterator first, iterator last); 清空所有元素：deq.clear(); 下标访问：deq[1]; // 并不会检查是否越界 at 方法访问：deq.at(1); // 以上两者的区别就是 at 会检查是否越界，是则抛出 out of range 异常 访问第一个元素：deq.front(); 访问最后一个元素：deq.back(); 多个元素赋值：deq.assign(int nSize, const T&amp; x); // 类似于初始化时用数组进行赋值 交换两个同类型容器的元素：swap(deque&amp;);算法 遍历元素1234567deque&lt;int&gt;::iterator it;for (it = deq.begin(); it != deq.end(); it++) cout &lt;&lt; *it &lt;&lt; endl;// 或者for (int i = 0; i &lt; deq.size(); i++) &#123; cout &lt;&lt; deq.at(i) &lt;&lt; endl;&#125; 元素翻转12#include &lt;algorithm&gt;reverse(deq.begin(), deq.end()); 元素排序12345678910#include &lt;algorithm&gt;sort(deq.begin(), deq.end()); // 采用的是从小到大的排序// 如果想从大到小排序，可以采用先排序后反转的方式，也可以采用下面方法:// 自定义从大到小的比较器，用来改变排序方式bool Comp(const int&amp; a, const int&amp; b) &#123; return a &gt; b;&#125;sort(deq.begin(), deq.end(), Comp); 例子以下例子声明了一个浮点类型的 deque，并在容器尾部插入 6 个元素，最后打印出所有元素：1234567891011121314151617#include &lt;iostream&gt;#include &lt;deque&gt;using namespace std;int main(int argc, char* argv[])&#123; deque&lt;float&gt; dequeTemp; for (int i = 0; i&lt;6; i++) dequeTemp.push_back(i); for (int i = 0; i&lt;dequeTemp.size(); i++) cout &lt;&lt; dequeTemp[i] &lt;&lt; &quot; &quot;; // 输出：0 1 2 3 4 5 return 0;&#125; 总结可以看到，deque 与 vector 的用法基本一致，除了以下几处不同： deque 没有 capacity() 函数，而 vector 有； deque 有 push_front() 和 pop_front() 函数，而 vector 没有； deque 没有 data() 函数，而 vector 有。 list（列表）List 由双向链表（doubly linked list）实现而成，元素存放在堆中，每个元素都是放在一块内存中。没有空间预留习惯，所以每分配一个元素都会从内存中分配，每删除一个元素都会释放它占用的内存。 特点 内存空间可以是不连续的，通过指针来进行数据的访问，这个特点使得它的随机存取变得非常没有效率，因此它没有提供 [] 操作符的重载。（缺点） 由于链表的特点，在任意位置的插入和删除效率都较高。（优点） 只支持首尾两个元素的直接存取，想获取其他元素（访问时间一样），则需要遍历链表。（缺点）总结：不支持随机访问，在任意位置的插入和删除效率都较高。适用场景适用于经常进行插入和删除操作并且不经常随机访问的场景。迭代器 开始迭代器指针：lst.begin(); 末尾迭代器指针：lst.end(); // 指向最后一个元素的下一个位置 指向常量的开始迭代器指针：lst.cbegin(); // 意思就是不能通过这个指针来修改所指的内容，但还是可以通过其他方式修改的，而且指针也是可以移动的。 指向常量的末尾迭代器指针：lst.cend(); 反向迭代器指针，指向最后一个元素：lst.rbegin(); 反向迭代器指针，指向第一个元素的前一个元素：lst.rend();123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;list&gt;using namespace std;int main(int argc, char* argv[])&#123; // Create and populate the list list&lt;int&gt; listTemp; for (int i = 0; i&lt;6; i++) &#123; listTemp.push_back(i); &#125; // Display contents of list cout &lt;&lt; &quot;Original list: &quot;; list&lt;int&gt;::iterator it; for (it = listTemp.begin(); it != listTemp.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; // Insert five 9 into the list list&lt;int&gt;::iterator itStart = listTemp.begin(); listTemp.insert(itStart,5,9); // Display the result cout &lt;&lt; &quot;Result of list: &quot;; for (it = listTemp.begin(); it != listTemp.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; return 0;&#125;/*输出结果：Original list: 0 1 2 3 4 5Result of list: 9 9 9 9 9 0 1 2 3 4 5*/ 初始化 使用之前必须加相应容器的头文件：1#include &lt;list&gt; // list属于std命名域的，因此需要通过命名限定，例如using std::list; 定义的代码如下：12345list&lt;int&gt; a; // 定义一个int类型的列表alist&lt;int&gt; a(10); // 定义一个int类型的列表a，并设置初始大小为10list&lt;int&gt; a(10, 1); // 定义一个int类型的列表a，并设置初始大小为10且初始值都为1list&lt;int&gt; b(a); // 定义并用列表a初始化列表bdeque&lt;int&gt; b(a.begin(), ++a.end()); // 将列表a中的第1个元素作为列表b的初始值 除此之外，还可以直接使用数组来初始化向量：12int n[] = &#123; 1, 2, 3, 4, 5 &#125;;list&lt;int&gt; a(n, n + 5); // 将数组n的前5个元素作为列表a的初值 函数 容器大小：lst.size(); 容器最大容量：lst.max_size(); 更改容器大小：lst.resize(); 容器判空：lst.empty(); 头部添加元素：lst.push_front(const T&amp; x); 末尾添加元素：lst.push_back(const T&amp; x); 任意位置插入一个元素：lst.insert(iterator it, const T&amp; x);1lst.insert(lst.begin(), 2); // 在第一个元素前插入一个2 任意位置插入 n 个相同元素：lst.insert(iterator it, int n, const T&amp; x);1lst.insert(lst.begin(), 3, 9); // 在第一个元素前插入3个9 插入另一个向量的 [forst,last] 间的数据：lst.insert(iterator it, iterator first, iterator last);1lst.insert(lst.begin(), lst2.begin(), ++lst2.begin()); 头部删除元素：lst.pop_front(); 末尾删除元素：lst.pop_back(); 任意位置删除一个元素：lst.erase(iterator it); 删除 [first,last] 之间的元素：lst.erase(iterator first, iterator last); 清空所有元素：lst.clear(); 访问第一个元素：lst.front(); 访问最后一个元素：lst.back(); 多个元素赋值：lst.assign(int nSize, const T&amp; x); // 类似于初始化时用数组进行赋值 交换两个同类型容器的元素：swap(list&amp;, list&amp;); 或 lst.swap(list&amp;); 合并两个列表的元素（默认升序排列）：lst.merge(); 在任意位置拼接入另一个list：lst.splice(iterator it, list&amp;); 删除容器中相邻的重复元素：lst.unique();算法 遍历元素123list&lt;int&gt;::iterator it;for (it = lst.begin(); it != lst.end(); it++) cout &lt;&lt; *it &lt;&lt; endl; 元素翻转12#include &lt;algorithm&gt;reverse(lst.begin(), lst.end()); 元素排序1234567891011#include &lt;algorithm&gt;sort(lst.begin(), lst.end()); // 采用的是从小到大的排序// 如果想从大到小排序，可以采用先排序后反转的方式，也可以采用下面方法:// 自定义从大到小的比较器，用来改变排序方式bool Comp(const int&amp; a, const int&amp; b) &#123; return a &gt; b;&#125;sort(lst.begin(), lst.end(), Comp); 例子以下例子产生一个空 list，准备放置字符，然后将 ‘a’ 至 ‘z’ 的所有字符插入其中，利用循环每次打印并移除集合的第一个元素，从而打印出所有元素：1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;list&gt;using namespace std;int main(int argc, char* argv[])&#123; list&lt;char&gt; listTemp; for (char c = &#x27;a&#x27;; c &lt;= &#x27;z&#x27;; ++c) listTemp.push_back(c); while (!listTemp.empty()) &#123; cout &lt;&lt;listTemp.front() &lt;&lt; &quot; &quot;; listTemp.pop_front(); &#125; return 0;&#125; 总结可以看到，list 与 vector、deque 的用法基本一致，除了以下几处不同： list 为双向迭代器，故不支持it+=i； list 不支持下标访问和at方法访问。 set（集合）set（集合）顾名思义，就是数学上的集合——每个元素最多只出现一次，并且 set 中的元素已经从小到大排好序。 特点 使用红黑树实现，其内部元素依据其值自动排序，每个元素值只能出现一次，不允许重复。 每次插入值的时候，都需要调整红黑树，效率有一定影响。（缺点） map 和 set 的插入或删除效率比用其他序列容器高，因为对于关联容器来说，不需要做内存拷贝和内存移动。（优点）总结：由红黑树实现，其内部元素依据其值自动排序，每个元素值只能出现一次，不允许重复，且插入和删除效率比用其他序列容器高。适用场景适用于经常查找一个元素是否在某集合中且需要排序的场景。迭代 开始迭代器指针：st.begin(); 末尾迭代器指针：st.end(); // 指向最后一个元素的下一个位置 指向常量的开始迭代器指针：st.cbegin(); // 意思就是不能通过这个指针来修改所指的内容，但还是可以通过其他方式修改的，而且指针也是可以移动的。 指向常量的末尾迭代器指针：lst.cend(); 反向迭代器指针，指向最后一个元素：st.rbegin(); 反向迭代器指针，指向第一个元素的前一个元素：st.rend(); 返回最后一个 key&lt;=keyElem 元素的迭代器：st.lower_bound(keyElem); 返回第一个 key&gt;keyElem 元素的迭代器：st.upper_bound(keyElem); 返回容器中 key 与 keyElem 相等的上下限的两个迭代器，这两个迭代器被放在对组（pair）中：st.equal_range(keyElem);1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;int main(int argc, char* argv[])&#123; // Create and populate the set set&lt;char&gt; setTemp; for (int i = 0; i&lt;6; i++) &#123; setTemp.insert(&#x27;F&#x27;-i); &#125; // Display contents of set cout &lt;&lt;&quot;Original set: &quot;; set&lt;char&gt;::iterator it; for (it = setTemp.begin(); it != setTemp.end(); it++) &#123; cout &lt;&lt;*it &lt;&lt;&quot; &quot;; &#125; cout &lt;&lt;endl; return 0;&#125;/*输出结果：Original set: A B C D E F*/ 初始化 使用之前必须加相应容器的头文件：1#include &lt;set&gt; // set属于std命名域的，因此需要通过命名限定，例如using std::set; 定义的代码如下：12345set&lt;int&gt; a; // 定义一个int类型的集合a// set&lt;int&gt; a(10); // error，未定义这种构造函数// set&lt;int&gt; a(10, 1); // error，未定义这种构造函数set&lt;int&gt; b(a); // 定义并用集合a初始化集合bset&lt;int&gt; b(a.begin(), a.end()); // 将集合a中的所有元素作为集合b的初始值 除此之外，还可以直接使用数组来初始化向量：12int n[] = &#123; 1, 2, 3, 4, 5 &#125;;list&lt;int&gt; a(n, n + 5); // 将数组n的前5个元素作为集合a的初值 函数 容器大小：st.size(); 容器最大容量：st.max_size(); 容器判空：st.empty(); 查找键 key 的元素个数：st.count(key); 在容器中插入元素：st.insert(const T&amp; x); 任意位置插入一个元素：st.insert(iterator it, const T&amp; x); 删除容器中值为 elem 的元素：st.erase(const T&amp; elem); 删除it迭代器所指的元素：st.erase(iterator it); 删除区间 [first,last] 之间的所有元素：st.erase(iterator first, iterator last); 清空所有元素：st.clear(); 查找键 key 是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end()：st.find(key); 交换两个同类型容器的元素：swap(set&amp;, set&amp;);或lst.swap(set&amp;);算法 遍历元素123set&lt;int&gt;::iterator it;for (it = st.begin(); it != st.end(); it++) cout &lt;&lt; *it &lt;&lt; endl; 例子下面的例子演示 set（集合）的两个特点：12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;int main(int argc, char* argv[])&#123; set&lt;int&gt; setTemp; setTemp.insert(3); setTemp.insert(1); setTemp.insert(2); setTemp.insert(1); set&lt;int&gt;::iterator it; for (it = setTemp.begin(); it != setTemp.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 输出结果：1 2 3。一共插入了 4 个数，但是集合中只有 3 个数并且是有序的，可见之前说过的 set 集合的两个特点，有序和不重复。当 set 集合中的元素为结构体时，该结构体必须实现运算符 ‘&lt;’ 的重载：12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;string&gt;using namespace std;struct People&#123; string name; int age; bool operator &lt;(const People p) const &#123; return age &lt; p.age; &#125;&#125;;int main(int argc, char* argv[])&#123; set&lt;People&gt; setTemp; setTemp.insert(&#123;&quot;张三&quot;,14&#125;); setTemp.insert(&#123; &quot;李四&quot;, 16 &#125;); setTemp.insert(&#123; &quot;隔壁老王&quot;, 10 &#125;); set&lt;People&gt;::iterator it; for (it = setTemp.begin(); it != setTemp.end(); it++) &#123; printf(&quot;姓名：%s 年龄：%d\\n&quot;, (*it).name.c_str(), (*it).age); &#125; return 0;&#125;/*输出结果姓名：王二麻子 年龄：10姓名：张三 年龄：14姓名：李四 年龄：16 */ 可以看到结果是按照年龄由小到大的顺序排列。另外 string 要使用c_str()转换一下，否则打印出的是乱码。另外 Multiset 和 set 相同，只不过它允许重复元素，也就是说 multiset 可包括多个数值相同的元素。这里不再做过多介绍。总结可以看到，set 与序列式容器的用法有以下几处不同： set 不支持 resize() 函数； set 容器不提供下标操作符。为了通过键从 set 中获取元素，可使用 find 运算； set 只能使用insert的两种重载函数插入，不支持 push_back() 和 push_front() 函数； set 不支持 STL 里的 reverse 和 sort 算法； set 能不通过迭代器，只通过元素值来删除该元素； set 只支持默认构造函数和拷贝构造函数，没有其它重载的构造函数。 map（字典）map 由红黑树实现，其元素都是 “键值/实值” 所形成的一个对组（key/value pairs)。map 主要用于资料一对一映射的情况，map 内部自建一颗红黑树，这颗树具有对数据自动排序的功能，所以在 map 内部所有的数据都是有序的。比如一个班级中，每个学生的学号跟他的姓名就存在着一对一映射的关系。 特点 每个元素都有一个键，且只能出现一次，不允许重复。 根据 key 值快速查找记录，查找的复杂度基本是 O(logN)，如果有 1000 个记录，二分查找最多查找 10次(1024)。（优点） 每次插入值的时候，都需要调整红黑树，效率有一定影响。（缺点） 增加和删除节点对迭代器的影响很小，除了那个操作节点，对其他的节点都没有什么影响。（优点） 对于迭代器来说，可以修改实值，而不能修改 key。总结：元素为键值对，key 和 value 可以是任意你需要的类型，每个元素都有一个键，且只能出现一次，不允许重复，根据 key 快速查找记录。适用场景适用于需要存储一个数据字典，并要求方便地根据key找value的场景。迭代器 开始迭代器指针：mp.begin(); 末尾迭代器指针：mp.end(); // 指向最后一个元素的下一个位置 指向常量的开始迭代器指针：mp.cbegin(); // 意思就是不能通过这个指针来修改所指的内容，但还是可以通过其他方式修改的，而且指针也是可以移动的。 指向常量的末尾迭代器指针：mp.cend(); 反向迭代器指针，指向最后一个元素：mp.rbegin(); 反向迭代器指针，指向第一个元素的前一个元素：mp.rend(); 返回最后一个 key&lt;=keyElem 元素的迭代器：mp.lower_bound(keyElem); 返回第一个 key&gt;keyElem 元素的迭代器：mp.upper_bound(keyElem); 返回容器中 key 与 keyElem 相等的上下限的两个迭代器，这两个迭代器被放在对组（pair）中：mp.equal_range(keyElem);1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;typedef map&lt;int, char&gt; MyMap;int main(int argc, char* argv[])&#123; // Create and populate the map MyMap mapTemp; for (int i = 0; i&lt;6; i++) &#123; mapTemp[i] = (&#x27;F&#x27;-i); &#125; // Display contents of map cout &lt;&lt;&quot;Original map: &quot; &lt;&lt;endl; MyMap::iterator it; for (it = mapTemp.begin(); it != mapTemp.end(); it++) &#123; cout &lt;&lt; (*it).first &lt;&lt; &quot; --&gt; &quot;; cout &lt;&lt; (*it).second &lt;&lt; std::endl; &#125; cout &lt;&lt;endl; return 0;&#125;/*输出结果：Original map:0 --&gt; F1 --&gt; E2 --&gt; D3 --&gt; C4 --&gt; B5 --&gt; A*/ 初始化使用之前必须加相应容器的头文件：1#include &lt;map&gt; // map属于std命名域的，因此需要通过命名限定，例如using std::map; 定义的代码如下：12345map&lt;int, string&gt; a; // 定义一个int类型的映射a// map&lt;int, string&gt; a(10); // error，未定义这种构造函数// map&lt;int, string&gt; a(10, 1); // error，未定义这种构造函数map&lt;int, string&gt; b(a); // 定义并用映射a初始化映射b// map&lt;int, string&gt; b(a.begin(), a.end()); // error，未定义这种构造函数 函数 容器大小：mp.size(); 容器最大容量：mp.max_size(); 容器判空：mp.empty(); 查找键 key 的元素个数：mp.count(key); 在容器中插入元素：mp.insert(const T&amp; x); 任意位置插入一个元素：mp.insert(iterator it, const T&amp; x); 删除键值为 keyValue 的元素：mp.erase(const T&amp; keyValue); 删除迭代器所指的元素：mp.erase(iterator it); 删除区间[first,last]之间的所有元素：mp.erase(iterator first, iterator last); 清空所有元素：mp.clear(); 查找键 key 是否存在，若存在，返回该键的元素的迭代器；若不存在，返回map.end()：mp.find(key); 交换两个同类型容器的元素：swap(map&amp;, map&amp;);或mp.swap(map&amp;);算法 遍历元素123map&lt;int&gt;::iterator it;for (it = mp.begin(); it != mp.end(); it++) cout &lt;&lt; it-&gt;second &lt;&lt; endl; 例子123456789101112131415161718192021222324252627282930#include &quot;stdafx.h&quot;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;string&gt;using namespace std;int main(int argc, char* argv[])&#123; map&lt;int, string&gt; mapTemp; mapTemp.insert(&#123; 5,&quot;张三&quot; &#125;); mapTemp.insert(&#123; 3, &quot;李四&quot;&#125;); mapTemp.insert(&#123; 4, &quot;隔壁老王&quot; &#125;); map&lt;int, string&gt;::iterator it; for (it = mapTemp.begin(); it != mapTemp.end(); it++) &#123; printf(&quot;学号：%d 姓名：%s\\n&quot;, (*it).first, (*it).second.c_str()); &#125; return 0;&#125;/*输出结果：学号：3 姓名：李四学号：4 姓名：隔壁老王学号：5 姓名：张三*/ multimap 和 map 相同，但允许重复元素，也就是说 multimap 可包含多个键值（key）相同的元素。这里不再做过多介绍。总结可以看到，map 与set的用法基本一致，只有以下一处不同： map 可以像数组那样插入元素，而 set 不行。 string（字符串）特殊容器。 迭代器1234567891011121314151617181920212223242526272829303132333435#define _SCL_SECURE_NO_WARNINGS #include &lt;iostream&gt;#include &lt;string&gt; //要与c语言里面的#include &lt;string.h&gt;区分using namespace std; int main()&#123; string str(&quot;abcdefg&quot;); string::iterator ite; ite = str.begin(); for (size_t i = 0; i &lt; str.size(); i++)&#123; cout &lt;&lt; *ite; ite++; &#125; ite = str.begin(); cout &lt;&lt; endl; for (size_t i = 0; i &lt; str.size(); i++)&#123; cout &lt;&lt; ite[i]; &#125; cout &lt;&lt; endl; ite = str.begin(); for (; ite != str.end(); ite++)&#123; cout &lt;&lt; *ite; &#125; cout &lt;&lt; endl; str.append(10, &#x27;a&#x27;); //cout &lt;&lt; ite[16] &lt;&lt; endl; 迭代器失效 system(&quot;pause&quot;); return 0;&#125; 初始化使用之前必须加上相应容器的头文件：1#include &lt;string&gt;定义的实现代码如下：12345string s1 = &quot;wty&quot;;string s2(s1);string s3 = s2;string s4(&quot;wangtianyang&quot;);string s5(10, &#x27;c&#x27;); 函数 字符串长度：str.length() 字符串长度：str.size() \\\\ 同上 at方法访问：str.at(1) 更改容器大小：str.resize(length + 10, &#39;a&#39;); //重新分配空间，将多余的十个空间分配a 清空容器：str.clear() 判空：str.empty() 末尾添加元素：str.append(&quot; hell0&quot;) 总结各容器的特点总结 vector 支持随机访问，在头部和中间插入或删除效率低，但在尾部插入或删除效率高。 支持随机访问，但效率没有 vector 高，在头部和尾部插入或删除效率高，但在中间插入或删除效率低。 list 不支持随机访问，在任意位置的插入和删除效率都较高。 set 由红黑树实现，其内部元素依据其值自动排序，每个元素值只能出现一次，不允许重复，且插入和删除效率比用其他序列容器高。 map 的元素为键值对，key 和 value 可以是任意你需要的类型，每个元素都有一个键，且只能出现一次，不允许重复，根据 key 快速查找记录。在实际使用过程中，到底选择这几种容器中的哪一个，应该根据遵循以下原则： 如果需要高效的随机访问，不在乎插入和删除的效率，使用 vector。 如果需要随机访问，并且关心两端数据的插入和删除效率，使用 deque。 如果需要大量的插入和删除元素，不关心随机访问的效率，使用 list。 如果经常查找一个元素是否在某集合中且需要排序，唯一存在的情况使用 set，不唯一存在的情况使用 multiset。 如果打算存储数据字典，并且要求方便地根据 key 找到 value，一对一的情况使用 map，一对多的情况使用 multimap。各容器的时间复杂度分析 vector 在头部和中间位置插入和删除的时间复杂度为 O(N)，在尾部插入和删除的时间复杂度为 O(1)，查找的时间复杂度为 O(1)； deque 在中间位置插入和删除的时间复杂度为 O(N)，在头部和尾部插入和删除的时间复杂度为 O(1)，查找的时间复杂度为 O(1)； list 在任意位置插入和删除的时间复杂度都为 O(1)，查找的时间复杂度为 O(N)； set 和 map 都是通过红黑树实现，因此插入、删除和查找操作的时间复杂度都是 O(log N)。各容器的共性各容器一般来说都有下列函数：默认构造函数、复制构造函数、析构函数、empty()、max_size()、size()、operator=、operator&lt;、operator&lt;=、operator&gt;、operator&gt;=、operator==、operator!=、swap()。顺序容器和关联容器都共有下列函数： begin() ：返回容器第一个元素的迭代器指针； end()：返回容器最后一个元素后面一位的迭代器指针； rbegin()：返回一个逆向迭代器指针，指向容器最后一个元素； rend()：返回一个逆向迭代器指针，指向容器首个元素前面一位； clear()：删除容器中的所有的元素； erase(it)：删除迭代器指针it处元素。","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"https://wangtianyang.com/tags/C/"}]},{"title":"Markdown教程","slug":"Markdown教程","date":"2022-01-12T10:14:22.000Z","updated":"2023-01-06T13:37:10.385Z","comments":true,"path":"2022/01/12/Markdown教程/","link":"","permalink":"https://wangtianyang.com/2022/01/12/Markdown%E6%95%99%E7%A8%8B/","excerpt":"标题格式使用 = 和 - 标记一级和二级标题123456此处为一级标题===正文此处为二级标题---正文 使用 /# 号标记使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题","text":"标题格式使用 = 和 - 标记一级和二级标题123456此处为一级标题===正文此处为二级标题---正文 使用 /# 号标记使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题显示效果： 字体123456*斜体文本\\_斜体文本\\_**粗体文本**__粗体文本__***粗斜体文本***___粗斜体文本___ 显示效果： 空格在半角输入状态下，Markdown只能识别一个空格，而要输出两个或以上空格，要么切换成全角输入，要么使用html的空格1234&amp;emsp; #占据一个中文宽度&amp;ensp; #占据半个中文宽度&amp;nbsp; #占据宽度受字体影响&amp;thinsp; #占据宽度最小 插入图片1.开头一个感叹号 !2.接着一个方括号，里面放上图片的替代文字，方括号里也可以省略3.接着一个普通括号，里面放上图片的网址或本地路径，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。本地路径分为绝对路径和相对路径： 绝对路径当Hexo项目中只用到少量图片时，可以将图片统一放在source/images文件夹中，通过markdown语法访问它们。1![](/images/image.jpg) 相对路径图片除了可以放在统一的images文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置_config.yml来生成。将_config.yml文件中的配置项post_asset_folder设为true后，执行命令$ hexo new post_name，在source/_posts中会生成文章post_name.md和同名文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。1![](image.jpg) 代码段落中代码段落中的函数或者代码片段可以用反引号 ` 包裹，例如：1`main()`函数显示效果：main()函数 代码块用 ``` 包裹一段代码，例如：123456789```cpp#include &lt;iostream&gt;using namespace std;int main()&#123; cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; endl; return 0;&#125;```显示效果：1234567#include &lt;iostream&gt;using namespace std;int main()&#123; cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; endl; return 0;&#125;注意：```` 的优先级大于 ```，因此可以在代码块内防止误解 转义Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：123456789101112\\ 反斜线` 反引号* 星号_ 下划线&#123;&#125; 花括号[] 方括号() 小括号# 井字号+ 加号- 减号. 英文句点! 感叹号 区块Markdown 区块引用是在段落开头使用 &gt; 符号，然后后面紧跟一个空格符号，并且区块可以嵌套：123&gt; 最外层&gt;&gt; 第一层嵌套&gt;&gt;&gt; 第二层嵌套显示效果： 列表Markdown 支持有序列表和无序列表。 无序列表无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个空格，然后再填写内容：1234567891011* 第一项* 第二项* 第三项+ 第一项+ 第二项+ 第三项- 第一项- 第二项- 第三项显示效果： 有序列表有序列表使用数字并加上 . 号来表示，如：1231. 第一项2. 第二项3. 第三项显示效果： 列表嵌套列表嵌套只需在子列表中的选项前面添加四个空格即可：1234561. 第一项： - 第一项嵌套的第一个元素 - 第一项嵌套的第二个元素2. 第二项： - 第二项嵌套的第一个元素 - 第二项嵌套的第二个元素显示效果：","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://wangtianyang.com/tags/Markdown/"}]},{"title":"JavaScript基础","slug":"JavaScript基础","date":"2022-01-12T09:57:06.000Z","updated":"2023-01-06T13:37:41.070Z","comments":true,"path":"2022/01/12/JavaScript基础/","link":"","permalink":"https://wangtianyang.com/2022/01/12/JavaScript%E5%9F%BA%E7%A1%80/","excerpt":"写在前面 JavaScript 对大小敏感 语句结尾分号可加可不加 JavaScript 不需要空格，一般为了代码可读性会向脚本添加空格，但JS解释执行时会忽略多余的空格 字符串可以用单引号或双引号 不同数据类型可以直接相加 回车符是&lt;br&gt; 获取对象长度是a.length","text":"写在前面 JavaScript 对大小敏感 语句结尾分号可加可不加 JavaScript 不需要空格，一般为了代码可读性会向脚本添加空格，但JS解释执行时会忽略多余的空格 字符串可以用单引号或双引号 不同数据类型可以直接相加 回车符是&lt;br&gt; 获取对象长度是a.length 变量JavaScript 使用关键字 var 来定义变量， 使用等号来为变量赋值：123456var num = 10; // 数字var a = b + c; // 表达式var x = true; // 布尔var name = &quot;vincent&quot;; // 字符串var nums = [1, 2, 3]; // 数组var ceo = &#123;firstName:&quot;Steve&quot;, lastName:&quot;Jobs&quot;&#125;; // 对象也可以使用关键词”new”来声明类型：12345var carname=new String;var x= new Number;var y= new Boolean;var cars= new Array;var person= new Object; undefined 和 nullundefined表示这个变量不含有值，可以通过将变量的值设为null来清空变量。 123var a; // undefineda = 10;a = null;函数JavaScript 语句可以写在函数内，函数可以重复引用： 123function myFunction(a, b) &#123; return a * b; // 返回 a 乘以 b 的结果&#125;对象对象由花括号分隔。在括号内部，对象的属性以名称和值对的形式 (name : value) 来定义。属性由逗号分隔：12345var person=&#123;firstname:&quot;John&quot;,lastname:&quot;Doe&quot;,fullName:function()&#123;&#125; // 创建对象方法&#125;;对象属性有两种寻址方式：12var name = person.lastname;var name = person[&quot;lastname&quot;]; 对象方法对象的方法定义了一个函数，并作为对象的属性存储。对象方法通过添加 () 调用 (作为一个函数)，注意调用对象方法和调用对象属性的区别： 12name = person.fullName(); // 调用对象方法name = person.fullName; // 调用对象属性运算符比较运算符 运算符 描述 == 等于 === 绝对等于（值和类型都相等） != 不等于 !== 不绝对等于（值和类型有一个不相等，或两个都不相等） &gt; 大于 &gt;= 大于等于 &lt; 小于 &lt;= 小于等于 逻辑运算符 运算符 描述 &amp;&amp; 与 \\ \\ 或 ! 非 条件运算符1variablename=(condition)?value1:value2条件语句在 JavaScript 中，我们可使用以下条件语句： if 语句 - 只有当指定条件为 true 时，使用该语句来执行代码 if…else 语句 - 当条件为 true 时执行代码，当条件为 false 时执行其他代码 if…else if….else 语句- 使用该语句来选择多个代码块之一来执行 switch 语句 - 使用该语句来选择多个代码块之一来执行if 语句1234if (condition)&#123; \\\\ 当条件为 true 时执行的代码&#125; if…else 语句12345678if (condition)&#123; \\\\ 当条件为 true 时执行的代码&#125;else&#123; \\\\ 当条件不为 true 时执行的代码&#125; if…else if….else 语句123456789101112if (condition1)&#123; \\\\ 当条件 1 为 true 时执行的代码&#125;else if (condition2)&#123; \\\\ 当条件 2 为 true 时执行的代码&#125;else&#123; \\\\当条件 1 和 条件 2 都不为 true 时执行的代码&#125; switch 语句首先设置表达式 n（通常是一个变量）。随后表达式的值会与结构中的每个 case 的值做比较。如果存在匹配，则与该 case 关联的代码块会被执行。注意：请使用 break 来阻止代码自动地向下一个 case 运行。使用 default 关键词来规定匹配不存在时做的事情：1234567891011switch(n)&#123; case 1: \\\\ 执行代码块 1 break; case 2: \\\\ 执行代码块 2 break; default: \\\\ 与 case 1 和 case 2 不同时执行的代码&#125; 循环语句JavaScript 支持不同类型的循环： for - 循环代码块一定的次数 for/in - 循环遍历对象的属性 while - 当指定的条件为 true 时循环指定的代码块 do/while - 同样当指定的条件为 true 时循环指定的代码块for 循环1234567for (语句 1; 语句 2; 语句 3)&#123; // 被执行的代码块&#125;// 语句 1 循环开始前执行// 语句 2 定义循环运行的条件// 语句 3 在每一次循环后执行 for/in 循环123456var txt = &quot;&quot;;var person=&#123;fname:&quot;Bill&quot;,lname:&quot;Gates&quot;,age:56&#125;; for (x in person) // x 为属性名&#123; txt=txt + person[x];&#125; while 循环1234while (条件)&#123; // 需要执行的代码&#125; do/while 循环12345do&#123; \\\\ 需要执行的代码&#125;while (条件); break 和 continue break跳出循环 continue继续下次循环 类型typeof 操作符typeof 操作符用来查看 JavaScript 变量的数据类型12345678910typeof &quot;John&quot; // 返回 stringtypeof 3.14 // 返回 numbertypeof NaN // 返回 numbertypeof false // 返回 booleantypeof [1,2,3,4] // 返回 objecttypeof &#123;name:&#x27;John&#x27;, age:34&#125; // 返回 objecttypeof new Date() // 返回 objecttypeof function () &#123;&#125; // 返回 functiontypeof myCar // 返回 undefined (如果 myCar 没有声明)typeof null // 返回 object constructor 属性constructor 属性返回所有 JavaScript 变量的构造函数1234567&quot;John&quot;.constructor // 返回函数 String() &#123; [native code] &#125;(3.14).constructor // 返回函数 Number() &#123; [native code] &#125;false.constructor // 返回函数 Boolean() &#123; [native code] &#125;[1,2,3,4].constructor // 返回函数 Array() &#123; [native code] &#125;&#123;name:&#x27;John&#x27;, age:34&#125;.constructor // 返回函数 Object() &#123; [native code] &#125;new Date().constructor // 返回函数 Date() &#123; [native code] &#125;function () &#123;&#125;.constructor // 返回函数 Function()&#123; [native code] &#125; 类型转换 方法 描述 实例 String() 数字、布尔值、日期转字符串 String(x)、String(true)、String(new Date()) ().toString 数字、布尔值、日期转字符串 x.toString() Number() 字符串、布尔值、日期转数字 Number(“3.14”)、Number(true)、Number(new Date())","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://wangtianyang.com/tags/JavaScript/"}]}],"categories":[{"name":"Issues","slug":"Issues","permalink":"https://wangtianyang.com/categories/Issues/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://wangtianyang.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"八股文","slug":"八股文","permalink":"https://wangtianyang.com/categories/%E5%85%AB%E8%82%A1%E6%96%87/"},{"name":"刷题笔记","slug":"刷题笔记","permalink":"https://wangtianyang.com/categories/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"},{"name":"科研笔记","slug":"科研笔记","permalink":"https://wangtianyang.com/categories/%E7%A7%91%E7%A0%94%E7%AC%94%E8%AE%B0/"},{"name":"面经","slug":"面经","permalink":"https://wangtianyang.com/categories/%E9%9D%A2%E7%BB%8F/"},{"name":"笔经","slug":"笔经","permalink":"https://wangtianyang.com/categories/%E7%AC%94%E7%BB%8F/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://wangtianyang.com/tags/Hexo/"},{"name":"Java","slug":"Java","permalink":"https://wangtianyang.com/tags/Java/"},{"name":"数据库","slug":"数据库","permalink":"https://wangtianyang.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"C++","slug":"C","permalink":"https://wangtianyang.com/tags/C/"},{"name":"算法","slug":"算法","permalink":"https://wangtianyang.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"操作系统","slug":"操作系统","permalink":"https://wangtianyang.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://wangtianyang.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Golang","slug":"Golang","permalink":"https://wangtianyang.com/tags/Golang/"},{"name":"Linux","slug":"Linux","permalink":"https://wangtianyang.com/tags/Linux/"},{"name":"数学","slug":"数学","permalink":"https://wangtianyang.com/tags/%E6%95%B0%E5%AD%A6/"},{"name":"网络安全","slug":"网络安全","permalink":"https://wangtianyang.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"Markdown","slug":"Markdown","permalink":"https://wangtianyang.com/tags/Markdown/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://wangtianyang.com/tags/JavaScript/"}]}